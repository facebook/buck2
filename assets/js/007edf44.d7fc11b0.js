"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[60977],{28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var r=n(96540);const l={},s=r.createContext(l);function i(e){const t=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:i(e.components),r.createElement(s.Provider,{value:t},e.children)}},38314:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>x,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"api/bxl/Context","title":"Context","description":"The bxl context that the top level bxl implementation receives as parameter. This context contains all the core bxl functions to query, build, create actions, etc.","source":"@site/../docs/api/bxl/Context.md","sourceDirName":"api/bxl","slug":"/api/bxl/Context","permalink":"/docs/api/bxl/Context","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"apiSidebar","previous":{"title":"ConfiguredTargetSet","permalink":"/docs/api/bxl/ConfiguredTargetSet"},"next":{"title":"CqueryContext","permalink":"/docs/api/bxl/CqueryContext"}}');var l=n(74848),s=n(28453),i=n(56289);const a={},o="Context",d={},c=[{value:"Context.analysis",id:"contextanalysis",level:2},{value:"Context.aquery",id:"contextaquery",level:2},{value:"Context.audit",id:"contextaudit",level:2},{value:"Context.build",id:"contextbuild",level:2},{value:"Context.bxl_actions",id:"contextbxl_actions",level:2},{value:"Context.cell_root",id:"contextcell_root",level:2},{value:"Context.cli_args",id:"contextcli_args",level:2},{value:"Context.configured_targets",id:"contextconfigured_targets",level:2},{value:"Context.cquery",id:"contextcquery",level:2},{value:"Context.fs",id:"contextfs",level:2},{value:"Context.instant_event",id:"contextinstant_event",level:2},{value:"Context.lazy",id:"contextlazy",level:2},{value:"Context.modifiers",id:"contextmodifiers",level:2},{value:"Context.output",id:"contextoutput",level:2},{value:"Context.resolve",id:"contextresolve",level:2},{value:"Context.root",id:"contextroot",level:2},{value:"Context.target_exists",id:"contexttarget_exists",level:2},{value:"Context.target_platform",id:"contexttarget_platform",level:2},{value:"Context.target_universe",id:"contexttarget_universe",level:2},{value:"Context.unconfigured_sub_targets",id:"contextunconfigured_sub_targets",level:2},{value:"Context.unconfigured_targets",id:"contextunconfigured_targets",level:2},{value:"Context.uquery",id:"contextuquery",level:2}];function h(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(t.header,{children:(0,l.jsx)(t.h1,{id:"context",children:"Context"})}),"\n",(0,l.jsx)(t.p,{children:"The bxl context that the top level bxl implementation receives as parameter. This context contains all the core bxl functions to query, build, create actions, etc."}),"\n",(0,l.jsx)(t.h2,{id:"contextanalysis",children:"Context.analysis"}),"\n",(0,l.jsx)("pre",{class:"language-python",children:(0,l.jsxs)("code",{children:["def Context.analysis(\nlabels: ",(0,l.jsx)(i.default,{to:"/docs/api/build/ConfiguredTargetLabel",children:"ConfiguredTargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/build/Label",children:"Label"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/ConfiguredTargetNode",children:"bxl.ConfiguredTargetNode"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/ConfiguredTargetSet",children:"target_set"})," | list[",(0,l.jsx)(i.default,{to:"/docs/api/build/ConfiguredTargetLabel",children:"ConfiguredTargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/build/Label",children:"Label"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/ConfiguredTargetNode",children:"bxl.ConfiguredTargetNode"}),"],\n*,\nskip_incompatible: ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/bool",children:"bool"})," = True,\n) -> None | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/AnalysisResult",children:"bxl.AnalysisResult"})," | dict[",(0,l.jsx)(i.default,{to:"/docs/api/build/Label",children:"Label"}),", ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/AnalysisResult",children:"bxl.AnalysisResult"}),"]"]})}),"\n",(0,l.jsxs)(t.p,{children:["Runs analysis on the given configured ",(0,l.jsx)(t.code,{children:"labels"}),", accepting an optional ",(0,l.jsx)(t.code,{children:"target_platform"})," which is the target platform configuration used to resolve configurations of any unconfigured target nodes, and an optional ",(0,l.jsx)(t.code,{children:"skip_incompatible"})," boolean that indicates whether to skip analysis of nodes that are incompatible with the target platform. The ",(0,l.jsx)(t.code,{children:"target_platform"})," is either a string that can be parsed as a target label, or a target label."]}),"\n",(0,l.jsxs)(t.p,{children:["The given ",(0,l.jsx)(t.code,{children:"labels"})," is a providers expression of configured targets, which is either:"]}),"\n",(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsx)(t.li,{children:"a single target node or label, configured"}),"\n",(0,l.jsx)(t.li,{children:"a single sub target label, configured"}),"\n",(0,l.jsx)(t.li,{children:"a list of the two options above."}),"\n",(0,l.jsx)(t.li,{children:"targetset of configured target labels"}),"\n"]}),"\n",(0,l.jsxs)(t.p,{children:["This returns either a single ",(0,l.jsx)(t.code,{children:"analysis_result"})," if the given ",(0,l.jsx)(t.code,{children:"labels"}),' argument is "singular",\nor a dict keyed by sub target labels of ',(0,l.jsx)(t.code,{children:"analysis"})," if the given ",(0,l.jsx)(t.code,{children:"labels"})," argument\nis list-like"]}),"\n",(0,l.jsx)(t.hr,{}),"\n",(0,l.jsx)(t.h2,{id:"contextaquery",children:"Context.aquery"}),"\n",(0,l.jsx)("pre",{class:"language-python",children:(0,l.jsxs)("code",{children:["def Context.aquery(\ntarget_platform: None | ",(0,l.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"})," = ...,\n) -> ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/AqueryContext",children:"bxl.AqueryContext"})]})}),"\n",(0,l.jsxs)(t.p,{children:["Returns the ",(0,l.jsx)(t.code,{children:"aqueryctx"})," that holds all the aquery functions. This function takes an optional parameter ",(0,l.jsx)(t.code,{children:"target_platform"}),", which is the target platform configuration used to configured any unconfigured target nodes."]}),"\n",(0,l.jsxs)(t.p,{children:["The ",(0,l.jsx)(t.code,{children:"target_platform"})," is a target label, or a string that is a target label."]}),"\n",(0,l.jsx)(t.hr,{}),"\n",(0,l.jsx)(t.h2,{id:"contextaudit",children:"Context.audit"}),"\n",(0,l.jsx)("pre",{class:"language-python",children:(0,l.jsxs)("code",{children:["def Context.audit(\n) -> ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/AuditContext",children:"bxl.AuditContext"})]})}),"\n",(0,l.jsxs)(t.p,{children:["Returns the ",(0,l.jsx)(t.code,{children:"audit_ctx"})," that holds all the audit functions."]}),"\n",(0,l.jsx)(t.hr,{}),"\n",(0,l.jsx)(t.h2,{id:"contextbuild",children:"Context.build"}),"\n",(0,l.jsx)("pre",{class:"language-python",children:(0,l.jsxs)("code",{children:["def Context.build(\nlabels: ",(0,l.jsx)(i.default,{to:"/docs/api/build/ConfiguredTargetLabel",children:"ConfiguredTargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/build/Label",children:"Label"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/build/ProvidersLabel",children:"ProvidersLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/ConfiguredTargetNode",children:"bxl.ConfiguredTargetNode"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetNode",children:"bxl.UnconfiguredTargetNode"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetSet",children:"target_set"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/ConfiguredTargetSet",children:"target_set"})," | list[",(0,l.jsx)(i.default,{to:"/docs/api/build/ConfiguredTargetLabel",children:"ConfiguredTargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/build/Label",children:"Label"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/build/ProvidersLabel",children:"ProvidersLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/ConfiguredTargetNode",children:"bxl.ConfiguredTargetNode"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetNode",children:"bxl.UnconfiguredTargetNode"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"}),"],\ntarget_platform: None | ",(0,l.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"})," = ...,\n*,\nmaterializations: ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"}),' = "default",\n) -> dict[',(0,l.jsx)(i.default,{to:"/docs/api/build/Label",children:"Label"}),", ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/BuildResult",children:"bxl.BuildResult"}),"]"]})}),"\n",(0,l.jsxs)(t.p,{children:["Runs a build on the given ",(0,l.jsx)(t.code,{children:"labels"}),", accepting an optional ",(0,l.jsx)(t.code,{children:"target_platform"})," which is the target platform configuration used to resolve configurations. Note that when ",(0,l.jsx)(t.code,{children:"build()"})," is called, the artifacts are materialized without needing to additionally call ",(0,l.jsx)(t.code,{children:"ensure()"})," on them."]}),"\n",(0,l.jsxs)(t.p,{children:["The given ",(0,l.jsx)(t.code,{children:"labels"})," is a providers expression, which is either:"]}),"\n",(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsxs)(t.li,{children:["a single string that is a ",(0,l.jsx)(t.code,{children:"target pattern"}),"."]}),"\n",(0,l.jsx)(t.li,{children:"a single target node or label, configured or unconfigured"}),"\n",(0,l.jsx)(t.li,{children:"a single provider label, configured or unconfigured"}),"\n",(0,l.jsx)(t.li,{children:"a list of the two options above."}),"\n"]}),"\n",(0,l.jsx)(t.p,{children:"materializations can be one of:"}),"\n",(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsxs)(t.li,{children:['"default"',"\n",(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsx)(t.li,{children:"defer to the configuration settings to decide whether to materialize or not"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(t.li,{children:['"materialize"',"\n",(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsx)(t.li,{children:"force materialization of build results at the end of the build."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(t.li,{children:['"skip"',"\n",(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsx)(t.li,{children:"skip materialization of the build results"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(t.p,{children:["This returns a dict keyed by sub target labels mapped to ",(0,l.jsx)(t.code,{children:"bxl_build_result"}),"s if the\ngiven ",(0,l.jsx)(t.code,{children:"labels"})," argument is list-like."]}),"\n",(0,l.jsxs)(t.p,{children:["This function is not available on the ",(0,l.jsx)(t.code,{children:"bxl_ctx"})," when called from ",(0,l.jsx)(t.code,{children:"dynamic_output"}),"."]}),"\n",(0,l.jsx)(t.hr,{}),"\n",(0,l.jsx)(t.h2,{id:"contextbxl_actions",children:"Context.bxl_actions"}),"\n",(0,l.jsx)("pre",{class:"language-python",children:(0,l.jsxs)("code",{children:["def Context.bxl_actions(\n*,\nexec_deps: None | ",(0,l.jsx)(i.default,{to:"/docs/api/build/ProvidersLabel",children:"ProvidersLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetNode",children:"bxl.UnconfiguredTargetNode"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetSet",children:"target_set"})," | list[",(0,l.jsx)(i.default,{to:"/docs/api/build/ProvidersLabel",children:"ProvidersLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetNode",children:"bxl.UnconfiguredTargetNode"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"}),"] = None,\ntoolchains: None | ",(0,l.jsx)(i.default,{to:"/docs/api/build/ProvidersLabel",children:"ProvidersLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetNode",children:"bxl.UnconfiguredTargetNode"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetSet",children:"target_set"})," | list[",(0,l.jsx)(i.default,{to:"/docs/api/build/ProvidersLabel",children:"ProvidersLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetNode",children:"bxl.UnconfiguredTargetNode"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"}),"] = None,\ntarget_platform: None | ",(0,l.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"})," = ...,\nexec_compatible_with: None | ",(0,l.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetNode",children:"bxl.UnconfiguredTargetNode"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetSet",children:"target_set"})," | list[",(0,l.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetNode",children:"bxl.UnconfiguredTargetNode"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"}),"] = None,\n) -> ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/Actions",children:"bxl.Actions"})]})}),"\n",(0,l.jsx)(t.p,{children:"Returns the bxl actions to create and register actions for this bxl function. This will have the execution platform resolved according to the execution deps and toolchains you pass into this function. You'll be able to access the analysis action factory of the correct execution platform, toolchains, and execution deps of the corresponding configuration via this context."}),"\n",(0,l.jsxs)(t.p,{children:["Actions created by bxl will not be built by default. Instead, they are marked to be built\nby ",(0,l.jsx)(t.code,{children:"ctx.output.ensure(artifact)"})," on the output module of the ",(0,l.jsx)(t.code,{children:"bxl_ctx"}),". Only artifacts\nmarked by ensure will be built."]}),"\n",(0,l.jsx)(t.p,{children:"Sample usage:"}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-python",children:'def _impl_write_action(ctx):\n    bxl_actions = ctx.bxl_actions()\n    output = bxl_actions.actions.write("my_output", "my_content")\n    ensured = ctx.output.ensure(output)\n    ctx.output.print(ensured)\n'})}),"\n",(0,l.jsx)(t.p,{children:"There are several optional named parameters:"}),"\n",(0,l.jsxs)(t.p,{children:[(0,l.jsx)(t.code,{children:"exec_deps"})," - These are dependencies you wish to access as executables for creating the action.\nThis is usually the same set of targets one would pass to rule's ",(0,l.jsx)(t.code,{children:"attr.exec_dep"}),".\n",(0,l.jsx)(t.code,{children:"toolchains"})," - The set of toolchains needed for the actions you intend to create.\n",(0,l.jsx)(t.code,{children:"target_platform"})," - The intended target platform for your toolchains\n",(0,l.jsx)(t.code,{children:"exec_compatible_with"})," - Explicit list of configuration nodes (like platforms or constraints)\nthat these actions are compatible with. This is the 'exec_compatible_with' attribute of a target."]}),"\n",(0,l.jsxs)(t.p,{children:["If you passed in ",(0,l.jsx)(t.code,{children:"exec_deps"})," or ",(0,l.jsx)(t.code,{children:"toolchains"}),", you can access the resolved dependencies using the ",(0,l.jsx)(t.code,{children:"exec_deps"}),"\nand ",(0,l.jsx)(t.code,{children:"toolchains"})," attributes on the ",(0,l.jsx)(t.code,{children:"bxl_actions"}),", which both return a ",(0,l.jsx)(t.code,{children:"dict"})," of unconfigured subtarget labels\nand their configured/resolved ",(0,l.jsx)(t.code,{children:"dependency"})," objects."]}),"\n",(0,l.jsxs)(t.p,{children:["Note that the keys of ",(0,l.jsx)(t.code,{children:"exec_deps"})," and ",(0,l.jsx)(t.code,{children:"toolchains"})," must be unconfigured subtarget labels (",(0,l.jsx)(t.code,{children:"providers_label"}),"s),\nand not unconfigured target labels. You can use ",(0,l.jsx)(t.code,{children:"ctx.unconfigured_sub_targets(...)"})," or ",(0,l.jsx)(t.code,{children:"with_sub_target()"})," on\n",(0,l.jsx)(t.code,{children:"target_label"})," to create the label."]}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-python",children:'def _impl_run_action(ctx):\n   my_exec_dep = ctx.unconfigured_sub_targets("foo//bar:baz") # has some provider that you would use in the action\n   bxl_actions = ctx.bxl_actions(exec_deps = [my_exec_dep]) # call once, reuse wherever needed\n   output = bxl_actions.actions.run(\n       [\n           "python3",\n           bxl_actions.exec_deps[my_exec_dep][RunInfo], # access resolved exec_deps on the `bxl_actions`\n           out.as_output(),\n       ],\n       category = "command",\n       local_only = True,\n   )\n   ctx.output.ensure(output)\n'})}),"\n",(0,l.jsxs)(t.p,{children:["When called from a ",(0,l.jsx)(t.code,{children:"dynamic_output"}),", ",(0,l.jsx)(t.code,{children:"bxl_actions()"})," cannot be configured with a different execution\nplatform resolution from the parent BXL."]}),"\n",(0,l.jsx)(t.hr,{}),"\n",(0,l.jsx)(t.h2,{id:"contextcell_root",children:"Context.cell_root"}),"\n",(0,l.jsx)("pre",{class:"language-python",children:(0,l.jsxs)("code",{children:["def Context.cell_root() -> ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"})]})}),"\n",(0,l.jsx)(t.p,{children:"Returns the absolute path to the cell of the repository"}),"\n",(0,l.jsxs)(t.p,{children:["This function is not available on the ",(0,l.jsx)(t.code,{children:"bxl_ctx"})," when called from ",(0,l.jsx)(t.code,{children:"dynamic_output"}),"."]}),"\n",(0,l.jsx)(t.hr,{}),"\n",(0,l.jsx)(t.h2,{id:"contextcli_args",children:"Context.cli_args"}),"\n",(0,l.jsx)("pre",{class:"language-python",children:(0,l.jsx)("code",{children:"Context.cli_args: struct(..)"})}),"\n",(0,l.jsxs)(t.p,{children:["A struct of the command line args as declared using the [",(0,l.jsx)(t.code,{children:"cli_args"}),"] module. These command lines are resolved per the users input on the cli when invoking the bxl script."]}),"\n",(0,l.jsxs)(t.p,{children:["If you wish to pass in a kebab-cased arg, the arg accessed from the BXL context's ",(0,l.jsx)(t.code,{children:"cli_args"}),"\nattribute will always be in snakecase. For example, if you passed in ",(0,l.jsx)(t.code,{children:"my-arg"}),", accessing it\nwithin BXL would look like ",(0,l.jsx)(t.code,{children:"ctx.cli_args.my_arg"}),"."]}),"\n",(0,l.jsx)(t.p,{children:"This attribute is not available on the bxl context within the a dynamic lambda."}),"\n",(0,l.jsx)(t.hr,{}),"\n",(0,l.jsx)(t.h2,{id:"contextconfigured_targets",children:"Context.configured_targets"}),"\n",(0,l.jsx)("pre",{class:"language-python",children:(0,l.jsxs)("code",{children:["def Context.configured_targets(\nlabels: ",(0,l.jsx)(i.default,{to:"/docs/api/build/ConfiguredTargetLabel",children:"ConfiguredTargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/ConfiguredTargetNode",children:"bxl.ConfiguredTargetNode"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetNode",children:"bxl.UnconfiguredTargetNode"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/ConfiguredTargetSet",children:"target_set"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetSet",children:"target_set"})," | list[",(0,l.jsx)(i.default,{to:"/docs/api/build/ConfiguredTargetLabel",children:"ConfiguredTargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/ConfiguredTargetNode",children:"bxl.ConfiguredTargetNode"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetNode",children:"bxl.UnconfiguredTargetNode"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"}),"],\n/,\ntarget_platform: None | ",(0,l.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"})," = ...,\n*,\nmodifiers: None | list[",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"}),"] = None,\n) -> None | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/ConfiguredTargetNode",children:"bxl.ConfiguredTargetNode"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/ConfiguredTargetSet",children:"target_set"})]})}),"\n",(0,l.jsxs)(t.p,{children:["Gets the target nodes for the ",(0,l.jsx)(t.code,{children:"labels"}),", accepting an optional ",(0,l.jsx)(t.code,{children:"target_platform"})," which is the target platform configuration used to resolve configurations of any unconfigured target nodes. The ",(0,l.jsx)(t.code,{children:"target_platform"})," is either a string that can be parsed as a target label, or a target label."]}),"\n",(0,l.jsxs)(t.p,{children:["The given ",(0,l.jsx)(t.code,{children:"labels"})," is a [",(0,l.jsx)(t.code,{children:"TargetListExpr"}),"], which is either:"]}),"\n",(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsxs)(t.li,{children:["a single string that is a ",(0,l.jsx)(t.code,{children:"target pattern"}),"."]}),"\n",(0,l.jsx)(t.li,{children:"a single target node or label, configured or unconfigured"}),"\n",(0,l.jsx)(t.li,{children:"a list of the two options above."}),"\n"]}),"\n",(0,l.jsxs)(t.p,{children:["Note that this function does not accept ",(0,l.jsx)(t.code,{children:"Label"})," (which is a configured provider label), since this\nis the label of a subtarget. You can get the underlying configured target label on the ",(0,l.jsx)(t.code,{children:"Label"}),"\nusing ",(0,l.jsx)(t.code,{children:"configured_targets()"})," (ex: ",(0,l.jsx)(t.code,{children:"my_label.configured_target()"}),")."]}),"\n",(0,l.jsxs)(t.p,{children:["This returns either a single ",(0,l.jsx)(t.code,{children:"target_node"})," if the given ",(0,l.jsx)(t.code,{children:"labels"}),'\nis "singular", a dict keyed by target labels of ',(0,l.jsx)(t.code,{children:"target_node"})," if the\ngiven ",(0,l.jsx)(t.code,{children:"labels"})," is list-like"]}),"\n",(0,l.jsx)(t.hr,{}),"\n",(0,l.jsx)(t.h2,{id:"contextcquery",children:"Context.cquery"}),"\n",(0,l.jsx)("pre",{class:"language-python",children:(0,l.jsxs)("code",{children:["def Context.cquery(\ntarget_platform: None | ",(0,l.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"})," = ...,\n) -> ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/CqueryContext",children:"bxl.CqueryContext"})]})}),"\n",(0,l.jsxs)(t.p,{children:["Returns the ",(0,l.jsx)(t.code,{children:"cqueryctx"})," that holds all the cquery functions. This function takes an optional parameter ",(0,l.jsx)(t.code,{children:"target_platform"}),", which is the target platform configuration used to configured any unconfigured target nodes."]}),"\n",(0,l.jsxs)(t.p,{children:["The ",(0,l.jsx)(t.code,{children:"target_platform"})," is a target label, or a string that is a target label."]}),"\n",(0,l.jsx)(t.hr,{}),"\n",(0,l.jsx)(t.h2,{id:"contextfs",children:"Context.fs"}),"\n",(0,l.jsx)("pre",{class:"language-python",children:(0,l.jsxs)("code",{children:["Context.fs: ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/Filesystem",children:"bxl.Filesystem"})]})}),"\n",(0,l.jsxs)(t.p,{children:["Returns the ",(0,l.jsx)(t.code,{children:"bxl.Filesystem"})," for performing a basic set of filesystem operations within bxl"]}),"\n",(0,l.jsx)(t.hr,{}),"\n",(0,l.jsx)(t.h2,{id:"contextinstant_event",children:"Context.instant_event"}),"\n",(0,l.jsx)("pre",{class:"language-python",children:(0,l.jsxs)("code",{children:["def Context.instant_event(\n*,\nid: ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"}),",\nmetadata,\n) -> None"]})}),"\n",(0,l.jsx)(t.p,{children:"Emits a user-defined instant event, taking in a required string id and a metadata dictionary where the keys are strings, and values are either strings, bools, or ints. The id is user-supplied, and used to identify the instant events in the event logs more easily."}),"\n",(0,l.jsx)(t.p,{children:"You may pass in an ensured artifact as a value in the metadata. The resulting output would be the ensured\nartifact's relative or absolute path as a string."}),"\n",(0,l.jsx)(t.hr,{}),"\n",(0,l.jsx)(t.h2,{id:"contextlazy",children:"Context.lazy"}),"\n",(0,l.jsx)("pre",{class:"language-python",children:(0,l.jsxs)("code",{children:["Context.lazy: ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/LazyContext",children:"bxl.LazyContext"})]})}),"\n",(0,l.jsx)(t.p,{children:"Lazy/batch/error handling operations."}),"\n",(0,l.jsx)(t.hr,{}),"\n",(0,l.jsx)(t.h2,{id:"contextmodifiers",children:"Context.modifiers"}),"\n",(0,l.jsx)("pre",{class:"language-python",children:(0,l.jsxs)("code",{children:["Context.modifiers: list[",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"}),"]"]})}),"\n",(0,l.jsxs)(t.p,{children:["The modifiers from the bxl invocation. It is from the ",(0,l.jsx)(t.code,{children:"--modifier"})," flag."]}),"\n",(0,l.jsx)(t.hr,{}),"\n",(0,l.jsx)(t.h2,{id:"contextoutput",children:"Context.output"}),"\n",(0,l.jsx)("pre",{class:"language-python",children:(0,l.jsxs)("code",{children:["Context.output: ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/OutputStream",children:"bxl.OutputStream"})]})}),"\n",(0,l.jsx)(t.p,{children:"Gets the output stream to the console via stdout. Items written to the output stream are considered to be the results of a bxl script, which will be displayed to stdout by buck2 even when the script is cached."}),"\n",(0,l.jsxs)(t.p,{children:["Prints that are not result of the bxl should be printed via stderr via the stdlib ",(0,l.jsx)(t.code,{children:"print"}),"\nand ",(0,l.jsx)(t.code,{children:"pprint"}),"."]}),"\n",(0,l.jsxs)(t.p,{children:["This function is not available on the ",(0,l.jsx)(t.code,{children:"bxl_ctx"})," when called from ",(0,l.jsx)(t.code,{children:"dynamic_output"}),"."]}),"\n",(0,l.jsx)(t.hr,{}),"\n",(0,l.jsx)(t.h2,{id:"contextresolve",children:"Context.resolve"}),"\n",(0,l.jsx)("pre",{class:"language-python",children:(0,l.jsxs)("code",{children:["def Context.resolve(\naction_factory: ",(0,l.jsx)(i.default,{to:"/docs/api/build/AnalysisActions",children:"AnalysisActions"}),",\npromise: ",(0,l.jsx)(i.default,{to:"/docs/api/build/Promise",children:"Promise"}),",\n)"]})}),"\n",(0,l.jsx)(t.p,{children:"Awaits a promise and returns an optional value of the promise."}),"\n",(0,l.jsx)(t.p,{children:"Sample usage:"}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-python",children:'load("//path/to/rules:rules.bzl", "my_anon_targets_rule", "my_map_function")\n\ndef _resolve_impl(ctx):\n    actions = ctx.bxl_actions().actions\n    my_attrs = {\n        "false": False,\n        "int": 42,\n        "list_string": ["a", "b", "c"],\n        "string": "a-string",\n        "true": True,\n    }\n\n    promise = actions.anon_target(my_anon_targets_rule, attrs).promise.map(my_map_function)\n    providers_result = ctx.resolve(actions, promise) # result is `ProviderCollection` type, which is a collection of `Provider`s\n    ctx.output.print(providers_result[0].my_field)\n'})}),"\n",(0,l.jsx)(t.hr,{}),"\n",(0,l.jsx)(t.h2,{id:"contextroot",children:"Context.root"}),"\n",(0,l.jsx)("pre",{class:"language-python",children:(0,l.jsxs)("code",{children:["def Context.root() -> ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"})]})}),"\n",(0,l.jsx)(t.p,{children:"Returns the absolute path to the root of the repository"}),"\n",(0,l.jsxs)(t.p,{children:["This function is not available on the ",(0,l.jsx)(t.code,{children:"bxl_ctx"})," when called from ",(0,l.jsx)(t.code,{children:"dynamic_output"}),"."]}),"\n",(0,l.jsx)(t.hr,{}),"\n",(0,l.jsx)(t.h2,{id:"contexttarget_exists",children:"Context.target_exists"}),"\n",(0,l.jsx)("pre",{class:"language-python",children:(0,l.jsxs)("code",{children:["def Context.target_exists(\nlabel: ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"}),",\n) -> ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/bool",children:"bool"})]})}),"\n",(0,l.jsx)(t.p,{children:"Checks if a target label exists. Target label must be a string literal, and an exact target."}),"\n",(0,l.jsx)(t.hr,{}),"\n",(0,l.jsx)(t.h2,{id:"contexttarget_platform",children:"Context.target_platform"}),"\n",(0,l.jsx)("pre",{class:"language-python",children:(0,l.jsxs)("code",{children:["Context.target_platform: None | ",(0,l.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})]})}),"\n",(0,l.jsxs)(t.p,{children:["The target_platform from the bxl invocation. It is from the ",(0,l.jsx)(t.code,{children:"--target-platforms"})," flag."]}),"\n",(0,l.jsx)(t.hr,{}),"\n",(0,l.jsx)(t.h2,{id:"contexttarget_universe",children:"Context.target_universe"}),"\n",(0,l.jsx)("pre",{class:"language-python",children:(0,l.jsxs)("code",{children:["def Context.target_universe(\nlabels: ",(0,l.jsx)(i.default,{to:"/docs/api/build/ConfiguredTargetLabel",children:"ConfiguredTargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/ConfiguredTargetNode",children:"bxl.ConfiguredTargetNode"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetNode",children:"bxl.UnconfiguredTargetNode"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/ConfiguredTargetSet",children:"target_set"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetSet",children:"target_set"})," | list[",(0,l.jsx)(i.default,{to:"/docs/api/build/ConfiguredTargetLabel",children:"ConfiguredTargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/ConfiguredTargetNode",children:"bxl.ConfiguredTargetNode"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetNode",children:"bxl.UnconfiguredTargetNode"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"}),"],\ntarget_platform: None | ",(0,l.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"})," = ...,\n*,\nkeep_going: ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/bool",children:"bool"})," = False,\nmodifiers: list[",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"}),"] = [],\n) -> ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/TargetUniverse",children:"bxl.TargetUniverse"})]})}),"\n",(0,l.jsxs)(t.p,{children:["Returns the ",(0,l.jsx)(t.code,{children:"TargetUniverse"})," that can lookup valid configured nodes in the universe."]}),"\n",(0,l.jsxs)(t.p,{children:["The given ",(0,l.jsx)(t.code,{children:"labels"})," is a target expression, which is either:"]}),"\n",(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsxs)(t.li,{children:["a single string that is a ",(0,l.jsx)(t.code,{children:"target pattern"}),"."]}),"\n",(0,l.jsx)(t.li,{children:"a single target node or label, configured or unconfigured"}),"\n",(0,l.jsx)(t.li,{children:"a single subtarget label, configured or unconfigured"}),"\n",(0,l.jsx)(t.li,{children:"a list of the two options above."}),"\n"]}),"\n",(0,l.jsxs)(t.p,{children:["Also takes in an optional ",(0,l.jsx)(t.code,{children:"target_platform"})," param to configure the nodes with, and a ",(0,l.jsx)(t.code,{children:"keep_going"}),"\nflag to skip any loading or configuration errors. Note that ",(0,l.jsx)(t.code,{children:"keep_going"})," currently can only be used\nif the input labels is a single target pattern as a string literal."]}),"\n",(0,l.jsxs)(t.p,{children:["The default modifiers used to configure the target nodes are empty. If you want to use the\nmodifiers from the cli, you can pass ",(0,l.jsx)(t.code,{children:"ctx.modifiers"})," to the argument ",(0,l.jsx)(t.code,{children:"modifiers"})," of this function."]}),"\n",(0,l.jsx)(t.hr,{}),"\n",(0,l.jsx)(t.h2,{id:"contextunconfigured_sub_targets",children:"Context.unconfigured_sub_targets"}),"\n",(0,l.jsx)("pre",{class:"language-python",children:(0,l.jsxs)("code",{children:["def Context.unconfigured_sub_targets(\nlabels: ",(0,l.jsx)(i.default,{to:"/docs/api/build/ProvidersLabel",children:"ProvidersLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetNode",children:"bxl.UnconfiguredTargetNode"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetSet",children:"target_set"})," | list[",(0,l.jsx)(i.default,{to:"/docs/api/build/ProvidersLabel",children:"ProvidersLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetNode",children:"bxl.UnconfiguredTargetNode"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"}),"],\n) -> ",(0,l.jsx)(i.default,{to:"/docs/api/build/ProvidersLabel",children:"ProvidersLabel"})," | dict[",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"}),", ",(0,l.jsx)(i.default,{to:"/docs/api/build/ProvidersLabel",children:"ProvidersLabel"}),"]"]})}),"\n",(0,l.jsxs)(t.p,{children:["Gets the unconfigured subtargets for the given ",(0,l.jsx)(t.code,{children:"labels"})]}),"\n",(0,l.jsxs)(t.p,{children:["The given ",(0,l.jsx)(t.code,{children:"labels"})," is a providers expression, which is either:"]}),"\n",(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsxs)(t.li,{children:["a single string that is a ",(0,l.jsx)(t.code,{children:"target pattern"}),"."]}),"\n",(0,l.jsx)(t.li,{children:"a single target node or label, configured or unconfigured"}),"\n",(0,l.jsx)(t.li,{children:"a single subtarget label, configured or unconfigured"}),"\n",(0,l.jsx)(t.li,{children:"a list of the two options above."}),"\n"]}),"\n",(0,l.jsxs)(t.p,{children:["This returns either a single ",(0,l.jsx)(t.code,{children:"providers_label"})," if the given ",(0,l.jsx)(t.code,{children:"labels"}),' argument\nis "singular", or dict of the subtarget string representation to the\n',(0,l.jsx)(t.code,{children:"providers_label"})," if the given ",(0,l.jsx)(t.code,{children:"labels"})," argument is list-like."]}),"\n",(0,l.jsx)(t.p,{children:"Note that this function does not check that this subtarget exists in the repo."}),"\n",(0,l.jsx)(t.hr,{}),"\n",(0,l.jsx)(t.h2,{id:"contextunconfigured_targets",children:"Context.unconfigured_targets"}),"\n",(0,l.jsx)("pre",{class:"language-python",children:(0,l.jsxs)("code",{children:["def Context.unconfigured_targets(\nlabels: ",(0,l.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetNode",children:"bxl.UnconfiguredTargetNode"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetSet",children:"target_set"})," | list[",(0,l.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetNode",children:"bxl.UnconfiguredTargetNode"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"}),"],\n) -> ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetNode",children:"bxl.UnconfiguredTargetNode"})," | ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetSet",children:"target_set"})]})}),"\n",(0,l.jsxs)(t.p,{children:["Gets the unconfigured target nodes for the ",(0,l.jsx)(t.code,{children:"labels"})]}),"\n",(0,l.jsxs)(t.p,{children:["The given ",(0,l.jsx)(t.code,{children:"labels"})," is either:"]}),"\n",(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsxs)(t.li,{children:["a single string that is a ",(0,l.jsx)(t.code,{children:"target pattern"}),"."]}),"\n",(0,l.jsx)(t.li,{children:"a single unconfigured  target node or label"}),"\n",(0,l.jsx)(t.li,{children:"a list of the two options above."}),"\n"]}),"\n",(0,l.jsxs)(t.p,{children:["This returns either a single ",(0,l.jsx)(t.code,{children:"UnconfiguredTargetNode"})," if the given ",(0,l.jsx)(t.code,{children:"labels"}),'\nis "singular", a dict keyed by target labels of ',(0,l.jsx)(t.code,{children:"UnconfiguredTargetNode"})," if the\ngiven ",(0,l.jsx)(t.code,{children:"labels"})," is list-like"]}),"\n",(0,l.jsx)(t.hr,{}),"\n",(0,l.jsx)(t.h2,{id:"contextuquery",children:"Context.uquery"}),"\n",(0,l.jsx)("pre",{class:"language-python",children:(0,l.jsxs)("code",{children:["def Context.uquery(\n) -> ",(0,l.jsx)(i.default,{to:"/docs/api/bxl/UqueryContext",children:"bxl.UqueryContext"})]})}),"\n",(0,l.jsxs)(t.p,{children:["Returns the ",(0,l.jsx)(t.code,{children:"uqueryctx"})," that holds all uquery functions."]})]})}function x(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,l.jsx)(t,{...e,children:(0,l.jsx)(h,{...e})}):h(e)}}}]);