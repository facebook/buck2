/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under both the MIT license found in the
 * LICENSE-MIT file in the root directory of this source tree and the Apache
 * License, Version 2.0 found in the LICENSE-APACHE file in the root directory
 * of this source tree.
 */

syntax = "proto3";

import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";
import "error.proto";

package buck.data;

// A single event originating from Buck. Its semantics depend on the `data`
// member.
message BuckEvent {
  reserved 2047;

  // A timestamp for when this event was fired, taken from the system clock.
  // Required.
  google.protobuf.Timestamp timestamp = 1;
  // A globally-unique ID (UUIDv4) of this trace. Required.
  string trace_id = 2;
  // A trace-unique 64-bit integer identifying this event's span ID, if this
  // event begins a new span or belongs to one.
  uint64 span_id = 3;
  // A trace-unique 64-bit identifying the span that this event is logically
  // parented to.
  uint64 parent_id = 4;
  // The payload of this event. Required.
  oneof data {
    SpanStartEvent span_start = 20;
    SpanEndEvent span_end = 21;
    InstantEvent instant = 22;
    // Not present in daemon -> CLI stream or event-log, sent to Scribe
    // directly.
    RecordEvent record = 23;
  }
}

// An event that begins a span.
message SpanStartEvent {
  reserved 83;
  // TODO(swgillespie) add fields common to span events
  // bool suspending = 1;
  oneof data {
    CommandStart command = 50;
    ActionExecutionStart action_execution = 51;
    AnalysisStart analysis = 52;
    LoadBuildFileStart load = 53;
    ExecutorStageStart executor_stage = 54;
    TestDiscoveryStart test_discovery = 55;
    TestRunStart test_start = 56;
    FileWatcherStart file_watcher = 57;
    MaterializeRequestedArtifactStart final_materialization = 58;
    AnalysisStageStart analysis_stage = 59;
    MatchDepFilesStart match_dep_files = 60;
    LoadPackageStart load_package = 61;
    SharedTaskStart shared_task = 62;
    CacheUploadStart cache_upload = 63;
    CreateOutputSymlinksStart create_output_symlinks = 64;
    CommandCriticalStart command_critical = 65;
    InstallEventInfoStart install_event_info = 66;
    DiceStateUpdateStart dice_state_update = 67;
    MaterializationStart materialization = 68;
    DiceCriticalSectionStart dice_critical_section = 69;
    DiceBlockConcurrentCommandStart dice_block_concurrent_command = 70;
    DiceSynchronizeSectionStart dice_synchronize_section = 71;
    DiceCleanupStart dice_cleanup = 72;
    ExclusiveCommandWaitStart exclusive_command_wait = 73;
    DeferredPreparationStageStart deferred_preparation_stage = 74;
    DynamicLambdaStart dynamic_lambda = 75;
    BxlExecutionStart bxl_execution = 76;
    BxlDiceInvocationStart bxl_dice_invocation = 77;
    ReUploadStart re_upload = 78;
    ConnectToInstallerStart connect_to_installer = 79;
    SetupLocalResourcesStart local_resources = 80;
    ReleaseLocalResourcesStart release_local_resources = 81;
    // Measure total time it takes to ensure BXL artifacts.
    BxlEnsureArtifactsStart bxl_ensure_artifacts = 82;
    CreateOutputHashesFileStart create_output_hashes_file = 84;
    ActionErrorHandlerExecutionStart action_error_handler_execution = 85;
    CqueryUniverseBuildStart cquery_universe_build = 87;
    // Used in Buck unit tests.
    FakeStart fake = 999;
  }
}

// An event that ends a span.
message SpanEndEvent {
  reserved 84;
  SpanStats stats = 1;
  // The total duration of this span, as observed by the client.
  google.protobuf.Duration duration = 2;

  oneof data {
    CommandEnd command = 50;
    ActionExecutionEnd action_execution = 51;
    AnalysisEnd analysis = 52;
    LoadBuildFileEnd load = 53;
    ExecutorStageEnd executor_stage = 54;
    TestDiscoveryEnd test_discovery = 55;
    TestRunEnd test_end = 56;
    SpanCancelled span_cancelled = 57;
    FileWatcherEnd file_watcher = 58;
    MaterializeRequestedArtifactEnd final_materialization = 59;
    AnalysisStageEnd analysis_stage = 60;
    MatchDepFilesEnd match_dep_files = 61;
    LoadPackageEnd load_package = 62;
    SharedTaskEnd shared_task = 63;
    CacheUploadEnd cache_upload = 64;
    CreateOutputSymlinksEnd create_output_symlinks = 65;
    CommandCriticalEnd command_critical = 66;
    InstallEventInfoEnd install_event_info = 67;
    DiceStateUpdateEnd dice_state_update = 68;
    MaterializationEnd materialization = 69;
    DiceCriticalSectionEnd dice_critical_section = 70;
    DiceBlockConcurrentCommandEnd dice_block_concurrent_command = 71;
    DiceSynchronizeSectionEnd dice_synchronize_section = 72;
    DiceCleanupEnd dice_cleanup = 73;
    ExclusiveCommandWaitEnd exclusive_command_wait = 74;
    DeferredPreparationStageEnd deferred_preparation_stage = 75;
    DeferredEvaluationEnd deferred_evaluation = 76;
    BxlExecutionEnd bxl_execution = 77;
    BxlDiceInvocationEnd bxl_dice_invocation = 78;
    ReUploadEnd re_upload = 79;
    ConnectToInstallerEnd connect_to_installer = 80;
    SetupLocalResourcesEnd local_resources = 81;
    ReleaseLocalResourcesEnd release_local_resources = 82;
    BxlEnsureArtifactsEnd bxl_ensure_artifacts = 83;
    CreateOutputHashesFileEnd create_output_hashes_file = 85;
    ActionErrorHandlerExecutionEnd action_error_handler_execution = 86;
    CqueryUniverseBuildEnd cquery_universe_build = 87;
    // Used in Buck unit tests.
    FakeEnd fake = 999;
  }
}

message SpanStats {
  uint64 max_poll_time_us = 1;
  uint64 total_poll_time_us = 2;
}

message UntrackedFile {
  string path = 1;
  string file_type = 2;
}

message StarlarkUserMetadataDictValue {
  map<string, StarlarkUserMetadataValue> value = 1;
}

message StarlarkUserMetadataListValue {
  repeated StarlarkUserMetadataValue value = 1;
}

message StarlarkUserMetadataValue {
  oneof value {
    string string_value = 1;
    int32 int_value = 2;
    bool bool_value = 3;
    StarlarkUserMetadataDictValue dict_value = 4;
    StarlarkUserMetadataListValue list_value = 5;
  }
}

message StarlarkUserEvent {
  string id = 1;
  map<string, StarlarkUserMetadataValue> metadata = 2;
}

message CommandOptions {
  uint64 concurrency = 1;
}

// An event that represents a single point in time.
message InstantEvent {
  reserved 2, 8, 9, 12, 13, 22, 24;

  oneof data {
    StructuredError structured_error = 1;
    ConsoleMessage console_message = 3;
    BuildGraphExecutionInfo build_graph_info = 4;
    RemoteExecutionSessionCreated re_session = 5;
    // Test discovery occurs as an instant event because we know when it starts,
    // but we do not know when it is complete.
    // Instead, we are informed of individual tests that are discovered.
    TestDiscovery test_discovery = 6;
    // Test result is an instant event for similar reasons as TestDiscovery.
    // It corresponds with the completion of an individual test.
    TestResult test_result = 7;
    Snapshot snapshot = 10;

    DiceStateSnapshot dice_state_snapshot = 11;

    // A tag to mark on the scuba tables
    TagEvent tag_event = 14;

    // Sent when the target pattern gets resolved to update the invocation info
    ParsedTargetPatterns target_patterns = 15;

    // Check DICE equality in critical section
    DiceEqualityCheck dice_equality_check = 16;

    // When we can execute DICE ops immediately since there was no active
    // state
    NoActiveDiceState no_active_dice_state = 17;

    // Info about materializer state
    MaterializerStateInfo materializer_state_info = 18;

    // Notify the client that the daemon is shutting down.
    DaemonShutdown daemon_shutdown = 19;

    // Information collected by buck2 rage command
    RageResult rage_result = 20;

    // Notify the client that the daemon would like to update the rendering.
    ConsolePreferences console_preferences = 21;

    IoProviderInfo io_provider_info = 23;

    // Stacktrace from the fail_no_stacktrace() call.
    StarlarkFailNoStacktrace starlark_fail_no_stacktrace = 25;

    // Snapshot of current debug adapter state. Only sent when a debugger is
    // attached.
    DebugAdapterSnapshot debug_adapter_snapshot = 27;

    // This is notionally reading from .buckconfig at startup, but since that's
    // done by the daemon, it needs to come through this way.
    RestartConfiguration restart_configuration = 28;

    // Unexpected file found in buck-out/<isolation_dir>/gen during a
    // clean --stale run, not found in materializer state
    UntrackedFile untracked_file = 29;

    // For user-defined instant events. Currently only used in BXL.
    StarlarkUserEvent starlark_user_event = 30;

    // Log options that are command-level and processed by the daemon.
    CommandOptions comand_options = 31;

    // Concurrent active commands.
    ConcurrentCommands concurrent_commands = 32;

    // Info coming from the `buck2 debug persist-event-log` subprocess
    PersistSubprocess persist_subprocess = 33;

    // An action error encountered during the build
    ActionError action_error = 34;

    ConsoleWarning console_warning = 35;
  }
}

message DebugAdapterStoppedEval {
  string description = 1;
  string stopped_at = 2;
}

message DebugAdapterCommandSnapshot {
  repeated DebugAdapterStoppedEval stopped_evals = 1;
}

// The DebugAdapterSnapshot is sent to all commands when a debugger is attached
// to buck, it contains imformation about the currently paused threads.
message DebugAdapterSnapshot {
  // The handle for the command receiving this snapshot, it can be used to
  // distinguish which of the per-handle snapshots is from this command and
  // which are from others.
  uint32 this_handle = 1;
  map<uint32, DebugAdapterCommandSnapshot> current_handles = 2;
}

message DiceStateSnapshot {
  map<string, DiceKeyState> key_states = 1;
}

message DiceKeyState {
  uint32 started = 1;
  uint32 finished = 2;
  uint32 check_deps_started = 3;
  uint32 check_deps_finished = 4;
}

message RemoteExecutionSessionCreated {
  string session_id = 1;
  string experiment_name = 2;
}

message Location {
  string file = 1;
  uint32 line = 2;
  uint32 column = 3;
}

// An error that needs to be reported. This may be a panic, or a soft error.
message StructuredError {
  // A resolved symbol, obtained through symbolicating the stack trace.
  message Symbol {
    // The name of the symbol (i.e. the function).
    string name = 1;
    // The address of the symbol.
    string address = 2;
    // The file containing the symbol.
    string file = 3;
    // The line where the symbol is defined.
    uint32 line = 4;
    // The column where the symbol is defined.
    uint32 column = 5;
  }

  // A stack frame, representing a single frame of execution in a backtrace.
  message StackFrame {
    // The instruction pointer at this frame. For terminal frames, this is the
    // faulting IP.
    string instruction_pointer = 1;
    // The address of the symbol associated with this stack frame.
    string symbol_address = 2;
    // The base address of the loaded module containing the given symbol
    // address, for use in symbolication.
    string module_base_address = 3;
    // The list of symbols known to resolve to the given symbol address, after
    // symbolication. A symbol address may resolve to multiple symbols if
    // inlining or COMDAT folding occurred. A symbol address may also resolve
    // to zero symbols if no symbols were found while symbolicating.
    repeated Symbol symbols = 4;
  }

  // The payload of the error (the argument to panic! if we are reporting a
  // panic).
  string payload = 1;
  // The code location this occurred at.
  Location location = 2;
  // Metadata associated with this daemon.
  map<string, string> metadata = 3;
  // A backtrace, we set this for panics.
  repeated StackFrame backtrace = 4;
  // StructuredError is used to propagate soft_errors, which can be hidden from
  // users. If true, it won't get logged to console
  bool quiet = 5;
  // If this was a soft error, its category.
  optional string soft_error_category = 6;
  // Whether a tracking task should be created for this error.
  optional bool task = 7;
  // Is this error indicative of needing to restart the daemon?
  bool daemon_in_memory_state_is_corrupted = 8;
  // Is this error indicative of needing to drop the materializer state?
  bool daemon_materializer_state_is_corrupted = 9;
  // Is this error indicative of the RE action cache returning corrupted
  // results?
  bool action_cache_is_corrupted = 10;
}

message CriticalPathEntry {
  // A pretty-printed action name.
  string action_name = 1;
  // The wall time taken by this action.
  google.protobuf.Duration duration = 2;
  // The action key (valid only locally within this build), useful for analysis
  // that wants to identify actions on the critical path.
  ActionKey action_key = 3;
  ActionName action_name_fields = 4;
}

message CriticalPathEntry2 {
  message Analysis {
    oneof target {
      ConfiguredTargetLabel standard_target = 1;
    }
  }

  message ActionExecution {
    ActionName name = 1;

    oneof owner {
      ConfiguredTargetLabel target_label = 2;
      BxlFunctionKey bxl_key = 3;
      AnonTarget anon_target = 4;
    }
  }

  message Materialization {
    string path = 1;

    oneof owner {
      ConfiguredTargetLabel target_label = 2;
      BxlFunctionKey bxl_key = 3;
      AnonTarget anon_target = 4;
    }
  }

  message ComputeCriticalPath {}

  message Load {
    string package = 1;
  }

  message Listing {
    string package = 1;
  }

  repeated uint64 span_ids = 1;

  // The duration we used to compute the critical path. This will be one of the
  // durations below, but to ensure not every callsite has to know which one we
  // chose, we expose it here.
  google.protobuf.Duration duration = 2;

  // The subset of the duration for this entry whose runtime is controlled by
  // the user.
  google.protobuf.Duration user_duration = 3;

  // The total duration for this entry, which might include runtime not
  // controlled by the user (e.g. Buck querying caches, etc.)
  google.protobuf.Duration total_duration = 4;

  // The maximum improvement possible for this node. This should be compared to
  // `duration` (since it can't exceed it).
  optional google.protobuf.Duration potential_improvement_duration = 5;

  oneof entry {
    Analysis analysis = 100;
    ActionExecution action_execution = 101;
    Materialization materialization = 102;
    ComputeCriticalPath compute_critical_path = 103;
    Load load = 104;
    Listing listing = 105;
  }
}

// Sent once per build.
message BuildGraphExecutionInfo {
  // The actions that made up the critical path, in chronological order.
  repeated CriticalPathEntry critical_path = 1;
  // Metadata associated with this build. Values in this map have no particular
  // semantics and are useful for logging and telemetry only.
  map<string, string> metadata = 2;
  // Number of nodes in the action graph.
  uint64 num_nodes = 3;
  // Number of directed edges in the action graph (directed acyclic graph).
  uint64 num_edges = 4;
  // The actions that made up the critical path, in chronological order, in a
  // new format. We will have either that, or critical_path;
  repeated CriticalPathEntry2 critical_path2 = 5;
  // Whether the aggregation is done using total duration or not.
  bool uses_total_duration = 6;
  // The backend that was use to produce the critical path.
  optional string backend_name = 7;
  // The command.
  optional string command_name = 8;
  // The isolation dir
  optional string isolation_dir = 9;
}

// An event capturing information from the test discovery phase.
// Test discovery includes sending a summary of the current testing session.
// For a given target, we also report when we discover its tests.
message TestDiscovery {
  oneof data {
    TestSessionInfo session = 1;
    TestSuite tests = 2;
  }
}

// Result of invoking buck2 rage
message RageResult {
  reserved 1 to 8;
  map<string, string> string_data = 9;
  map<string, uint64> int_data = 10;
  google.protobuf.Timestamp timestamp = 11;
  google.protobuf.Duration command_duration = 12;
}

// A snapshot of current system state, with useful info.
message Snapshot {
  // Resident set size in bytes of the buck2 daemon.
  // Does not include subprocesses (e.g. local actions).
  optional uint64 buck2_rss = 11;
  // Maximum resident set size in bytes of the buck2 daemon.
  // Does not include subprocesses (e.g. local actions).
  uint64 buck2_max_rss = 1;
  // User CPU time of buck2 daemon, not including subprocesses.
  uint64 buck2_user_cpu_us = 2;
  // System CPU time of buck2 daemon, not including subprocesses.
  uint64 buck2_system_cpu_us = 3;
  // Queue size of the blocking executor.
  uint64 blocking_executor_io_queue_size = 4;

  uint64 re_download_bytes = 5;
  uint64 re_upload_bytes = 6;
  uint32 re_uploads_started = 1011;
  uint32 re_uploads_finished_successfully = 1012;
  uint32 re_uploads_finished_with_error = 1013;
  uint32 re_downloads_started = 1021;
  uint32 re_downloads_finished_successfully = 1022;
  uint32 re_downloads_finished_with_error = 1023;
  uint32 re_action_cache_started = 1031;
  uint32 re_action_cache_finished_successfully = 1032;
  uint32 re_action_cache_finished_with_error = 1033;
  uint32 re_executes_started = 1041;
  uint32 re_executes_finished_successfully = 1042;
  uint32 re_executes_finished_with_error = 1043;
  uint32 re_materializes_started = 1051;
  uint32 re_materializes_finished_successfully = 1052;
  uint32 re_materializes_finished_with_error = 1053;
  uint32 re_write_action_results_started = 1061;
  uint32 re_write_action_results_finished_successfully = 1062;
  uint32 re_write_action_results_finished_with_error = 1063;
  uint32 re_get_digest_expirations_started = 1064;
  uint32 re_get_digest_expirations_finished_successfully = 1065;
  uint32 re_get_digest_expirations_finished_with_error = 1066;

  // I/O operations in progress.
  uint32 io_in_flight_copy = 1101;
  uint32 io_in_flight_symlink = 1102;
  uint32 io_in_flight_hardlink = 1103;
  uint32 io_in_flight_mk_dir = 1104;
  uint32 io_in_flight_read_dir = 1105;
  uint32 io_in_flight_read_dir_eden = 1106;
  uint32 io_in_flight_rm_dir = 1107;
  uint32 io_in_flight_rm_dir_all = 1108;
  uint32 io_in_flight_stat = 1109;
  uint32 io_in_flight_stat_eden = 1110;
  uint32 io_in_flight_chmod = 1111;
  uint32 io_in_flight_read_link = 1112;
  uint32 io_in_flight_remove = 1113;
  uint32 io_in_flight_rename = 1114;
  uint32 io_in_flight_read = 1115;
  uint32 io_in_flight_write = 1116;
  uint32 io_in_flight_canonicalize = 1117;
  uint32 io_in_flight_eden_settle = 1118;

  // Time passed since buck2 daemon was started
  uint64 daemon_uptime_s = 7;

  // https://jemalloc.net/jemalloc.3.html
  // (stats.active) Total number of bytes in active pages
  // allocated by the application, is greater or equal to stats.allocated.
  optional uint64 malloc_bytes_active = 8;
  // (stats.allocated) Total number of bytes allocated by the application
  optional uint64 malloc_bytes_allocated = 9;

  uint64 dice_key_count = 101;
  // the number of keys actively present in the per transaction cache
  uint64 dice_currently_active_key_count = 102;
  uint32 dice_active_transaction_count = 103;

  uint64 deferred_materializer_queue_size = 104;

  // Sink write statistics; counts of sink statistics taken at this snapshot.
  // Cumulative count of messages that were successfully emitted.
  optional uint64 sink_successes = 105;
  // Cumulative count of messages that failed to be emitted.
  optional uint64 sink_failures = 106;
  // Current number of messages queued up to be submitted.
  optional uint64 sink_buffer_depth = 107;
  // Cumulative count of messages that were dropped (i.e. not even processed).
  optional uint64 sink_dropped = 108;

  // Network statistics for "interesting" network interfaces.
  map<string, NetworkInterfaceStats> network_interface_stats = 109;

  uint64 http_download_bytes = 110;

  uint64 deferred_materializer_declares = 200;
  uint64 deferred_materializer_declares_reused = 201;

  optional UnixSystemStats unix_system_stats = 300;

  // Client side metrics.

  // Delay between time snapshot is created and time it is received
  // by the client.
  optional int64 this_event_client_delay_ms = 2001;
  // Client average user + system CPU time since last snapshot processed.
  optional uint32 client_cpu_percents = 2002;
}

message UnixSystemStats {
  double load1 = 1;
  double load5 = 2;
  double load15 = 3;
}

enum TestStatus {
  // sibling enum scoping in grpc requires file-wide unique name
  NOT_SET_TEST_STATUS = 0;
  PASS = 1;
  FAIL = 2;
  SKIP = 3;
  OMITTED = 4;
  FATAL = 5;
  TIMEOUT = 6;
  UNKNOWN = 7;
  RERUN = 8;
  LISTING_SUCCESS = 9;
  LISTING_FAILED = 10;
}

message TestResult {
  message OptionalMsg {
    string msg = 1; // Required
  }

  string name = 1; // Required
  TestStatus status = 2; // Required
  OptionalMsg msg = 5; // Optional
  google.protobuf.Duration duration = 7; // Optional
  string details = 8; // Required
  ConfiguredTargetLabel target_label = 9;
}

// At the beginning of discovery, the test orchestrator will advertise
// some information about the session
message TestSessionInfo {
  // Usually this contains a test link, like in Tpx
  string info = 2;
}

// We report all of the tests for a particular target simultaneously
message TestSuite {
  // When the tests for a target are discovered,
  // we are also given the suite name for the tests.
  string suite_name = 1;
  repeated string test_names = 2;
  ConfiguredTargetLabel target_label = 3;
}

// An event that marks the beginning of a command.
message CommandStart {
  // Metadata associated with this build. Values in this map have no particular
  // semantics and are useful for logging and telemetry only.
  //
  // The metadata cannot contain information from buckconfig or dice state
  map<string, string> metadata = 1;
  oneof data {
    BuildCommandStart build = 20;
    TargetsCommandStart targets = 21;
    QueryCommandStart query = 22;
    CQueryCommandStart cquery = 23;
    TestCommandStart test = 24;
    AuditCommandStart audit = 25;
    DocsCommandStart docs = 26;
    CleanCommandStart clean = 27;
    AqueryCommandStart aquery = 28;
    InstallCommandStart install = 29;
    MaterializeCommandStart materialize = 30;
    ProfileCommandStart profile = 31;
    BxlCommandStart bxl = 32;
    LspCommandStart lsp = 33;
    FileStatusCommandStart file_status = 34;
    StarlarkCommandStart starlark = 35;
    SubscriptionCommandStart subscribe = 36;
    TraceIoCommandStart trace = 37;
    ConfiguredTargetsCommandStart ctargets = 38;
    StarlarkDebugAttachCommandStart starlark_debug_attach = 39;
  }
}

// An event that marks that the command has start execution and synced it's
// state. The period of time between CommandStart and CommandCriticalStart is
// the time spent synchronizing changes and waiting for concurrent commands to
// finish.
message CommandCriticalStart {
  reserved 2;

  // Metadata associated with this build. Values in this map have no particular
  // semantics and are useful for logging and telemetry only.
  //
  // The metadata will contain information from buckconfigs
  map<string, string> metadata = 1;

  // DICE transaction version number.
  string dice_version = 3;
}

message AuditCommandStart {}

message StarlarkCommandStart {}

message BuildCommandStart {}

message BxlCommandStart {
  // The full bxl label that was run, excluding the arguments to the bxl
  string bxl_label = 1;
}

message LspCommandStart {}

message StarlarkDebugAttachCommandStart {}

message TargetsCommandStart {}

message ConfiguredTargetsCommandStart {}

message QueryCommandStart {}

message AqueryCommandStart {}

message CQueryCommandStart {
  string query = 1;
  string query_args = 2;
  string target_universe = 3;
}

message TestCommandStart {}

message DocsCommandStart {}

message CleanCommandStart {}

message InstallCommandStart {}

message MaterializeCommandStart {}

message FileStatusCommandStart {}

message ProfileCommandStart {}

message CommandEnd {
  reserved 3;
  oneof data {
    BuildCommandEnd build = 20;
    TargetsCommandEnd targets = 21;
    QueryCommandEnd query = 22;
    CQueryCommandEnd cquery = 23;
    TestCommandEnd test = 24;
    AuditCommandEnd audit = 25;
    DocsCommandEnd docs = 26;
    CleanCommandEnd clean = 27;
    AqueryCommandEnd aquery = 28;
    InstallCommandEnd install = 29;
    MaterializeCommandEnd materialize = 30;
    ProfileCommandEnd profile = 31;
    BxlCommandEnd bxl = 32;
    LspCommandEnd lsp = 33;
    FileStatusCommandEnd file_status = 34;
    StarlarkCommandEnd starlark = 35;
    SubscriptionCommandEnd subscribe = 36;
    TraceIoCommandEnd trace = 37;
    ConfiguredTargetsCommandEnd ctargets = 38;
    StarlarkDebugAttachCommandEnd starlark_debug_attach = 39;
  }

  bool is_success = 2;
  repeated ErrorReport errors = 4;
}

// Marks the exit of the `CommandCriticalStart` event, such that the command has
// left the critical section.
message CommandCriticalEnd {
  // Metadata associated with this command. Values in this map have no
  // particular semantics and are useful for logging and telemetry only.
  //
  // The metadata will contain information from buckconfigs
  map<string, string> metadata = 1;
}

message AuditCommandEnd {
  reserved 1, 2, 3;
}

message StarlarkCommandEnd {
  reserved 1, 2, 3;
}

message BuildCommandEnd {
  reserved 2;

  repeated TargetPattern unresolved_target_patterns = 1;
}

message BxlCommandEnd {
  // The full bxl label that was run, excluding the arguments to the bxl
  string bxl_label = 1;
}

message LspCommandEnd {}

message StarlarkDebugAttachCommandEnd {}

message TargetsCommandEnd {
  repeated TargetPattern unresolved_target_patterns = 1;
}

message ConfiguredTargetsCommandEnd {}

message QueryCommandEnd {}

message CQueryCommandEnd {}

message AqueryCommandEnd {}

message TestCommandEnd {
  repeated TargetPattern unresolved_target_patterns = 1;
}

message DocsCommandEnd {}

message CleanCommandEnd {
  optional CleanStaleStats clean_stale_stats = 1;
}

message CleanStaleStats {
  uint64 stale_artifact_count = 1;
  uint64 stale_bytes = 2;
  uint64 retained_artifact_count = 3;
  uint64 retained_bytes = 4;
  uint64 untracked_artifact_count = 5;
  uint64 untracked_bytes = 6;
  uint64 cleaned_path_count = 7;
  uint64 cleaned_artifact_count = 8;
  uint64 cleaned_bytes = 9;
}

message InstallCommandEnd {
  repeated TargetPattern unresolved_target_patterns = 1;
}

message MaterializeCommandEnd {}

message FileStatusCommandEnd {}

message ProfileCommandEnd {}

message LoadPackageStart {
  string path = 1;
}

message LoadPackageEnd {
  reserved 2, 3;
  string path = 1;
}

message LoadBuildFileStart {
  string module_id = 1;
  string cell = 2;
}

message LoadBuildFileEnd {
  string module_id = 1;
  string cell = 2;
  optional string error = 3;
  // Peak allocated memory in starlark mutable heap during evaluation of BUCK
  // file.
  uint64 starlark_peak_allocated_bytes = 4;
}

message SharedTaskStart {
  string owner_trace_id = 1;
}

message SharedTaskEnd {}

message FakeStart {
  string caramba = 1;
}

message FakeEnd {}

// A unique key identifying a particular action.
message ActionKey {
  // A deferred ID associated with this action. Opaque to consumers.
  bytes id = 1;

  // The configured target label that this action contributes to.
  oneof owner {
    ConfiguredTargetLabel target_label = 2;
    BxlFunctionKey bxl_key = 4;
    ConfiguredTargetLabel test_target_label = 5;
    AnonTarget anon_target = 6;
    ConfiguredTargetLabel local_resource_setup = 7;
  }

  // The full deferred key associated with this action. Opaque to consumers.
  string key = 3;
}

enum ActionKind {
  NOT_SET = 0;
  COPY = 1;
  DOWNLOAD_FILE = 2;
  RUN = 3;
  SYMLINKED_DIR = 4;
  WRITE = 5;
  WRITE_MACROS_TO_FILE = 6;
  CAS_ARTIFACT = 7;
}

// The kinds of ways an action can be executed by buck2.
enum ActionExecutionKind {
  ACTION_EXECUTION_KIND_NOT_SET = 0;
  // This action was executed locally.
  ACTION_EXECUTION_KIND_LOCAL = 1;
  // This action was executed via a remote execution service.
  ACTION_EXECUTION_KIND_REMOTE = 2;
  // This action was served via a remote execution service's action cache.
  ACTION_EXECUTION_KIND_ACTION_CACHE = 3;
  // This action was served inline within buck2 due to its simplicity (e.g.
  // write, symlink, etc.
  ACTION_EXECUTION_KIND_SIMPLE = 4;
  // reserving 5 for deprecated ACTION_EXECUTION_KIND_SKIPPED
  // This action was logically executed, but didn't perform all the work.
  ACTION_EXECUTION_KIND_DEFERRED = 6;
  // This action was served by the local dep file cache and not executed.
  ACTION_EXECUTION_KIND_LOCAL_DEP_FILE = 7;
  // This action was executed locally via a worker.
  ACTION_EXECUTION_KIND_LOCAL_WORKER = 8;
  // This action was served by a remote execution service's action cache based
  // on a dep file based key.
  ACTION_EXECUTION_KIND_REMOTE_DEP_FILE_CACHE = 9;
}

// A name for a particular action, suitable for offline analytics and user
// display. ActionNames are unique within the execution of a particular target.
message ActionName {
  // The category of this action. Categories are families of actions that are
  // similar but operate on different inputs, such as invocations of a C++
  // compiler (whose category would be `cxx_compile`).
  string category = 1;

  // The identifier of this action. Combined with the category, the identifier
  // describes the action umbiguously within the context of a single target.
  //
  // If only one action is expected in a single category, this field may be
  // empty.
  string identifier = 2;
}

// The beginning of execution for a particular action.
message ActionExecutionStart {
  reserved 2;

  // A unique key identifying this action within the build.
  ActionKey key = 1;
  // The kind of this action.
  ActionKind kind = 3;
  // A pair of category and identifier describing this action.
  ActionName name = 4;
}

message OmittedLocalCommand {
  string action_digest = 1;
}

message CommandExecutionDetails {
  reserved 6, 7, 8, 9, 10, 11, 12, 35;

  // Same as exit_code but allowing negative values
  optional sint32 signed_exit_code = 4;
  // The stdout of the command. This may be omitted for successful commands.
  string stdout = 2;
  // The stderr of the command.
  string stderr = 3;

  CommandExecutionKind command_kind = 5;
  CommandExecutionMetadata metadata = 13;
}

message CommandExecutionKind {
  oneof command {
    // The command, if it was local.
    LocalCommand local_command = 1;
    // The command, if it was remote.
    RemoteCommand remote_command = 2;
    // The command, if it was local and omitted from this log record for
    // brevity.
    OmittedLocalCommand omitted_local_command = 3;
    // The command used to initialize the worker, if the action failed at this
    // step.
    WorkerInitCommand worker_init_command = 4;
    // The command, if executed by a local worker.
    WorkerCommand worker_command = 5;
  }
}

// Serialization of CommandExecutionMetadata
message CommandExecutionMetadata {
  /// How long this command actually waited for this action to complete
  google.protobuf.Duration wall_time = 1;

  /// How long this command actually took to execute
  google.protobuf.Duration execution_time = 2;

  /// When execution started.
  google.protobuf.Timestamp start_time = 3;

  /// How long it took to materialize the action's inputs.
  google.protobuf.Duration input_materialization_duration = 4;

  CommandExecutionStats execution_stats = 5;

  /// How long it took to hash the action's artifacts
  google.protobuf.Duration hashing_duration = 6;

  uint64 hashed_artifacts_count = 7;
}

message CommandOutputsMissing {
  // A description of what outputs are missing.
  string message = 2;
}

message CommandTimedOut {
  string message = 2;
}

// Serialization of CommandExecutionReport
message CommandExecution {
  CommandExecutionDetails details = 1;

  message Success {}

  message Failure {}

  message Timeout {
    google.protobuf.Duration duration = 1;
  }

  message Error {
    string stage = 1;
    string error = 2;
  }

  // (Hybrid execution only) This executor released its claim in order to allow
  // another executor to proceed. We use this to cancel local tasks when racing
  // local & RE.
  message Cancelled {}

  reserved 6;

  // Serialization of CommandExecutionStatus.
  oneof status {
    Success success = 2;
    Failure failure = 3;
    Timeout timeout = 4;
    Error error = 5;
    Cancelled cancelled = 7;
  }
}

// NOTE: This is an empty message. When this is returned as an error, the
// relevant execution details are in the reports field.
message CommandExecutionError {}

message ActionOutput {
  string tiny_digest = 1;
}

message ActionExecutionEnd {
  reserved 2, 20;

  // A unique key identifying this action within the build.
  ActionKey key = 1;
  // The kind of this action.
  ActionKind kind = 4;
  // A pair of category and identifier describing this action.
  ActionName name = 5;
  // Whether or not this action failed. The default value of this field is
  // "false", indicating that an action was successful. This polarity was chosen
  // deliberately; our hypothesis is that a large majority of actions are
  // successful and, when a boolean is sent over the wire as its default value
  // (false), it is not serialized at all.
  bool failed = 6;
  // If this action failed, contains an object that represents the nature of the
  // error. Can be just a string, in which case it is `unknown`, or may be a
  // richer object depending on the error.
  // TODO(JakobDegen): Consider reusing the `ActionError` type below
  oneof error {
    // An error message whose nature is unknown. This often comes from cases
    // where action execution fails for reasons other than the command failing.
    // This should not be preferred, and should be an error type of last resort.
    // TODO (torozco): Remove
    string unknown = 7;

    // Command executed successfully but did not produce the desired outputs.
    CommandOutputsMissing missing_outputs = 9;

    // TODO (torozco): Rename to command_failed.
    CommandExecutionError command_execution_error = 11;
  };
  // If not-empty, the stderr for the process. This may contain ANSI control
  // characters, so consumers should sanitize it before displaying it to users.
  // If it is empty, the stderr contents are available elsewhere, e.g. in an
  // error message for failed actions.
  // Whether, in the normal case, stderr should be printed for successful
  // actions. It *may* still be presented to users if they request it
  // specifically.
  bool always_print_stderr = 21;
  // The kind of execution used to service this action.
  // TODO (torozco): Remove the command variants? This should probably just be
  // "Command" if there was a command and then we should look at the command
  // reports to tell if it was RE or Local.
  ActionExecutionKind execution_kind = 22;
  /// How long this build waited for this action to complete. Omits queue time.
  google.protobuf.Duration wall_time = 23;
  // the total size of the outputs of this action.
  uint64 output_size = 24;
  // The commands executed by this action. These are in the order they were
  // attempted. If a command was executed, the one that should be shown to the
  // user will always be last.
  repeated CommandExecution commands = 25;
  // The outputs produced by this action
  repeated ActionOutput outputs = 26;

  // For commands, their local preference.
  bool prefers_local = 27;
  bool requires_local = 28;
  bool allows_cache_upload = 29;
  bool did_cache_upload = 30;

  // Revision hash (version) for this action. This is set only when the action
  // fails.
  optional string buck2_revision = 31;
  // Time when the buck2 binary servicing this action was built. This is set
  // only when the action fails.
  optional string buck2_build_time = 32;

  // Was this command eligible for full hybrid execution (i.e. no exclusions
  // from the command, hybrid is turned on).
  optional bool eligible_for_full_hybrid = 33;

  // Hostname of this action ran on. This is set only when the action fails.
  optional string hostname = 34;

  // Fields related to the remote dep file cache
  bool allows_dep_file_cache_upload = 35;
  bool did_dep_file_cache_upload = 36;
  // Remote dep file key (the digest we use to populate the action cache).
  // This is set if the action contains a dep file
  optional string dep_file_key = 37;

  // Additional diagnostics, if an action error handler was provided
  optional ActionErrorDiagnostics error_diagnostics = 38;
}

message ActionError {
  ActionKey key = 1;
  ActionName name = 2;

  // Matches the definition in `ActionExecutionEnd`
  // FIXME(JakobDegen): Extract and deduplicate
  oneof error {
    string unknown = 3;
    CommandOutputsMissing missing_outputs = 4;
    CommandExecutionError command_execution_error = 5;
  };

  // The last command executed as a part of the action, if any
  optional CommandExecution last_command = 6;

  // Additional diagnostics, if an action error handler was provided
  optional ActionErrorDiagnostics error_diagnostics = 7;
}

// Either the produced `ActionSubError`s, or the error that occured when
// invoking the error handler
message ActionErrorDiagnostics {
  oneof data {
    // list of action error subcategories and their metadata
    ActionSubErrors sub_errors = 1;
    // error that may have occured when invoking the handler
    string handler_invocation_error = 2;
  }
}

// Wrapper around `ActionSubError` so we can use `oneof` in
// `ActionErrorDiagnostics`
message ActionSubErrors {
  repeated ActionSubError sub_errors = 1;
}

message ActionSubError {
  // Error category produced by the error handler function provided by the rule
  // author.
  //
  // These should be finer grain error categorizations provided by the rule
  // authors, and tend to be language specific. These should not be any kind of
  // shared concepts among all errors for all languages/rules. For example,
  // timeouts and infra errors should not go here - buck2 tries to categorize
  // these types of errors automatically. An example of a finer grain error
  // category may be the error code for rustc outputs.

  string category = 1;

  // Optional freeform string for rule author to populate. The message will be
  // emitted to the build report, and to the stderr in the error diagnostics
  // section.

  optional string message = 2;

  // Optional list of file locations/lines for rule author to populate.
  optional ActionErrorLocations locations = 3;
}

// Wrapper around `ActionErrorLocation` so we can differentiate between null and
// empty locations
message ActionErrorLocations {
  repeated ActionErrorLocation locations = 1;
}

message ActionErrorLocation {
  // The file path of the error location. Should be project relative or absolute
  string file = 1;
  optional uint64 line = 2;
}

message ActionErrorHandlerExecutionStart {}

message ActionErrorHandlerExecutionEnd {}

message CqueryUniverseBuildStart {}

message CqueryUniverseBuildEnd {}

// The beginning of materialization for the output of a target requested,
// inclusive of all dependent artifacts it might recursively request to
// materialize.
message MaterializeRequestedArtifactStart {
  BuildArtifact artifact = 1;
}

message MaterializeRequestedArtifactEnd {
  BuildArtifact artifact = 1;
}

message AnalysisProfile {
  uint64 starlark_allocated_bytes = 1;
  uint64 starlark_available_bytes = 2;
}

message AnalysisStart {
  oneof target {
    ConfiguredTargetLabel standard_target = 1;
    AnonTarget anon_target = 3;
  }
  string rule = 2;
}

message AnalysisEnd {
  oneof target {
    ConfiguredTargetLabel standard_target = 1;
    AnonTarget anon_target = 4;
  }
  string rule = 3;
  AnalysisProfile profile = 2;
}

message AnalysisStageStart {
  oneof stage {
    google.protobuf.Empty resolve_queries = 1;
    google.protobuf.Empty evaluate_rule = 2;
  }
}

message AnalysisStageEnd {}

message ExecutorStageStart {
  oneof stage {
    ReStage re = 20;
    LocalStage local = 21;
    CacheQuery cache_query = 22;
    CacheHit cache_hit = 23;
    PrepareAction prepare = 24;
  }
}

message PrepareAction {}

enum CacheType {
  CACHE_TYPE_ACTION_CACHE = 0;
  CACHE_TYPE_REMOTE_DEP_FILE_CACHE = 1;
}

message CacheQuery {
  string action_digest = 1;
  CacheType cache_type = 2;
}

message CacheHit {
  string action_digest = 1;
  optional string action_key = 3;
}

message ReStage {
  reserved 1, 2, 3, 4;

  oneof stage {
    ReExecute execute = 5;
    ReDownload download = 6;
    ReQueue queue = 7;
    ReWorkerDownload worker_download = 8;
    ReWorkerUpload worker_upload = 9;
    ReUnknown unknown = 10;
    MaterializeFailedInputs materialize_failed_inputs = 11;
  }
}

message MaterializeFailedInputs {}

message ReExecute {
  string action_digest = 1;
  RePlatform platform = 2;
  optional string action_key = 3;
}

message RePlatform {
  message Property {
    string name = 1;
    string value = 2;
  }
  repeated Property properties = 1;
}

message ReDownload {}

message ReQueue {
  string action_digest = 1;
}

message ReWorkerDownload {
  string action_digest = 1;
}

message ReWorkerUpload {
  string action_digest = 1;
}

message ReUnknown {
  string action_digest = 1;
}

message LocalStage {
  oneof stage {
    LocalQueued queued = 1;
    LocalExecute execute = 2;
    LocalMaterializeInputs materialize_inputs = 3;
    LocalPrepareOutputDirs prepare_outputs = 4;
    AcquireLocalResource acquire_local_resource = 5;
    WorkerInit worker_init = 6;
    WorkerExecute worker_execute = 7;
    WorkerQueued worker_queued = 8;
    WorkerWait worker_wait = 9;
  }
}

message LocalQueued {}

message WorkerQueued {}

message LocalExecute {
  LocalCommand command = 1;
}

message WorkerExecute {
  WorkerCommand command = 1;
}

message LocalMaterializeInputs {}

message LocalPrepareOutputDirs {}

message AcquireLocalResource {}

message WorkerWait {}

message WorkerInit {
  WorkerInitCommand command = 1;
}

message ExecutorStageEnd {}

// For most tests, tpx calls the test orchestrator's `execute` method.
// The `execute` method calls a test binary.
// We instrument the span associated specifically with the execution of this
// binary, ignoring time spent resolving deps, etc.
//
// `Execute` is called in two different ways:
// - Discovery: `tpx` is trying to figure out what tests to run for a suite.
// - SuiteRun: `tpx` wants to run one or more tests for a suite.
// These different ways are tracked using the span events below.

message TestDiscoveryStart {
  // Trying to find the test suite(s) associated with this binary.
  string suite_name = 1;
}

message TestDiscoveryEnd {
  string suite_name = 1;
  CommandExecution command_report = 2;
}

message TestRunStart {
  TestSuite suite = 1;
}

message TestRunEnd {
  TestSuite suite = 1;
  CommandExecution command_report = 2;
}

message FileWatcherStart {
  FileWatcherProvider provider = 1;
}

enum FileWatcherProvider {
  WATCHMAN = 0;
  // The Rust `notify` crate
  RUST_NOTIFY = 1;

  FS_HASH_CRAWLER = 2;
}

enum FileWatcherEventType {
  CREATE = 0;
  MODIFY = 1;
  DELETE = 2;
}

enum FileWatcherKind {
  FILE = 0;
  DIRECTORY = 1;
  SYMLINK = 2;
}

message FileWatcherEvent {
  FileWatcherEventType event = 1;
  FileWatcherKind kind = 2;
  string path = 3;
}

// Stats for a file watching (e.g. Watchman) update. We ignore events that are
// outside of the cells we care about, which is why events_total and
// events_processed might differ.
message FileWatcherStats {
  reserved 5;

  bool fresh_instance = 1;
  uint64 events_total = 2;
  uint64 events_processed = 3;
  optional string branched_from_revision = 4;
  optional uint64 branched_from_global_rev = 10;
  repeated FileWatcherEvent events = 6;
  // Present if the results are incomplete
  optional string incomplete_events_reason = 7;
  // Present if it is using Watchman
  optional string watchman_version = 8;
  // Present on a fresh instance. This is a bit duplicative of field 1
  // (`fresh_instance`), but we keep that for backwards compatibility.
  optional FreshInstance fresh_instance_data = 9;
}

message FreshInstance {
  bool new_mergebase = 1;
  bool cleared_dice = 2;
  bool cleared_dep_files = 3;
}

message FileWatcherEnd {
  FileWatcherStats stats = 1;
}

message MatchDepFilesStart {
  bool checking_filtered_inputs = 1;
  // True if the dep file entry was retrieved from the remote dep file cache
  bool remote_cache = 2;
}

message MatchDepFilesEnd {}

// Returned when a Span is dropped before terminating.
message SpanCancelled {}

// A configured target label, which is a target label plus a configuration.
message ConfiguredTargetLabel {
  TargetLabel label = 1;
  Configuration configuration = 2;
  // Only present on toolchain_deps
  optional Configuration execution_configuration = 3;
}

message AnonTarget {
  TargetLabel name = 1;
  Configuration execution_configuration = 2;
  string hash = 3;
}

// A bxl function key, which is a bxl function and its args
message BxlFunctionKey {
  reserved 2;
  BxlFunctionLabel label = 1;
}

// A bxl function label, which is its defining file and the function name
message BxlFunctionLabel {
  string bxl_path = 1;
  string name = 2;
}

// A configuration, identified by its full name.
message Configuration {
  string full_name = 2;
}

// A target label, consisting of a package and a name.
message TargetLabel {
  string package = 1;
  string name = 2;
}

message BuildArtifact {
  ActionKey key = 1;
  string path = 2;
}

// A target pattern, representing a set of targets. See
// `<https://buck.build/concept/build_target_pattern.html#content>` for Buck's
// documentation on target patterns.
message TargetPattern {
  string value = 1;
}

/// A message that should be printed to the user, generally via stderr
///
/// The formatting used is up to the user, and may have things like ANSI
/// control characters removed.
///
/// Generally, one should rely on properly typed events, rather than raw
/// console events if additional formatting is required.
message ConsoleMessage {
  string message = 1;
}

/// A message that should be printed to the user as a warning in yellow color,
/// generally via stderr
message ConsoleWarning {
  string message = 1;
}

message EnvironmentEntry {
  // The environment key.
  string key = 1;
  // The environment value.
  string value = 2;
}

/// A representation of a command that we executed locally.
message LocalCommand {
  repeated string argv = 1;
  repeated EnvironmentEntry env = 2;
  string action_digest = 3;
}

message WorkerInitCommand {
  repeated string argv = 1;
  repeated EnvironmentEntry env = 2;
}

/// A representation of a command executed by a local worker.
message WorkerCommand {
  repeated string argv = 1;
  repeated EnvironmentEntry env = 2;
  string action_digest = 3;
  /// The exe args to run this command as a separate process,
  /// if needed to reproduce a failed command.
  repeated string fallback_exe = 4;
}

enum CacheHitType {
  ACTION_CACHE = 0;
  REMOTE_DEP_FILE_CACHE = 1;
  EXECUTED = 2; // not a cache hit
}

// A representation of a command we executed remotely.
message RemoteCommand {
  string action_digest = 1;
  bool cache_hit = 2;

  /// How long this build waited in queue.
  google.protobuf.Duration queue_time = 3;

  // Potentially more details about this command.
  optional RemoteCommandDetails details = 4;

  CacheHitType cache_hit_type = 5;
  optional string remote_dep_file_key = 6;

  // Project relative paths to the materialized inputs for failed

  // actions, if `--materialize-failed-inputs` was passed to build options
  repeated string materialized_inputs_for_failed = 7;
}

message RemoteCommandDetails {
  optional string session_id = 1;
  string use_case = 2;
  RePlatform platform = 3;
}

// Header in binary event log.
message Invocation {
  repeated string command_line_args = 1;
  repeated string expanded_command_line_args = 11;
  string working_dir = 2;
  optional string trace_id = 3;
}

message RecordEvent {
  oneof data {
    InvocationRecord invocation_record = 1;
    BuildGraphStats build_graph_stats = 2;
  }
}

// An arbitrary tag on the command. Usually used to mark A/B experiments
message TagEvent {
  repeated string tags = 1;
}

// Unambiguous provider patterns that this command is requesting be brought
// up-to-date. These patterns are not exactly the same as the patterns
// directly provided to the buck2 command-line; rather, these patterns have
// been disambiguated using the client's working directory and cell
// configuration.
message ParsedTargetPatterns {
  repeated TargetPattern target_patterns = 1;
}

message TypedMetadata {
  map<string, int64> ints = 1;
  map<string, string> strings = 2;
}

// This is the origin for every sample in buck2_builds scuba table
// It's sent from the client to Scribe at the end of each invocation
message InvocationRecord {
  reserved 1, 22, 27, 28, 36, 61, 62, 66, 77;

  // Optional - present if ever sent to client.
  // Will be missing on a cancelled build.
  CommandEnd command_end = 2;
  // Optional - present if event-log had RemoteExecutionSessionCreated.
  string re_session_id = 3;
  repeated string cli_args = 4;
  // Optional - present if CommandEnd sent to client.
  google.protobuf.Duration command_duration = 5;
  // Required. The walltime as measured by the client.
  google.protobuf.Duration client_walltime = 6;
  // Optional - present if BuildGraphExecutionInfo sent to client.
  google.protobuf.Duration critical_path_duration = 7;
  // Optional - any contents are copied directly to scuba buck2_builds.
  TypedMetadata metadata = 8;
  // Tags for this command
  repeated string tags = 9;
  // Count of actions that were executed locally
  uint64 run_local_count = 10;
  // Count of actions that were executed remotely
  uint64 run_remote_count = 11;
  // Count of actions that downloaded action cache
  uint64 run_action_cache_count = 12;
  // Count of actions that were skipped. Actions are usually skipped due to a
  // dep-files hit.
  uint64 run_skipped_count = 13;
  // Optional - Count of actions that used fallback if fallback was used
  optional uint64 run_fallback_count = 14;
  // Optional - Count of actions executed locally by a persistent worker,
  // actions included in this count are also included in run_local_count.
  optional uint64 local_actions_executed_via_worker = 15;
  // Optional - the first snapshot sent.
  Snapshot first_snapshot = 20;
  // Optional - the last snapshot sent.
  Snapshot last_snapshot = 21;
  // If any, the name of the RE experiment config that was used by the RE
  // client in this build.
  string re_experiment_name = 23;
  // Minimum build count among the targets that were involved in the command
  uint64 min_build_count_since_rebase = 24;
  // The number of cache uploads done by this build.
  uint64 cache_upload_count = 25;
  // The number of cache uploads attempted by this build.
  uint64 cache_upload_attempt_count = 26;
  // Resolved target pattern for the command. Codebase considers these "parsed."
  ParsedTargetPatterns parsed_target_patterns = 29;
  // Whether repository is Eden filesystem / mount (EdenFS)
  string filesystem = 30;
  // Test session
  optional string test_info = 31;
  // Whether there were any full-hybrid-eligible actions.
  optional bool eligible_for_full_hybrid = 32;
  // Max delay between time a server generates an event and time the client
  // observes it.
  optional uint64 max_event_client_delay_ms = 33;
  // Stateful max for malloc_bytes_active over the lifetime of invocation.
  optional uint64 max_malloc_bytes_active = 34;
  // Stateful max for malloc_bytes_allocated over the lifetime of invocation.
  optional uint64 max_malloc_bytes_allocated = 35;
  optional uint64 run_command_failure_count = 37;
  optional uint64 event_count = 38;
  // Time elapsed from a build's start until the first action begins execution.
  optional uint64 time_to_first_action_execution_ms = 39;
  // Total size, in bytes, of all materialized outputs.
  optional uint64 materialization_output_size = 40;
  // Time elapsed from a build's start until the command starts.
  optional uint64 time_to_command_start_ms = 41;
  // Time elapsed from a build's start until command enters critical section.
  optional uint64 time_to_command_critical_section_ms = 42;
  // Time elapsed from build start until analysis of first action.
  optional uint64 time_to_first_analysis_ms = 43;
  // Time elapsed from build start until first build file is loaded.
  optional uint64 time_to_load_first_build_file_ms = 44;
  // Time elapsed from a build's start until first command begins execution.
  optional uint64 time_to_first_command_execution_start_ms = 45;
  // Total system memory in bytes
  optional uint64 system_total_memory_bytes = 46;
  // Information of file changes provided by file watcher
  FileWatcherStats file_watcher_stats = 47;
  // Time elapsed from a build's start until the last action ends execution.
  optional uint64 time_to_last_action_execution_end_ms = 48;
  // Isolation directory.
  optional string isolation_dir = 49;
  // Number of materializer entries loaded from db on daemon start.
  optional uint64 initial_materializer_entries_from_sqlite = 50;
  // Sink write statistics for the command
  optional uint64 sink_success_count = 51;
  optional uint64 sink_failure_count = 52;
  optional uint64 sink_dropped_count = 53;
  optional uint64 sink_max_buffer_depth = 54;
  // Version number of watchman
  optional string watchman_version = 55;
  optional string command_name = 56;
  // Any soft errors we hit during this invocation.
  repeated string soft_error_categories = 57;
  // Version number of EdenFS if mount is EdenFS
  optional string eden_version = 58;
  // Duration of when the concurrent command is blocking
  google.protobuf.Duration concurrent_command_blocking_duration = 59;
  // How many analyses were executed
  optional uint64 analysis_count = 60;
  optional string restarted_trace_id = 63;
  optional bool has_command_result = 64;
  optional uint64 compressed_event_log_size_bytes = 65;
  optional bool has_end_of_stream = 67;
  optional string critical_path_backend = 68;
  optional bool instant_command_is_success = 69;
  // Optional - total time for final artifact materializations.
  google.protobuf.Duration bxl_ensure_artifacts_duration = 70;
  optional uint64 re_upload_bytes = 71;
  optional uint64 re_download_bytes = 72;
  // Count of actions that downloaded the remote depfile cache
  uint64 run_remote_dep_file_cache_count = 73;
  // List of concurrent command trace IDs
  repeated string concurrent_command_ids = 74;
  // The client has failed to connect to the daemon.
  optional bool daemon_connection_failure = 75;
  // Metadata provided by the client. Unlike TypedMetadata, this won't become
  // its own column in Scuba, all those entries will land in a NormVector.
  repeated ClientMetadata client_metadata = 76;
  // The errors that occured during the command.
  repeated ProcessedErrorReport errors = 79;
  // Cache hit rate as it appears in the console
  float cache_hit_rate = 78;
  repeated string target_rule_type_names = 80;
  // Time elapsed from a build's start until first test discovery begins.
  optional uint64 time_to_first_test_discovery_ms = 81;
}

// Record event sent directly to scribe.
message BuildGraphStats {
  repeated BuildTarget build_targets = 1;
}

message BuildTarget {
  string target = 1;
  string configuration = 2;
  // The dependency graph size for this target, if enabled and the target was
  // not skipped.
  optional uint64 configured_graph_size = 3;
}

message ClientMetadata {
  string key = 1;
  string value = 2;
}

enum CacheUploadReason {
  // The action was executed locally
  LOCAL_EXECUTION = 0;
  // The action has dep files that can be cached
  DEP_FILE = 1;
}

message CacheUploadStart {
  // A unique key identifying this action within the build.
  ActionKey key = 1;
  // A pair of category and identifier describing this action.
  ActionName name = 2;
  // The digest of the action being uploaded.
  string action_digest = 3;
  // Reason for why this upload took place
  CacheUploadReason reason = 4;
}

message CacheUploadEnd {
  // A unique key identifying this action within the build.
  ActionKey key = 1;
  // A pair of category and identifier describing this action.
  ActionName name = 2;
  // The digest of the action being uploaded.
  string action_digest = 3;
  // Whether the upload was actually completed. This may be false if it wasn't
  // representable in RE, or if an error occurred.
  bool success = 4;
  // An error, if any occurred.
  string error = 5;
  // The files we uploaded.
  repeated string file_digests = 6;
  // The directories we uploaded.
  repeated string tree_digests = 7;
  optional uint64 output_bytes = 8;
  // If a RE error occurred, the error code.
  optional string re_error_code = 9;
  // Reason for why this upload took place
  CacheUploadReason reason = 10;
}

message CreateOutputSymlinksStart {};

message CreateOutputSymlinksEnd {
  uint64 created = 1;
};

message CreateOutputHashesFileStart {};

message CreateOutputHashesFileEnd {};

message InstallEventInfoStart {
  string artifact_name = 1;
  string file_path = 2;
};

message InstallEventInfoEnd {};

message DiceStateUpdateStart {}

message DiceStateUpdateEnd {}

message MaterializationStart {
  // The digest of the action being materialized.
  optional string action_digest = 1;
};

enum MaterializationMethod {
  MATERIALIZATION_METHOD_CAS_DOWNLOAD = 0;
  MATERIALIZATION_METHOD_LOCAL_COPY = 1;
  MATERIALIZATION_METHOD_HTTP_DOWNLOAD = 2;
  MATERIALIZATION_METHOD_WRITE = 3;
}

message MaterializationEnd {
  uint64 file_count = 1;
  uint64 total_bytes = 2;
  string path = 3;

  // The digest of the action being materialized.
  optional string action_digest = 4;

  // Whether the materialization was actually completed. This may be false if it
  // wasn't in RE, or if an error occurred.
  bool success = 5;
  // An error, if any occurred.
  optional string error = 6;

  // The type of entry that was materialized
  optional MaterializationMethod method = 7;
};

message ExclusiveCommandWaitStart {
  optional string command_name = 1;
}

message ExclusiveCommandWaitEnd {}

message DiceCriticalSectionStart {}

message DiceCriticalSectionEnd {}

message DiceSynchronizeSectionStart {}

message DiceSynchronizeSectionEnd {}

message BxlExecutionStart {
  string name = 1;
}

message BxlExecutionEnd {}

message BxlDiceInvocationStart {}

message BxlDiceInvocationEnd {}

message BxlEnsureArtifactsStart {}

message BxlEnsureArtifactsEnd {}

message DiceBlockConcurrentCommandStart {
  string current_active_trace_id = 1;
  string cmd_args = 2;
}

message DiceBlockConcurrentCommandEnd {
  string ending_active_trace_id = 1;
}

message DiceCleanupStart {
  uint64 epoch = 1;
}

message DiceCleanupEnd {}

message DiceEqualityCheck {
  bool is_equal = 1;
}

message NoActiveDiceState {}

message ErrorReport {
  optional buck.data.error.ErrorCategory category = 1;
  optional buck.data.error.ErrorType typ = 2;
  // The error message that is shown to users on the CLI
  string message = 3;
  // If different from `message`, the error messsage that is shown to the
  // build report or logged in scuba. Currently, this distinction only exists
  // for action errors - they show the full stderr in telemetry and in a
  // separate event, but the error message only contains `failed to build target
  // foo`
  optional string telemetry_message = 4;
  // The location in source code where this error was created. Typically a Rust
  // source file, but the exact format is not guaranteed.
  optional string source_location = 5;
  repeated buck.data.error.ErrorTag tags = 6;
}

// Identical to `ErrorReport`, but with the typ and tags converted to strings.
// This makes it easy to change those enums without having to worry about uses
// of this protobuf definition outside of buck2. Currently used in the
// invocation record and nowhere else.
message ProcessedErrorReport {
  optional buck.data.error.ErrorCategory category = 1;
  optional string typ = 2;
  string message = 3;
  optional string telemetry_message = 4;
  optional string source_location = 5;
  repeated string tags = 6;
}

message MaterializerStateInfo {
  // Number of entries loaded from sqlite
  uint64 num_entries_from_sqlite = 1;
}

message IoProviderInfo {
  optional string eden_version = 1;
}

message ConcurrentCommands {
  repeated string trace_ids = 1;
}

message PersistSubprocess {
  repeated string errors = 1;
}

message StarlarkFailNoStacktrace {
  string trace = 1;
}

message NoopEvent {}

message DaemonShutdown {
  reserved 3;
  string reason = 1;
  repeated string callers = 4;
}

message ConsolePreferences {
  uint64 max_lines = 1;
}

message SubscriptionCommandStart {}

message SubscriptionCommandEnd {}

message DeferredPreparationStageStart {
  oneof stage {
    MaterializedArtifacts materialized_artifacts = 1;
  }
}

message MaterializedArtifacts {}

message DeferredPreparationStageEnd {}

message DynamicLambdaStart {
  // The configured target label that this action contributes to.
  oneof owner {
    ConfiguredTargetLabel target_label = 1;
    BxlFunctionKey bxl_key = 2;
    AnonTarget anon_target = 3;
  }
}

message DeferredEvaluationEnd {}

// Wraps the RE upload stage of execution to report useful data on network
// traffic.
// Eventually all the executor stage span definitions should be moved to
// dedicated spans.
message ReUploadStart {}

message ReUploadEnd {
  optional uint64 digests_uploaded = 1;
  optional uint64 bytes_uploaded = 2;
}

message ConnectToInstallerStart {
  uint32 tcp_port = 1;
}

message ConnectToInstallerEnd {}

message CpuCounter {
  uint64 count = 1;
  uint64 time_enabled = 2;
  uint64 time_running = 3;
}

message CommandExecutionStats {
  optional uint64 cpu_instructions_user = 1;
  optional uint64 cpu_instructions_kernel = 2;
  optional CpuCounter userspace_events = 3;
  optional CpuCounter kernel_events = 4;
}

message NetworkInterfaceStats {
  uint64 tx_bytes = 1;
  uint64 rx_bytes = 2;
}

message TraceIoCommandStart {}

message TraceIoCommandEnd {}

message SetupLocalResourcesStart {
  ConfiguredTargetLabel target_label = 1;
}

message SetupLocalResourcesEnd {}

message ReleaseLocalResourcesStart {}

message ReleaseLocalResourcesEnd {}

message RestartConfiguration {
  bool enable_restarter = 1;
}
