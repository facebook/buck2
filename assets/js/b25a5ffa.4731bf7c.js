"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[45271],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var a=n(96540);const i={},o=a.createContext(i);function s(e){const t=a.useContext(o);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(o.Provider,{value:t},e.children)}},88596:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"rfcs/implemented/bxl-actions","title":"Bxl Actions and Build API","description":"Bxl allows integrators to write Starlark snippets that introspect the buck2","source":"@site/../docs/rfcs/implemented/bxl-actions.md","sourceDirName":"rfcs/implemented","slug":"/rfcs/implemented/bxl-actions","permalink":"/docs/rfcs/implemented/bxl-actions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{}}');var i=n(74848),o=n(28453);const s={},r="Bxl Actions and Build API",c={},l=[{value:"Actions API",id:"actions-api",level:2},{value:"Creating and Building the Actions",id:"creating-and-building-the-actions",level:2},{value:"Internal Representation (Deferred Framework)",id:"internal-representation-deferred-framework",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"bxl-actions-and-build-api",children:"Bxl Actions and Build API"})}),"\n",(0,i.jsxs)(t.p,{children:["Bxl allows integrators to write Starlark snippets that introspect the buck2\ngraph, and perform various operations on them within Starlark to accomplish\ncomplex operations, as previously proposed in ",(0,i.jsx)(t.a,{href:"../bxl",children:"bxl RFC"}),")"]}),"\n",(0,i.jsx)(t.p,{children:"This document is intended at discussing the aspects of build and actions\ndeclaration of a bxl function in more details, and proposed changes to deferred\nframework to support bxl actions."}),"\n",(0,i.jsx)(t.h2,{id:"actions-api",children:"Actions API"}),"\n",(0,i.jsxs)(t.p,{children:["The actions API should be the same as rules' actions API. That is, it has the\nsame ",(0,i.jsx)(t.code,{children:"ctx.actions"})," that allows registering of artifacts, creating actions,\ndynamic actions via the same api."]}),"\n",(0,i.jsx)(t.h2,{id:"creating-and-building-the-actions",children:"Creating and Building the Actions"}),"\n",(0,i.jsx)(t.p,{children:"Bxl allows users to build targets and actions. However, when creating actions,\nthey are not bound/buildable until the artifact/action factories are finalized.\nAs such, we will introduce the limitation that bxl cannot build artifacts that\nthey themselves declared within the bxl. Instead, they will return a set of\nartifacts to expose to users, which buck2 will automatically build after\nfinalizing the action factory. For dynamic-ness, bxl users will use the standard\ndynamic output api. There is an issue that during the dynamic output api's\nlambda, bxl functions will not be able to access the regular bxl functions for\nqueries, etc. However, this is likely not important as most use cases should\nreasonably query bxl data before the dynamic outputs, and have limited power in\ndynamic-ness. We can also always replace the ctx of the dynamic to be the bxl\ncontext in the future, as we see fit."}),"\n",(0,i.jsx)(t.p,{children:"Sample:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'def my_bxl(ctx):\n    actions_factory = ctx.bxl_actions.factory()\n\n    artifact = actions_factory.write("file.txt", "content")\n\n    # note that existing artifacts that were declared by other rules can be built\n    ctx.actions.build(ctx.analysis(ctx.target("foo")).providers[DefaultInfo].default_output))\n\n    return [artifact] # exposes the declared artifact to users\n'})}),"\n",(0,i.jsx)(t.h2,{id:"internal-representation-deferred-framework",children:"Internal Representation (Deferred Framework)"}),"\n",(0,i.jsxs)(t.p,{children:["The existing actions framework attaches all actions to a deferred, which is\nbased off a ",(0,i.jsx)(t.code,{children:"ConfiguredLabel"}),", which also corresponds to the output path prefix.\nbxl actions should also have a unique output path prefix, and follow the same\nsystem of having a base deferred key to reuse the action implementation."]}),"\n",(0,i.jsxs)(t.p,{children:["We should extend the ",(0,i.jsx)(t.code,{children:"BaseKey"})," of a ",(0,i.jsx)(t.code,{children:"DeferredKey"})," to support beyond a\n",(0,i.jsx)(t.code,{children:"ConfiguredLabel"}),", so that we can use a ",(0,i.jsx)(t.code,{children:"BxlFunctionLabel"})," in its place. This\nwould allow ",(0,i.jsx)(t.code,{children:"owner"})," of these actions to point to the correct creator. The output\npath would be determined by using the ",(0,i.jsx)(t.code,{children:"BxlFunctionLabel"})," as prefix similar to a\nlabel. While this means that not all outputs are associated with an actual rule,\nthis is arguably more correct as bxl that creates outputs that doesn't fit the\ntarget graph structure (i.e android project generation follows directory\nstructure rather than the packages defined by targets) to not have to conform\nthe attaching their actions to existing rules. bxl functions can examine\nmultiple rules and create a single action, attached only to their function\nlabel."]}),"\n",(0,i.jsxs)(t.p,{children:["The ActionRegistry will be attached to the evaluation result of ",(0,i.jsx)(t.code,{children:"bxl"}),". Since we\ndo not allow bxl to explicitly request build of the actions itself declares, we\ncan wait until the end of the bxl function to finalize the actions. Then, the\naction lookup can simply refer to the result of the ",(0,i.jsx)(t.code,{children:"bxl"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"With the above changes, the rest of the actions framework does not need changed\nto support the proposed API. DICE caching will work as today."})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);