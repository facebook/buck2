BUCK_CPP_RULE_KINDS = [
    "apple_binary",
    "apple_library",
    "apple_test",
    "cxx_python_extension",
    ".*xx_binary",
    ".*xx_library",
    ".*xx_.*_library",
    ".*xx_test",
    ".*xx_resources",
]
CPP_HEADER_EXTENTIONS = [".h", ".hh", ".hpp", ".hxx", ".h++"]
CPP_SOURCE_EXTENSIONS = [".c", ".cc", ".cpp", ".cxx", ".c++", ".m", ".mm"]

def _impl(ctx):
    owner = findOwningTarget(ctx)
    if owner != None:
        buildTarget = configured_sub_target(owner.label, "compilation-database")
        print(buildTarget)
        res = ctx.build(buildTarget).values()
        print(res)

def findOwningTarget(ctx):
    filename = ctx.cli_args.filename
    owners = ctx.cquery.attrregexfilter(
        "srcs",
        ".*",
        ctx.cquery.kind("|".join(BUCK_CPP_RULE_KINDS), ctx.cquery.owner(filename)),
    )
    if len(owners) >= 1:
        return pickTarget(ctx, owners)
    if isSourceFile(filename):
        print("Cannot find owner for source file " + filename)
        return None
        # TODO: check if the header file exist

    elif isHeaderFile(filename):
        # remove the src = '.*' attr filter and try again
        unfilteredTargets = ctx.cquery.kind(
            "|".join(BUCK_CPP_RULE_KINDS),
            ctx.cquery.owner(filename),
        )
        if len(unfilteredTargets) == 0:
            print("Cannot find unfiltered owner for header file " + filename)
            return None
        rdepOwners = findTargetsByReverseDependency(ctx, unfilteredTargets)
        if len(rdepOwners) == 0:
            print("Cannot find rdep owner for header file " + filename)
            return None
        return pickTarget(ctx, rdepOwners)
    else:
        print("File extension not supported " + filename)
        return None

def findTargetsByReverseDependency(ctx, unfilteredTargets):
    for searchDepth in range(1, 3):
        for unfilteredTarget in unfilteredTargets:
            buildPackage = unfilteredTarget.split(":")[0]
            dirCount = buildPackage.count("/")
            owners = []

            # workaround for a lack of while loop
            for _i in range(dirCount + 1):
                owners = ctx.cquery.attrregexfilter(
                    "srcs",
                    ".*",
                    ctx.cquery.kind(
                        "|".join(BUCK_CPP_RULE_KINDS),
                        ctx.cquery.rdeps(
                            buildPackage + "/...",
                            unfilteredTarget,
                            searchDepth,
                        ),
                    ),
                )
                if buildPackage == "/" or len(buildPackage) == 0:
                    break
                buildPackage = buildPackage[0:buildPackage.rindex("/")]
                if buildPackage == "//" or buildPackage == ".":
                    buildPackage = "/"
                if len(owners) > 0:
                    return owners

    return []

def pickTarget(ctx, targets):
    if len(targets) == 1:
        for target in targets:
            return target

    if ctx.cli_args.os == "darwin":
        for target in targets:
            if target.endswith("applemac"):
                return target

    # todo: identify fobjc mode

    # pick a target that's prefix for all other targets
    sortedTargets = sorted(targets, key = lambda target: target.label)
    for sortedTarget in sortedTargets:
        if not sortedTarget.label.startswith(sortedTargets[0].label):
            return targets[0]
    return sortedTargets[0]

def isSourceFile(filename):
    for ext in CPP_SOURCE_EXTENSIONS:
        if filename.endswith(ext):
            return True
    return False

def isHeaderFile(filename):
    for ext in CPP_HEADER_EXTENTIONS:
        if filename.endswith(ext):
            return True
    return False

cpp_gen_cdb = bxl(
    implementation = _impl,
    cli_args = {
        "filename": cli_args.string(),
        "os": cli_args.string(),
    },
)
