"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[30280],{28453:(n,t,e)=>{e.d(t,{R:()=>s,x:()=>a});var i=e(96540);const o={},r=i.createContext(o);function s(n){const t=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(t):{...t,...n}},[t,n])}function a(n){let t;return t=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),i.createElement(r.Provider,{value:t},n.children)}},81216:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"rule_authors/configuration_transitions","title":"Configuration Transitions","description":"Configuration transition is a mechanism for changing the configuration when","source":"@site/../docs/rule_authors/configuration_transitions.md","sourceDirName":"rule_authors","slug":"/rule_authors/configuration_transitions","permalink":"/docs/rule_authors/configuration_transitions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"configuration_transitions","title":"Configuration Transitions"},"sidebar":"main","previous":{"title":"Configurations By Example","permalink":"/docs/rule_authors/configurations_by_example"},"next":{"title":"Macros","permalink":"/docs/rule_authors/custom_macros"}}');var o=e(74848),r=e(28453);const s={id:"configuration_transitions",title:"Configuration Transitions"},a=void 0,c={},l=[{value:"Defining transitions",id:"defining-transitions",level:2},{value:"Idempotence",id:"idempotence",level:4},{value:"Incoming edge transitions",id:"incoming-edge-transitions",level:2},{value:"Outgoing edge transitions",id:"outgoing-edge-transitions",level:2},{value:"Access rule attributes in transition function implementation",id:"access-rule-attributes-in-transition-function-implementation",level:2},{value:"Deprecated transition declarations with <code>transition</code> objects",id:"deprecated-transition-declarations-with-transition-objects",level:2},{value:"Split transitions",id:"split-transitions",level:2}];function d(n){const t={admonition:"admonition",code:"code",h2:"h2",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"Configuration transition is a mechanism for changing the configuration when\ndepending on a target."}),"\n",(0,o.jsx)(t.p,{children:"Currently, Buck2 has incoming and outgoing transitions:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Incoming"})," transitions are specified per-target and take effect when\ndepending on that target."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Outgoing"})," transitions are specified on an attribute and take effect on\ndependencies that appear in that attribute."]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"defining-transitions",children:"Defining transitions"}),"\n",(0,o.jsxs)(t.p,{children:["The meat of any transition definition is the transition implementation, a\nfunction which accepts the pre-transition ",(0,o.jsx)(t.code,{children:"PlatformInfo"})," as an argument, and\nreturns the modified ",(0,o.jsx)(t.code,{children:"PlatformInfo"})," that should be transitioned to. Here's an\nexample of what such a function might look like:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:'def _transition_impl_with_refs(platform: PlatformInfo) -> PlatformInfo:\n    # Not bound in this function, see below for where these come from\n    os = os[ConstraintSettingInfo]\n    watchos = watchos[ConstraintValueInfo]\n    # Remove operating system constraint from input platform.\n    constraints = {\n        s: v\n        for (s, v) in platform.configuration.constraints.items()\n        if s != os.label\n    }\n    # Add watchos constraint value.\n    constraints[watchos.setting.label] = watchos\n    # Construct configuration structure.\n    new_cfg = ConfigurationInfo(\n        # Updated constraints.\n        constraints = constraints,\n        # Keep original config values.\n        values = platform.configuration.values,\n    )\n    # And return new configuration,\n    # or a dict of marker to configuration in case of split transition.\n    return PlatformInfo(\n        # ... supplying configuration label.\n        label = "<transitioned-to-watch>",\n        configuration = new_cfg,\n    )\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Much like constraints and platforms, transitions make their way into the graph\nby means of a target that returns a built-in provider - specifically, the\n",(0,o.jsx)(t.code,{children:"TransitionInfo"})," provider. The ",(0,o.jsx)(t.code,{children:"TransitionInfo"})," provider accepts only one\nparameter, ",(0,o.jsx)(t.code,{children:"impl"})," a callable with signature ",(0,o.jsx)(t.code,{children:"PlatformInfo -> PlatformInfo"}),". With\nthat in mind, we can a transition rule:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:"def _transition_to_watchos_impl(_ctx: AnalysisContext) -> list[Provider]:\n\n    # From above\n    def _transition_impl_with_refs(platform: PlatformInfo) -> PlatformInfo:\n        # Not bound in this function, see below for where these come from\n        os = os[ConstraintSettingInfo]\n        watchos = watchos[ConstraintValueInfo]\n        ...\n\n    return [\n        DefaultInfo(),\n        TransitionInfo(\n            impl = _transition_impl_with_refs,\n        ),\n    ]\n\ntransition_to_watchos = rule(\n    impl = _transition_to_watchos_impl,\n    attrs = {},\n    # Rules that define transitions must be configuration rules\n    is_configuration_rule = True,\n)\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Most transition functions will require access to the analysis outputs of other\nconfiguration rules, typically to extract a ",(0,o.jsx)(t.code,{children:"ConstraintSettingInfo"}),",\n",(0,o.jsx)(t.code,{children:"ConstraintValueInfo"}),", or ",(0,o.jsx)(t.code,{children:"PlatformInfo"})," from them. The example above does as\nwell - it needs the ",(0,o.jsx)(t.code,{children:"os"})," constraint setting and ",(0,o.jsx)(t.code,{children:"watchos"})," constraint value."]}),"\n",(0,o.jsx)(t.p,{children:"Analysis results from other configuration rules are made available by depending\non those rules as dependencies like in any other analysis. We can use that to\nfinish the example above:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:'def _transition_to_watchos_impl(ctx: AnalysisContext) -> list[Provider]:\n    os = ctx.attrs.os\n    watchos = ctx.attrs.watchos\n\n    # From above\n    def _transition_impl_with_refs(platform: PlatformInfo) -> PlatformInfo:\n        # These values are captured into the `def` from above\n        os = os[ConstraintSettingInfo]\n        watchos = watchos[ConstraintValueInfo]\n        ...\n\n    return [\n        DefaultInfo(),\n        TransitionInfo(\n            impl = _transition_impl_with_refs,\n        ),\n    ]\n\ntransition_to_watchos = rule(\n    impl = _transition_to_watchos_impl,\n    attrs = {\n        "os": attrs.dep(default = "//constraints:os"),\n        "watchos": attrs.dep(default = "//constraints:watchos"),\n    },\n    is_configuration_rule = True,\n)\n'})}),"\n",(0,o.jsx)(t.h4,{id:"idempotence",children:"Idempotence"}),"\n",(0,o.jsx)(t.p,{children:"A transition function applied twice must produce the configuration identical to\nthe configuration produced after applying transition once. Violating this\nrequirement is an error."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:"assert tr(tr(platform=platform)) == tr(platform=platform)\n"})}),"\n",(0,o.jsx)(t.h2,{id:"incoming-edge-transitions",children:"Incoming edge transitions"}),"\n",(0,o.jsxs)(t.p,{children:["With a suitable transition target defined, you can set an incoming edge\ntransition on a target by passing the transition target to the built-in\n",(0,o.jsx)(t.code,{children:"incoming_transition"})," attribute, like this:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:'# BUCK\ntransition_to_watchos(\n    name = "transition_to_watchos",\n)\n\nmy_binary(\n    name = "watchos_binary",\n    deps = ...\n    incoming_transition = ":transition_to_watchos",\n)\n'})}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"incoming_transition"})," attributes are not available on all rules - instead, rules\nmust declare that they support them by setting\n",(0,o.jsx)(t.code,{children:"supports_incoming_transition = True"})," as a parameter to the ",(0,o.jsx)(t.code,{children:"rule"})," call"]}),"\n",(0,o.jsx)(t.h2,{id:"outgoing-edge-transitions",children:"Outgoing edge transitions"}),"\n",(0,o.jsxs)(t.p,{children:["Outgoing edge transitions are declared via use of\n",(0,o.jsx)(t.code,{children:'attrs.transition_dep(cfg = ":transition_target")'}),". Such attributes act much\nlike an ",(0,o.jsx)(t.code,{children:"attrs.dep()"}),", except that the transition is applied."]}),"\n",(0,o.jsx)(t.h2,{id:"access-rule-attributes-in-transition-function-implementation",children:"Access rule attributes in transition function implementation"}),"\n",(0,o.jsxs)(t.p,{children:["It might be useful for the transition function to be able to query rule\nattributes (for example, to perform transition to different configurations\ndepending on ",(0,o.jsx)(t.code,{children:"java_version"})," attribute)."]}),"\n",(0,o.jsx)(t.p,{children:"Both incoming (per rule) and outgoing (per dependency) transitions can access\nrule attributes. For outgoing transitions, transition rule implementation\naccesses the attributes of the target that has dependencies with transitions,\nnot attributes of dependency targets."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:'def _tr(platform, attrs):\n    # NB: There are some restrictions on what attrs can be made accessible:\n    # - Only primitive values for now (providers are not resolved)\n    # - Only unconfigured attributes for now\n    attrs.my_list_attribute # == [12345, 67890]\n\n\ndef _transition_target_impl(ctx):\n    return [\n        DefaultInfo(),\n        TransitionInfo(\n            impl = _tr,\n            attrs = {\n                "my_list_attribute": attr.list(...),\n            },\n        ),\n    ]\n_transition_target = rule(\n    impl = _transition_target_impl,\n    is_configuration_rule = True,\n)\n\n_transition_target(\n    name = "my_transition_target",\n)\n\nmy_rule = rule(..., supports_incoming_transition)\n\nmy_rule(\n    ...,\n    my_list_attribute = [12345, 67890],\n    incoming_transition = ":my_transition_target",\n)\n'})}),"\n",(0,o.jsxs)(t.h2,{id:"deprecated-transition-declarations-with-transition-objects",children:["Deprecated transition declarations with ",(0,o.jsx)(t.code,{children:"transition"})," objects"]}),"\n",(0,o.jsxs)(t.p,{children:["There is an old, soft-deprecated mechanism to declare transitions that used\nobjects returned by the ",(0,o.jsx)(t.code,{children:"transition"})," object. These work substantially similarly\nwith the objects replacing transition targets, but there are some key\ndifferences (uquery correctness bugs, first class refs, etc.)."]}),"\n",(0,o.jsx)(t.p,{children:"The new API is strictly more powerful - it should be used instead in new code."}),"\n",(0,o.jsx)(t.h2,{id:"split-transitions",children:"Split transitions"}),"\n",(0,o.jsx)(t.p,{children:'Along with the old transition API, there is first class support for a notion of\n"split transitions." It is currently unclear whether split transitions will\nremain supported as a first-class concept going forward. It is probably wise to\nuse something along the lines of the following instead:'}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:"attrs.tuple(\n    attrs.transition_dep(cfg = tr_1),\n    attrs.transition_dep(cfg = tr_2),\n)\n"})}),"\n",(0,o.jsx)(t.p,{children:"For completeness, below are the old docs for split transitions:"}),"\n",(0,o.jsx)(t.p,{children:"For split transition, each dependency is resolved into a dict of marker to\nproviders."}),"\n",(0,o.jsx)(t.p,{children:"For example:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:'android_binary = rule(\n    ...\n    attrs = {\n        "deps": attrs.list(attrs.split_transition_dep(cfg = cpu_split_transition), default = []),\n    },\n)\n'})}),"\n",(0,o.jsx)(t.p,{children:"When the above is invoked as follows:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:'android_binary(\n    deps = ["//foo:bar", "//qux:quux"],\n)\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Then the rule implementation gets something like the following in the ",(0,o.jsx)(t.code,{children:"deps"}),"\nattribute:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:'{\n    [\n        {\n            # Key in this dict is the marker returned from split transition impl function.\n            "arm64": "providers for //foo:bar configured for arm64",\n            "armv7": "providers for //foo:bar configured for armv7",\n        },\n        {\n            "arm64": "providers for //qux:quux configured for arm64",\n            "armv7": "providers for //qux:quux configured for armv7",\n        },\n    ]\n}\n'})}),"\n",(0,o.jsx)(t.admonition,{type:"note",children:(0,o.jsxs)(t.p,{children:["It is an error to pass a split transition object to ",(0,o.jsx)(t.code,{children:"attrs.transition_dep"})," and a\nnon-split transition to ",(0,o.jsx)(t.code,{children:"attrs.split_transition_dep"}),"."]})})]})}function u(n={}){const{wrapper:t}={...(0,r.R)(),...n.components};return t?(0,o.jsx)(t,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}}}]);