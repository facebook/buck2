"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[65386],{10810:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"users/commands/cquery","title":"cquery","description":"This document provides an overview of the commands and options available under buck2 cquery.","source":"@site/../docs/users/commands/cquery.generated.md","sourceDirName":"users/commands","slug":"/users/commands/cquery","permalink":"/docs/users/commands/cquery","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"cquery","title":"cquery"},"sidebar":"main","previous":{"title":"completion","permalink":"/docs/users/commands/completion"},"next":{"title":"ctargets","permalink":"/docs/users/commands/ctargets"}}');var r=i(74848),t=i(28453);const l={id:"cquery",title:"cquery"},c="cquery",o={},a=[{value:"<code>buck2 cquery</code>",id:"buck2-cquery",level:2},{value:"Arguments:",id:"arguments",level:3},{value:"Common Options:",id:"common-options",level:3},{value:"Options:",id:"options",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"cquery",children:"cquery"})}),"\n",(0,r.jsxs)(n.p,{children:["This document provides an overview of the commands and options available under ",(0,r.jsx)(n.code,{children:"buck2 cquery"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"buck2-cquery",children:(0,r.jsx)(n.code,{children:"buck2 cquery"})}),"\n",(0,r.jsx)(n.p,{children:"Perform queries on the configured target graph"}),"\n",(0,r.jsxs)(n.p,{children:["The configured target graph includes information about the configuration\n(platforms) and transitions involved in building targets. In the\nconfigured graph, ",(0,r.jsx)(n.code,{children:"selects"})," are fully resolved. The same target may\nappear in multiple different configurations (when printed, the\nconfiguration is after the target in parentheses)."]}),"\n",(0,r.jsxs)(n.p,{children:["A user can specify a ",(0,r.jsx)(n.code,{children:"--target-universe"})," flag to control how literals\nare resolved. When provided, any literals will resolve to all\nmatching targets within the universe (which includes the targets\npassed as the universe and all transitive deps of them).  When not\nprovided, we implicitly set the universe to be rooted at every\ntarget literal in the ",(0,r.jsx)(n.code,{children:"cquery"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Run ",(0,r.jsx)(n.code,{children:"buck2 docs cquery"})," or\n",(0,r.jsx)(n.a,{href:"https://buck2.build/docs/users/query/cquery/",children:"https://buck2.build/docs/users/query/cquery/"}),"\nfor more documentation about the functions available in cquery\nexpressions."]}),"\n",(0,r.jsx)(n.p,{children:"Examples:"}),"\n",(0,r.jsx)(n.p,{children:"Print all the attributes of a target"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"buck2 cquery //java/com/example/app:amazing --output-all-attributes"})}),"\n",(0,r.jsx)(n.p,{children:"List the deps of a target (special characters in a target will\nrequire quotes):"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"buck2 cquery 'deps(\"//java/com/example/app:amazing+more\")'"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Usage"}),": ",(0,r.jsx)(n.code,{children:"buck2 cquery [OPTIONS] <QUERY> [QUERY_ARGS]..."})]}),"\n",(0,r.jsx)(n.h3,{id:"arguments",children:"Arguments:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"<QUERY>"}),"\nthe query to evaluate"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"<QUERY_ARGS>"}),"\nlist of literals for a multi-query (one containing ",(0,r.jsx)(n.code,{children:"%s"})," or ",(0,r.jsx)(n.code,{children:"%Ss"}),")"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"common-options",children:"Common Options:"}),"\n",(0,r.jsxs)(n.p,{children:["Common options are documented on the ",(0,r.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,r.jsx)(n.h3,{id:"options",children:"Options:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"-A, --output-all-attributes"}),"\nOutput all attributes, equivalent of --output-attribute ''."]}),"\n",(0,r.jsx)(n.p,{children:"Avoid using this flag in automation because it may be expensive to produce certain attributes, and because it makes harder to track which special attributes are used."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"-B, --output-basic-attributes"}),"\nOutput basic attributes, namely those the user can supply, plus rule type and package name"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"-a, --output-attribute <ATTRIBUTE>"}),'\nRegular expressions to match attributes. Regular expressions are used in "search" mode, so for example empty string matches all attributes including special attributes.']}),"\n",(0,r.jsxs)(n.p,{children:["When using in automation, please specify the regular expression to match the attribute precisely, for example ",(0,r.jsx)(n.code,{children:"--output-attribute '^headers$'"})," to make it easier to track which special attributes are used."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"--output-attributes <ATTRIBUTE>"}),"\nDeprecated: Use ",(0,r.jsx)(n.code,{children:"--output-attribute"})," instead."]}),"\n",(0,r.jsx)(n.p,{children:"List of space-separated attributes to output, --output-attributes attr1 attr2."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"--json"}),"\nOutput in JSON format"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"--dot"}),"\nOutput in Graphviz Dot format"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"--dot-compact"}),"\nOutput in a more compact format than Graphviz Dot"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"--output-format <dot|dot_compact|json|starlark|html>"}),"\nOutput format (default: list)."]}),"\n",(0,r.jsx)(n.p,{children:"dot -  dot graph format."}),"\n",(0,r.jsx)(n.p,{children:"dot_compact - compact alternative to dot format."}),"\n",(0,r.jsx)(n.p,{children:"json - JSON format."}),"\n",(0,r.jsx)(n.p,{children:"starlark - targets are printed like starlark code that would produce them.\nhtml - html file containing interactive target graph."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Possible values:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"dot"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"json"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"dot_compact"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"starlark"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"html"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"--show-providers"}),"\nShow the providers of the query result instead of the attributes and labels"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"-u, --target-universe <TARGET_UNIVERSE>"}),"\nComma separated list of targets to construct a configured target universe."]}),"\n",(0,r.jsxs)(n.p,{children:["When the option is specified, command targets are be resolved in this universe.\nAdditionally, ",(0,r.jsx)(n.code,{children:"--target-platforms="})," and ",(0,r.jsx)(n.code,{children:"--modifier="})," flags are be used to configure the\nuniverse targets, not the command targets."]}),"\n",(0,r.jsx)(n.p,{children:"This argument is particularly recommended on most non-trivial cqueries. In the absence of\nthis argument, buck2 will use the target literals in your cquery expression as the value\nfor this argument, which may not be what you want."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"--target-platforms <PLATFORM>"}),"\nConfiguration target (one) to use to configure targets"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"-m, --modifier <VALUE>"}),"\nA configuration modifier to configure all targets on the command line. This may be a constraint value target."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"--disable-starlark-types"}),"\nDisable runtime type checking in Starlark interpreter."]}),"\n",(0,r.jsx)(n.p,{children:"This option is not stable, and can be used only locally to diagnose evaluation performance problems."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"--stack"}),"\nRecord or show target call stacks."]}),"\n",(0,r.jsx)(n.p,{children:"Starlark call stacks will be included in duplicate targets error."}),"\n",(0,r.jsxs)(n.p,{children:["If a command outputs targets (like ",(0,r.jsx)(n.code,{children:"targets"})," command), starlark call stacks will be printed after the targets."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"--profile-patterns <PROFILE_PATTERNS>"}),"\nEnables profiling for all evaluations whose evaluation identifier matches one of the provided patterns."]}),"\n",(0,r.jsxs)(n.p,{children:["Some examples identifiers: analysis/cell//buck2/app/buck2_action_impl",":buck2_action_impl"," (cfg",":linux-x86_64","#27ac5723e0c99706) load/cell//build_defs/json.bzl load/prelude//playground/test.bxl load/cell//build_defs/json.bzl@other_cell load_buildfile/fbcode//third-party-buck/platform010/build/ncurses load_packagefile/fbcode//cli/rust/cli_delegate anon_analysis/anon//:_anon_link_rule (anon: 766183dc9b6f680a) (fbcode//buck2/platform/execution",":linux-x86_64","#08961b14cfb182aa) bxl/prelude//playground/test.bxl",":playground"]}),"\n",(0,r.jsxs)(n.p,{children:["You can pass ",(0,r.jsx)(n.code,{children:"--profile-patterns=.*"})," to enable no-op profiling for everything (additionally pass ",(0,r.jsx)(n.code,{children:"--profile-patterns-mode=none"})," to use no-op profiling to just get a list of all the identifiers)."]}),"\n",(0,r.jsxs)(n.p,{children:["The profile results will be written to individual .profile files in ",(0,r.jsx)(n.code,{children:"<ROOT_OUTPUT>/<data+time>-<uuid>/"})," where ROOT_OUTPUT comes from the --profile-patterns-output flag. In that directory there will also be a file listing all the identifiers that were profiled."]}),"\n",(0,r.jsx)(n.p,{children:"Enabling/disabling profiling of an evaluation will invalidate the results of that evaluation and it will be recomputed. In some cases, this will cause other work to also need to be redone (for example, invalidating the result of loading PACKAGE files causes all consumers to be recomputed). But if you keep profiling options consistent between commands, only the work that is otherwise invalidated will be redone (and only for those would profiling results be created)."}),"\n",(0,r.jsx)(n.p,{children:"You must also pass --profile-patterns-mode and --profile-patterns-output."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"--profile-patterns-output <PATH>"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"--profile-patterns-mode <PROFILE_PATTERNS_MODE>"}),"\nProfile mode."]}),"\n",(0,r.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,r.jsx)(n.code,{children:"-allocated"})," or ",(0,r.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heaps after analysis completes. ",(0,r.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Possible values:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"time-flame"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"statement"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"bytecode"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"typecheck"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"coverage"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"--profile-mode <PROFILE_MODE>"}),"\nProfile target loading."]}),"\n",(0,r.jsxs)(n.p,{children:["When this option is enabled, Buck will profile every ",(0,r.jsx)(n.code,{children:"BUCK"})," file loaded during the query and merge the results into a single profile. The command may return cached profile data if ",(0,r.jsx)(n.code,{children:"BUCK"})," files were not invalidated."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Possible values:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"time-flame"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"statement"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"bytecode"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"typecheck"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"coverage"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"--profile-output <PROFILE_OUTPUT>"}),"\nWhere to write profile output"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>c});var s=i(96540);const r={},t=s.createContext(r);function l(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);