load(
    "@fbcode//buck2/prelude/cxx:comp_db.bzl",
    "CxxCompilationDbInfo",
)

BUCK_CPP_RULE_KINDS = [
    "apple_binary",
    "apple_library",
    "apple_test",
    "cxx_python_extension",
    ".*xx_binary",
    ".*xx_library",
    ".*xx_.*_library",
    ".*xx_test",
    ".*xx_resources",
]
CPP_HEADER_EXTENTIONS = [".h", ".hh", ".hpp", ".hxx", ".h++"]
CPP_SOURCE_EXTENSIONS = [".c", ".cc", ".cpp", ".cxx", ".c++", ".m", ".mm"]

def _impl(ctx):
    filename = ctx.cli_args.filename
    owner = findOwningTarget(ctx, filename)
    if owner != None:
        buckRoot = ctx.root()
        providers = ctx.analysis(owner, None, True).providers()
        artifact = providers[CxxCompilationDbInfo].info.values()[0]
        sourceLabel = owner.get_source(filename, ctx)
        if sourceLabel in providers[CxxCompilationDbInfo].info:
            artifact = providers[CxxCompilationDbInfo].info[sourceLabel]
        compileCommands = []
        arguments = cmd_args()
        arguments.add(artifact.cxx_compile_cmd.base_compile_cmd)
        arguments.add(artifact.cxx_compile_cmd.argsfile.argfile_args)
        arguments.add(artifact.args)

        # @unsorted-dict-items
        compileCommands.append({"file": filename, "directory": buckRoot, "arguments": arguments})
        actionFactory = ctx.bxl_actions.action_factory()
        compdbArtifact = actionFactory.write_json("compdb.json", compileCommands)
        # HMAP CONVERTER
        # hmapConverter = ctx.analysis("fbsource//xplat/scripts/clangd/hmapconverter:bxlhmapconverter").providers()[RunInfo]
        # outputDir = actionFactory.declare_output("merged_cdb")
        # cmd = cmd_args(hmapConverter)
        # cmd.add("--input-file")
        # cmd.add(compdbArtifact)
        # cmd.add("--output-dir")
        # cmd.add(outputDir.as_output())
        # actionFactory.run(cmd, category = "cxx_merge_compdb_hmap")

        # TODO: do we need this for dependencies materialization?
        # buildTarget = configured_sub_target(owner.label, "compilation-database")
        # ctx.build(buildTarget)
        return [compdbArtifact]
    return []

def findOwningTarget(ctx, filename):
    owner = runCqueryOwner(ctx, filename)
    if owner != None:
        return owner
    if isSourceFile(filename):
        print("Cannot find owner for source file " + filename)
        return None
    elif isHeaderFile(filename):
        correspondingSourceFile = filename.split(".")[0] + ".cpp"
        if ctx.unstable_fs.exists(correspondingSourceFile):
            owner = runCqueryOwner(ctx, correspondingSourceFile)
            if owner != None:
                return owner

        # remove the src = '.*' attr filter and try again
        unfilteredTargets = ctx.cquery().kind(
            "|".join(BUCK_CPP_RULE_KINDS),
            ctx.cquery().owner(filename),
        )
        if len(unfilteredTargets) == 0:
            print("Cannot find unfiltered owner for header file " + filename)
            return None
        rdepOwners = findTargetsByReverseDependency(ctx, unfilteredTargets)
        if len(rdepOwners) == 0:
            print("Cannot find rdep owner for header file " + filename)
            return None
        return pickTarget(ctx, rdepOwners)
    else:
        print("File extension not supported " + filename)
        return None

def runCqueryOwner(ctx, filename):
    owners = ctx.cquery().attrregexfilter(
        "srcs",
        ".*",
        ctx.cquery().kind("|".join(BUCK_CPP_RULE_KINDS), ctx.cquery().owner(filename)),
    )
    if len(owners) >= 1:
        return pickTarget(ctx, owners)
    return None

def findTargetsByReverseDependency(ctx, unfilteredTargets):
    for searchDepth in range(1, 3):
        for unfilteredTarget in unfilteredTargets:
            buildPackage = str(unfilteredTarget.label).split(":")[0]
            dirCount = buildPackage.count("/")
            owners = []
            fromTarget = str(unfilteredTarget.label).split(" ")[0]

            # workaround for a lack of while loop
            for _i in range(dirCount + 1):
                universe = buildPackage + "/..."
                owners = ctx.cquery().attrregexfilter(
                    "srcs",
                    ".*",
                    ctx.cquery().kind(
                        "|".join(BUCK_CPP_RULE_KINDS),
                        ctx.cquery().rdeps(
                            universe,
                            fromTarget,
                            searchDepth,
                        ),
                    ),
                )
                if buildPackage == "/" or len(buildPackage) == 0:
                    break
                buildPackage = buildPackage[0:buildPackage.rindex("/")]
                if buildPackage == "//" or buildPackage == ".":
                    buildPackage = "/"
                if len(owners) > 0:
                    return owners

    return []

def pickTarget(ctx, targets):
    if len(targets) == 1:
        for target in targets:
            return target

    if ctx.cli_args.os == "darwin":
        for target in targets:
            if str(target.label).endswith("applemac"):
                return target

    # todo: identify fobjc mode

    # pick a target that's prefix for all other targets
    sortedTargets = sorted(targets, key = lambda target: str(target.label))
    for sortedTarget in sortedTargets:
        if not str(sortedTarget.label).startswith(str(sortedTargets[0].label)):
            return targets[0]
    return sortedTargets[0]

def isSourceFile(filename):
    for ext in CPP_SOURCE_EXTENSIONS:
        if filename.endswith(ext):
            return True
    return False

def isHeaderFile(filename):
    for ext in CPP_HEADER_EXTENTIONS:
        if filename.endswith(ext):
            return True
    return False

cpp_gen_cdb = bxl(
    implementation = _impl,
    cli_args = {
        "filename": cli_args.string(),
        "os": cli_args.string(),
    },
)
