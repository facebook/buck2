"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[34229],{28453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>d});var a=r(96540);const s={},o=a.createContext(s);function l(e){const n=a.useContext(o);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),a.createElement(o.Provider,{value:n},e.children)}},67513:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>a,toc:()=>i});const a=JSON.parse('{"id":"developers/starlark/heaps","title":"Heaps and Heap References","description":"Heaps","source":"@site/../docs/developers/starlark/heaps.generated.md","sourceDirName":"developers/starlark","slug":"/developers/starlark/heaps","permalink":"/docs/developers/starlark/heaps","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"heaps"},"sidebar":"main","previous":{"title":"A Moving Garbage Collector","permalink":"/docs/developers/starlark/gc"},"next":{"title":"Starlark Language Specification","permalink":"/docs/developers/starlark/spec"}}');var s=r(74848),o=r(28453);const l={id:"heaps"},d="Heaps and Heap References",c={},i=[{value:"Heaps",id:"heaps",level:2},{value:"Heap Containers",id:"heap-containers",level:2},{value:"Heap References",id:"heap-references",level:2},{value:"<code>OwnedFrozenValue</code>",id:"ownedfrozenvalue",level:2}];function t(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"heaps-and-heap-references",children:"Heaps and Heap References"})}),"\n",(0,s.jsx)(n.h2,{id:"heaps",children:"Heaps"}),"\n",(0,s.jsx)(n.p,{children:"In Starlark, there are three interesting heap-related points of interest:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.code,{children:"Heap"})," has ",(0,s.jsx)(n.code,{children:"Value"}),"'s allocated on it and cannot be cloned or shared."]}),"\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.code,{children:"FrozenHeap"})," has ",(0,s.jsx)(n.code,{children:"FrozenValue"}),"'s allocated on it and cannot be cloned or\nshared."]}),"\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.code,{children:"FrozenHeapRef"})," is a ",(0,s.jsx)(n.code,{children:"FrozenHeap"})," that is now read-only and can now be\ncloned and shared."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"FrozenHeapRef"})," keeps a heap alive. While you have a ",(0,s.jsx)(n.code,{children:"FrozenValue"}),", it is\nimportant that you have either the ",(0,s.jsx)(n.code,{children:"FrozenHeap"})," itself, or more usually, a\n",(0,s.jsx)(n.code,{children:"FrozenHeapRef"})," to it. A ",(0,s.jsx)(n.code,{children:"FrozenHeap"})," may contains a set of ",(0,s.jsx)(n.code,{children:"FrozenHeapRef"}),"'s to\nkeep the ",(0,s.jsx)(n.code,{children:"FrozenHeap"}),"s it references alive."]}),"\n",(0,s.jsx)(n.h2,{id:"heap-containers",children:"Heap Containers"}),"\n",(0,s.jsx)(n.p,{children:"Heaps are included in other data types:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.code,{children:"Module"})," contains a ",(0,s.jsx)(n.code,{children:"Heap"})," (where normal values are allocated) and a\n",(0,s.jsx)(n.code,{children:"FrozenHeap"})," (stores references to other frozen heaps and has compilation\nconstants allocated on it). The ",(0,s.jsx)(n.code,{children:"Heap"})," portion is garbage collected. At the\nend, when you call ",(0,s.jsx)(n.code,{children:"freeze"}),", ",(0,s.jsx)(n.code,{children:"Value"}),"'s referenced by name in the ",(0,s.jsx)(n.code,{children:"Module"})," are\nmoved to the ",(0,s.jsx)(n.code,{children:"FrozenHeap"})," and then then ",(0,s.jsx)(n.code,{children:"FrozenHeap"})," is sealed to produce a\n",(0,s.jsx)(n.code,{children:"FrozenHeapRef"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.code,{children:"FrozenModule"})," contains a ",(0,s.jsx)(n.code,{children:"FrozenHeapRef"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.code,{children:"GlobalsBuilder"})," contains a ",(0,s.jsx)(n.code,{children:"FrozenHeap"})," onto which values are allocated."]}),"\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.code,{children:"Globals"})," contains a ",(0,s.jsx)(n.code,{children:"FrozenHeapRef"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"heap-references",children:"Heap References"}),"\n",(0,s.jsxs)(n.p,{children:["It is important that when a ",(0,s.jsx)(n.code,{children:"FrozenValue"})," X is referenced by a ",(0,s.jsx)(n.code,{children:"Value"})," or\n",(0,s.jsx)(n.code,{children:"FrozenValue"})," (for example, included in a list), the heap where X originates is\nadded as a reference to the heap where the new value is being created."]}),"\n",(0,s.jsx)(n.p,{children:"As a concrete example in pseudo-code:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'let h1 = FrozenHeap::new();\nlet s = "test".alloc(h1);\nlet h1 : FrozenHeapRef = h1.into_ref();\n\nlet h2 = Heap::new();\nh2.add_reference(h1);\nvec![s].alloc(h2);\n'})}),"\n",(0,s.jsx)(n.p,{children:"In the above code, the following steps are taken:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Create a ",(0,s.jsx)(n.code,{children:"FrozenHeap"})," then allocate something in it."]}),"\n",(0,s.jsx)(n.li,{children:"Turn the heap into a reference."}),"\n",(0,s.jsxs)(n.li,{children:["Use the allocated value ",(0,s.jsx)(n.code,{children:"s"})," from ",(0,s.jsx)(n.code,{children:"h1"})," when constructing a value in ",(0,s.jsx)(n.code,{children:"h2"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["For that to be legal, and for the heap ",(0,s.jsx)(n.code,{children:"h1"})," to not disappear while it is\nbeing allocated, it is important to call ",(0,s.jsx)(n.code,{children:"add_reference"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Note that this API can only point at a ",(0,s.jsx)(n.code,{children:"FrozenValue"})," from another heap, and only\nafter that heap has been turned into a reference, so it will not be allocated in\nanymore. These restrictions are deliberate and mean that most programs only have\none 'active heap' at a time."]}),"\n",(0,s.jsx)(n.p,{children:"Following are some places where heap references are added by Starlark:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Before evaluation is started, a reference is added to the ",(0,s.jsx)(n.code,{children:"Globals"})," from the\n",(0,s.jsx)(n.code,{children:"Module"}),", so it can access the global functions."]}),"\n",(0,s.jsxs)(n.li,{children:["When evaluating a ",(0,s.jsx)(n.code,{children:"load"})," statement, a reference is added to the ",(0,s.jsx)(n.code,{children:"FrozenModule"}),"\nthat is being loaded."]}),"\n",(0,s.jsxs)(n.li,{children:["When freezing a module, the ",(0,s.jsx)(n.code,{children:"FrozenHeap"}),", in the ",(0,s.jsx)(n.code,{children:"Module"}),", is moved to the\n",(0,s.jsx)(n.code,{children:"FrozenModule"}),", preserving the references that were added."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"ownedfrozenvalue",children:(0,s.jsx)(n.code,{children:"OwnedFrozenValue"})}),"\n",(0,s.jsxs)(n.p,{children:["When you get a value from a ",(0,s.jsx)(n.code,{children:"FrozenModule"}),", it will be a ",(0,s.jsx)(n.code,{children:"OwnedFrozenValue"}),".\nThis structure is a pair of a ",(0,s.jsx)(n.code,{children:"FrozenHeapRef"})," and a ",(0,s.jsx)(n.code,{children:"FrozenValue"}),", where the ref\nkeeps the value alive. You can move that ",(0,s.jsx)(n.code,{children:"OwnedFrozenValue"})," into the value of a\nmodule with code such as:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'fn move<\'v>(from: &FrozenModule, to: &\'v Module) {\n    let x : OwnedFrozenValue = from.get("value").unwrap();\n    let v : Value<\'v> = x.owned_value(&to);\n    to.set("value", v);\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In general, you can use the ",(0,s.jsx)(n.code,{children:"OwnedFrozenValue"})," in one of three ways:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Operate on it directly"})," - with methods like ",(0,s.jsx)(n.code,{children:"unpack_i32"})," or ",(0,s.jsx)(n.code,{children:"to_str"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Extract it safely"})," - using methods like ",(0,s.jsx)(n.code,{children:"owned_frozen_value"}),", which takes a\n",(0,s.jsx)(n.code,{children:"FrozenHeap"})," to which the heap reference is added and returns a naked\n",(0,s.jsx)(n.code,{children:"FrozenValue"}),". After that, it is then safe for the ",(0,s.jsx)(n.code,{children:"FrozenHeap"})," you passed in\nto use the ",(0,s.jsx)(n.code,{children:"FrozenValue"}),".","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["With ",(0,s.jsx)(n.code,{children:"owned_value"}),", there is lifetime checking that the right heap is\npassed, but with ",(0,s.jsx)(n.code,{children:"FrozenValue"}),", there isn't."]}),"\n",(0,s.jsx)(n.li,{children:"Be careful to pass the right heap, although given most programs only have\none active heap at a time, it should mostly work out."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Extract it unsafely"})," - using methods ",(0,s.jsx)(n.code,{children:"unchecked_frozen_value"}),", which gives\nyou the underlying ",(0,s.jsx)(n.code,{children:"FrozenValue"})," without adding any references.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Be careful to make sure there is a good reason the ",(0,s.jsx)(n.code,{children:"FrozenValue"})," remains\nvalid."]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(t,{...e})}):t(e)}}}]);