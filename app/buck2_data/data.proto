/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under both the MIT license found in the
 * LICENSE-MIT file in the root directory of this source tree and the Apache
 * License, Version 2.0 found in the LICENSE-APACHE file in the root directory
 * of this source tree.
 */

syntax = "proto3";

import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";

package buck.data;

// A single event originating from Buck. Its semantics depend on the `data`
// member.
message BuckEvent {
  reserved 2047;

  // A timestamp for when this event was fired, taken from the system clock.
  // Required.
  google.protobuf.Timestamp timestamp = 1;
  // A globally-unique ID (UUIDv4) of this trace. Required.
  string trace_id = 2;
  // A trace-unique 64-bit integer identifying this event's span ID, if this
  // event begins a new span or belongs to one. Required.
  uint64 span_id = 3;
  // A trace-unique 64-bit identifying the span that this event is logically
  // parented to. Required.
  uint64 parent_id = 4;
  // The payload of this event. Required.
  oneof data {
    SpanStartEvent span_start = 20;
    SpanEndEvent span_end = 21;
    InstantEvent instant = 22;
    // Not present in daemon -> CLI stream or event-log, sent to Scribe
    // directly.
    RecordEvent record = 23;
  }
}

// An event that begins a span.
message SpanStartEvent {
  // TODO(swgillespie) add fields common to span events
  // bool suspending = 1;
  oneof data {
    CommandStart command = 50;
    ActionExecutionStart action_execution = 51;
    AnalysisStart analysis = 52;
    LoadBuildFileStart load = 53;
    ExecutorStageStart executor_stage = 54;
    TestDiscoveryStart test_discovery = 55;
    TestRunStart test_start = 56;
    FileWatcherStart file_watcher = 57;
    MaterializeRequestedArtifactStart final_materialization = 58;
    AnalysisStageStart analysis_stage = 59;
    MatchDepFilesStart match_dep_files = 60;
    LoadPackageStart load_package = 61;
    SharedTaskStart shared_task = 62;
    CacheUploadStart cache_upload = 63;
    CreateOutputSymlinksStart create_output_symlinks = 64;
    CommandCriticalStart command_critical = 65;
    InstallEventInfoStart install_event_info = 66;
    DiceStateUpdateStart dice_state_update = 67;
    MaterializationStart materialization = 68;
    DiceCriticalSectionStart dice_critical_section = 69;
    DiceBlockConcurrentCommandStart dice_block_concurrent_command = 70;
    DiceSynchronizeSectionStart dice_synchronize_section = 71;
    DiceCleanupStart dice_cleanup = 72;
    ExclusiveCommandWaitStart exclusive_command_wait = 73;
    DeferredPreparationStageStart deferred_preparation_stage = 74;
    DynamicLambdaStart dynamic_lambda = 75;
    BxlExecutionStart bxl_execution = 76;
    BxlDiceInvocationStart bxl_dice_invocation = 77;
    ReUploadStart re_upload = 78;
    ConnectToInstallerStart connect_to_installer = 79;
    // Used in Buck unit tests.
    FakeStart fake = 999;
  }
}

// An event that ends a span.
message SpanEndEvent {
  SpanStats stats = 1;
  // The total duration of this span, as observed by the client.
  google.protobuf.Duration duration = 2;

  oneof data {
    CommandEnd command = 50;
    ActionExecutionEnd action_execution = 51;
    AnalysisEnd analysis = 52;
    LoadBuildFileEnd load = 53;
    ExecutorStageEnd executor_stage = 54;
    TestDiscoveryEnd test_discovery = 55;
    TestRunEnd test_end = 56;
    SpanCancelled span_cancelled = 57;
    FileWatcherEnd file_watcher = 58;
    MaterializeRequestedArtifactEnd final_materialization = 59;
    AnalysisStageEnd analysis_stage = 60;
    MatchDepFilesEnd match_dep_files = 61;
    LoadPackageEnd load_package = 62;
    SharedTaskEnd shared_task = 63;
    CacheUploadEnd cache_upload = 64;
    CreateOutputSymlinksEnd create_output_symlinks = 65;
    CommandCriticalEnd command_critical = 66;
    InstallEventInfoEnd install_event_info = 67;
    DiceStateUpdateEnd dice_state_update = 68;
    MaterializationEnd materialization = 69;
    DiceCriticalSectionEnd dice_critical_section = 70;
    DiceBlockConcurrentCommandEnd dice_block_concurrent_command = 71;
    DiceSynchronizeSectionEnd dice_synchronize_section = 72;
    DiceCleanupEnd dice_cleanup = 73;
    ExclusiveCommandWaitEnd exclusive_command_wait = 74;
    DeferredPreparationStageEnd deferred_preparation_stage = 75;
    DeferredEvaluationEnd deferred_evaluation = 76;
    BxlExecutionEnd bxl_execution = 77;
    BxlDiceInvocationEnd bxl_dice_invocation = 78;
    ReUploadEnd re_upload = 79;
    ConnectToInstallerEnd connect_to_installer = 80;
    // Used in Buck unit tests.
    FakeEnd fake = 999;
  }
}

message SpanStats {
  uint64 max_poll_time_us = 1;
  uint64 total_poll_time_us = 2;
}

// An event that represents a single point in time.
message InstantEvent {
  reserved 9, 13;

  oneof data {
    StructuredError structured_error = 1;
    MercurialInfo hg_info = 2;
    ConsoleMessage console_message = 3;
    BuildGraphExecutionInfo build_graph_info = 4;
    RemoteExecutionSessionCreated re_session = 5;
    // Test discovery occurs as an instant event because we know when it starts,
    // but we do not know when it is complete.
    // Instead, we are informed of individual tests that are discovered.
    TestDiscovery test_discovery = 6;
    // Test result is an instant event for similar reasons as TestDiscovery.
    // It corresponds with the completion of an individual test.
    TestResult test_result = 7;
    // Inform tailer that rage was performed on certain command.
    RageInvoked rage_invoked = 8;
    Snapshot snapshot = 10;

    DiceStateSnapshot dice_state_snapshot = 11;

    // A tag to mark on the scuba tables
    TagEvent tag_event = 14;

    // Sent when the target pattern gets resolved to update the invocation info
    ResolvedTargetPatterns target_patterns = 15;

    // Check DICE equality in critical section
    DiceEqualityCheck dice_equality_check = 16;

    // When we can execute DICE ops immediately since there was no active
    // state
    NoActiveDiceState no_active_dice_state = 17;

    // Info about materializer state
    MaterializerStateInfo materializer_state_info = 18;

    // Notify the client that the daemon is shutting down.
    DaemonShutdown daemon_shutdown = 19;

    // TODO iguridi: consolidate with RageInvoked
    RageResult rage_result = 20;

    // Notify the client that the daemon would like to update the rendering.
    ConsolePreferences console_preferences = 21;

    InternalError internal_error = 22;

    IoProviderInfo io_provider_info = 23;

    // Total number of concurrent commands in an active dice.
    DiceConcurrentCommands dice_concurrent_commands = 24;

    // Stacktrace from the fail_no_stacktrace() call.
    StarlarkFailNoStacktrace starlark_fail_no_stacktrace = 25;

    // Emitted when the user requests that concurrent commands with different
    // states should be exited immediately
    ExitWhenDifferentState exit_when_different_state = 26;

    // Snapshot of current debug adapter state. Only sent when a debugger is
    // attached.
    DebugAdapterSnapshot debug_adapter_snapshot = 27;
  }

  reserved 12; // Log
}

message DebugAdapterStoppedEval {
  string description = 1;
  string stopped_at = 2;
}

message DebugAdapterCommandSnapshot {
  repeated DebugAdapterStoppedEval stopped_evals = 1;
}

// The DebugAdapterSnapshot is sent to all commands when a debugger is attached
// to buck, it contains imformation about the currently paused threads.
message DebugAdapterSnapshot {
  // The handle for the command receiving this snapshot, it can be used to
  // distinguish which of the per-handle snapshots is from this command and
  // which are from others.
  uint32 this_handle = 1;
  map<uint32, DebugAdapterCommandSnapshot> current_handles = 2;
}

message DiceStateSnapshot {
  map<string, DiceKeyState> key_states = 1;
}

message DiceKeyState {
  uint32 started = 1;
  uint32 finished = 2;
}

message RemoteExecutionSessionCreated {
  string session_id = 1;
  string experiment_name = 2;
}

message Location {
  string file = 1;
  uint32 line = 2;
  uint32 column = 3;
}

// An error that needs to be reported. This may be a panic, or a soft error.
message StructuredError {
  // A resolved symbol, obtained through symbolicating the stack trace.
  message Symbol {
    // The name of the symbol (i.e. the function).
    string name = 1;
    // The address of the symbol.
    string address = 2;
    // The file containing the symbol.
    string file = 3;
    // The line where the symbol is defined.
    uint32 line = 4;
    // The column where the symbol is defined.
    uint32 column = 5;
  }

  // A stack frame, representing a single frame of execution in a backtrace.
  message StackFrame {
    // The instruction pointer at this frame. For terminal frames, this is the
    // faulting IP.
    string instruction_pointer = 1;
    // The address of the symbol associated with this stack frame.
    string symbol_address = 2;
    // The base address of the loaded module containing the given symbol
    // address, for use in symbolication.
    string module_base_address = 3;
    // The list of symbols known to resolve to the given symbol address, after
    // symbolication. A symbol address may resolve to multiple symbols if
    // inlining or COMDAT folding occurred. A symbol address may also resolve
    // to zero symbols if no symbols were found while symbolicating.
    repeated Symbol symbols = 4;
  }

  // The payload of the error (the argument to panic! if we are reporting a
  // panic).
  string payload = 1;
  // The code location this occurred at.
  Location location = 2;
  // Metadata associated with this daemon.
  map<string, string> metadata = 3;
  // A backtrace, we set this for panics.
  repeated StackFrame backtrace = 4;
  // StructuredError is used to propagate soft_errors, which can be hidden from
  // users. If true, it won't get logged to console
  bool quiet = 5;
  // If this was a soft error, its category.
  optional string soft_error_category = 6;
}

// An event capturing the input, output, and context during the execution of an
// audit.
message MercurialInfo {
  // hg commit for repo
  string commit = 1;
  // hg diff for diff between current repo and mercurial hash as a pastry link
  string diff = 2;
}

message CriticalPathEntry {
  // A pretty-printed action name.
  string action_name = 1;
  // The wall time taken by this action.
  google.protobuf.Duration duration = 2;
  // The action key (valid only locally within this build), useful for analysis
  // that wants to identify actions on the critical path.
  ActionKey action_key = 3;
  ActionName action_name_fields = 4;
}

message CriticalPathEntry2 {
  message Analysis {
    oneof target {
      ConfiguredTargetLabel standard_target = 1;
    }
  }

  message ActionExecution {
    ActionName name = 1;

    oneof owner {
      ConfiguredTargetLabel target_label = 2;
      BxlFunctionKey bxl_key = 3;
      AnonTarget anon_target = 4;
    }
  }

  message Materialization {
    string path = 1;

    oneof owner {
      ConfiguredTargetLabel target_label = 2;
      BxlFunctionKey bxl_key = 3;
      AnonTarget anon_target = 4;
    }
  }

  message ComputeCriticalPath {}

  message Load {
    string package = 1;
  }

  optional uint64 span_id = 1;

  // The duration we used to compute the critical path. This will be one of the
  // durations below, but to ensure not every callsite has to know which one we
  // chose, we expose it here.
  google.protobuf.Duration duration = 2;

  // The subset of the duration for this entry whose runtime is controlled by
  // the user.
  google.protobuf.Duration user_duration = 3;

  // The total duration for this entry, which might include runtime not
  // controlled by the user (e.g. Buck querying caches, etc.)
  google.protobuf.Duration total_duration = 4;

  // The maximum improvement possible for this node. This should be compared to
  // `duration` (since it can't exceed it).
  optional google.protobuf.Duration potential_improvement_duration = 5;

  oneof entry {
    Analysis analysis = 100;
    ActionExecution action_execution = 101;
    Materialization materialization = 102;
    ComputeCriticalPath compute_critical_path = 103;
    Load load = 104;
  }
}

// Sent once per build.
message BuildGraphExecutionInfo {
  // The actions that made up the critical path, in chronological order.
  repeated CriticalPathEntry critical_path = 1;
  // Metadata associated with this build. Values in this map have no particular
  // semantics and are useful for logging and telemetry only.
  map<string, string> metadata = 2;
  // Number of nodes in the action graph.
  uint64 num_nodes = 3;
  // Number of directed edges in the action graph (directed acyclic graph).
  uint64 num_edges = 4;
  // The actions that made up the critical path, in chronological order, in a
  // new format. We will have either that, or critical_path;
  repeated CriticalPathEntry2 critical_path2 = 5;
  // Whether the aggregation is done using total duration or not.
  bool uses_total_duration = 6;
  // The backend that was use to produce the critical path.
  optional string backend_name = 7;
}

// An event capturing information from the test discovery phase.
// Test discovery includes sending a summary of the current testing session.
// For a given target, we also report when we discover its tests.
message TestDiscovery {
  oneof data {
    TestSessionInfo session = 1;
    TestSuite tests = 2;
  }
}

// Event indicating buck2 rage has been invoked.
message RageInvoked {
  map<string, string> metadata = 1;
  // the trace id of the command that rage was invoked upon.
  optional string recent_command_trace_id = 2;
}

// Result of invoking buck2 rage
message RageResult {
  reserved 1 to 8;
  map<string, string> string_data = 9;
  map<string, uint64> int_data = 10;
  google.protobuf.Timestamp timestamp = 11;
  google.protobuf.Duration command_duration = 12;
}

// A snapshot of current system state, with useful info.
message Snapshot {
  // Resident set size in bytes of the buck2 daemon.
  // Does not include subprocesses (e.g. local actions).
  optional uint64 buck2_rss = 11;
  // Maximum resident set size in bytes of the buck2 daemon.
  // Does not include subprocesses (e.g. local actions).
  uint64 buck2_max_rss = 1;
  // User CPU time of buck2 daemon, not including subprocesses.
  uint64 buck2_user_cpu_us = 2;
  // System CPU time of buck2 daemon, not including subprocesses.
  uint64 buck2_system_cpu_us = 3;
  // Queue size of the blocking executor.
  uint64 blocking_executor_io_queue_size = 4;

  uint64 re_download_bytes = 5;
  uint64 re_upload_bytes = 6;
  uint32 re_uploads_started = 1011;
  uint32 re_uploads_finished_successfully = 1012;
  uint32 re_uploads_finished_with_error = 1013;
  uint32 re_downloads_started = 1021;
  uint32 re_downloads_finished_successfully = 1022;
  uint32 re_downloads_finished_with_error = 1023;
  uint32 re_action_cache_started = 1031;
  uint32 re_action_cache_finished_successfully = 1032;
  uint32 re_action_cache_finished_with_error = 1033;
  uint32 re_executes_started = 1041;
  uint32 re_executes_finished_successfully = 1042;
  uint32 re_executes_finished_with_error = 1043;
  uint32 re_materializes_started = 1051;
  uint32 re_materializes_finished_successfully = 1052;
  uint32 re_materializes_finished_with_error = 1053;
  uint32 re_write_action_results_started = 1061;
  uint32 re_write_action_results_finished_successfully = 1062;
  uint32 re_write_action_results_finished_with_error = 1063;
  uint32 re_get_digest_expirations_started = 1064;
  uint32 re_get_digest_expirations_finished_successfully = 1065;
  uint32 re_get_digest_expirations_finished_with_error = 1066;

  // I/O operations in progress.
  uint32 io_in_flight_copy = 1101;
  uint32 io_in_flight_symlink = 1102;
  uint32 io_in_flight_hardlink = 1103;
  uint32 io_in_flight_mk_dir = 1104;
  uint32 io_in_flight_read_dir = 1105;
  uint32 io_in_flight_read_dir_eden = 1106;
  uint32 io_in_flight_rm_dir = 1107;
  uint32 io_in_flight_rm_dir_all = 1108;
  uint32 io_in_flight_stat = 1109;
  uint32 io_in_flight_stat_eden = 1110;
  uint32 io_in_flight_chmod = 1111;
  uint32 io_in_flight_read_link = 1112;
  uint32 io_in_flight_remove = 1113;
  uint32 io_in_flight_rename = 1114;
  uint32 io_in_flight_read = 1115;
  uint32 io_in_flight_write = 1116;
  uint32 io_in_flight_canonicalize = 1117;
  uint32 io_in_flight_eden_settle = 1118;

  // Time passed since buck2 daemon was started
  uint64 daemon_uptime_s = 7;

  // https://jemalloc.net/jemalloc.3.html
  // (stats.active) Total number of bytes in active pages
  // allocated by the application, is greater or equal to stats.allocated.
  optional uint64 malloc_bytes_active = 8;
  // (stats.allocated) Total number of bytes allocated by the application
  optional uint64 malloc_bytes_allocated = 9;

  uint64 dice_key_count = 101;
  // the number of keys actively present in the per transaction cache
  uint64 dice_currently_active_key_count = 102;
  uint32 dice_active_transaction_count = 103;

  uint64 deferred_materializer_queue_size = 104;

  // Sink write statistics; counts of sink statistics taken at this snapshot.
  // Cumulative count of messages that were successfully emitted.
  optional uint64 sink_successes = 105;
  // Cumulative count of messages that failed to be emitted.
  optional uint64 sink_failures = 106;
  // Current number of messages queued up to be submitted.
  optional uint64 sink_buffer_depth = 107;
  // Cumulative count of messages that were dropped (i.e. not even processed).
  optional uint64 sink_dropped = 108;

  // Network statistics for "interesting" network interfaces.
  map<string, NetworkInterfaceStats> network_interface_stats = 109;

  // Client side metrics.

  // Delay between time snapshot is created and time it is received
  // by the client.
  optional int64 this_event_client_delay_ms = 2001;
  // Client average user + system CPU time since last snapshot processed.
  optional uint32 client_cpu_percents = 2002;
}

enum TestStatus {
  // sibling enum scoping in grpc requires file-wide unique name
  NOT_SET_TEST_STATUS = 0;
  PASS = 1;
  FAIL = 2;
  SKIP = 3;
  OMITTED = 4;
  FATAL = 5;
  TIMEOUT = 6;
  UNKNOWN = 7;
  RERUN = 8;
  LISTING_SUCCESS = 9;
  LISTING_FAILED = 10;
}

message TestResult {
  message OptionalMsg {
    string msg = 1; // Required
  }

  string name = 1; // Required
  TestStatus status = 2; // Required
  OptionalMsg msg = 5; // Optional
  google.protobuf.Duration duration = 7; // Optional
  string details = 8; // Required
  ConfiguredTargetLabel target_label = 9;
}

// At the beginning of discovery, the test orchestrator will advertise
// some information about the session
message TestSessionInfo {
  // Usually this contains a test link, like in Tpx
  string info = 2;
}

// We report all of the tests for a particular target simultaneously
message TestSuite {
  // When the tests for a target are discovered,
  // we are also given the suite name for the tests.
  string suite_name = 1;
  repeated string test_names = 2;
  ConfiguredTargetLabel target_label = 3;
}

// An event that marks the beginning of a command.
message CommandStart {
  // Metadata associated with this build. Values in this map have no particular
  // semantics and are useful for logging and telemetry only.
  //
  // The metadata cannot contain information from buckconfig or dice state
  map<string, string> metadata = 1;
  oneof data {
    BuildCommandStart build = 20;
    TargetsCommandStart targets = 21;
    QueryCommandStart query = 22;
    CQueryCommandStart cquery = 23;
    TestCommandStart test = 24;
    AuditCommandStart audit = 25;
    DocsCommandStart docs = 26;
    CleanCommandStart clean = 27;
    AqueryCommandStart aquery = 28;
    InstallCommandStart install = 29;
    MaterializeCommandStart materialize = 30;
    ProfileCommandStart profile = 31;
    BxlCommandStart bxl = 32;
    LspCommandStart lsp = 33;
    FileStatusCommandStart file_status = 34;
    StarlarkCommandStart starlark = 35;
    SubscriptionCommandStart subscribe = 36;
    TraceIoCommandStart trace = 37;
    ConfiguredTargetsCommandStart ctargets = 38;
    StarlarkDebugAttachCommandStart starlark_debug_attach = 39;
  }
}

// An event that marks that the command has start execution and synced it's
// state. The period of time between CommandStart and CommandBegin is the time
// spent synchronizing changes and waiting for concurrent commands to finish.
message CommandCriticalStart {
  reserved 2;

  // Metadata associated with this build. Values in this map have no particular
  // semantics and are useful for logging and telemetry only.
  //
  // The metadata will contain information from buckconfigs
  map<string, string> metadata = 1;

  // DICE transaction version number.
  string dice_version = 3;
}

message AuditCommandStart {
  // TODO(swgillespie) fill this with useful fields
}

message StarlarkCommandStart {}

message BuildCommandStart {
  // TODO(swgillespie) fill this with useful fields
}

message BxlCommandStart {
  // The full bxl label that was run, excluding the arguments to the bxl
  string bxl_label = 1;
}

message LspCommandStart {}

message StarlarkDebugAttachCommandStart {}

message TargetsCommandStart {
  // TODO(swgillespie) fill this with useful fields
}

message ConfiguredTargetsCommandStart {}

message QueryCommandStart {
  // TODO(swgillespie) fill this with useful fields
}

message AqueryCommandStart {
  // TODO(swgillespie) fill this with useful fields
}

message CQueryCommandStart {
  string query = 1;
  string query_args = 2;
  string target_universe = 3;
  // TODO(swgillespie) fill this with useful fields
}

message TestCommandStart {
  // TODO(swgillespie) fill this with useful fields
}

message DocsCommandStart {
  // TODO(nmj) fill this with useful fields
}

message CleanCommandStart {
  // TODO fill this with useful fields
}

message InstallCommandStart {
  // TODO fill this with useful fields
}

message MaterializeCommandStart {
  // TODO fill this with useful fields
}

message FileStatusCommandStart {}

message ProfileCommandStart {}

message CommandEnd {
  // Metadata associated with this build. Values in this map have no particular
  // semantics and are useful for logging and telemetry only.
  //
  // The metadata cannot contain information from buckconfig or dice state
  map<string, string> metadata = 1;
  oneof data {
    BuildCommandEnd build = 20;
    TargetsCommandEnd targets = 21;
    QueryCommandEnd query = 22;
    CQueryCommandEnd cquery = 23;
    TestCommandEnd test = 24;
    AuditCommandEnd audit = 25;
    DocsCommandEnd docs = 26;
    CleanCommandEnd clean = 27;
    AqueryCommandEnd aquery = 28;
    InstallCommandEnd install = 29;
    MaterializeCommandEnd materialize = 30;
    ProfileCommandEnd profile = 31;
    BxlCommandEnd bxl = 32;
    LspCommandEnd lsp = 33;
    FileStatusCommandEnd file_status = 34;
    StarlarkCommandEnd starlark = 35;
    SubscriptionCommandEnd subscribe = 36;
    TraceIoCommandEnd trace = 37;
    ConfiguredTargetsCommandEnd ctargets = 38;
    StarlarkDebugAttachCommandEnd starlark_debug_attach = 39;
  }

  bool is_success = 2;
  repeated string error_messages = 3;
}

// Marks the exit of the `CommandBeginCritical` event, such that the command has
// left the critical section.
message CommandCriticalEnd {
  // Metadata associated with this command. Values in this map have no
  // particular semantics and are useful for logging and telemetry only.
  //
  // The metadata will contain information from buckconfigs
  map<string, string> metadata = 1;
}

message AuditCommandEnd {
  // output status
  uint64 status = 1;
  // arguments to command
  string args = 2;
  // execution dir
  string dir = 3;
}

message StarlarkCommandEnd {
  // output status
  uint64 status = 1;
  // arguments to command
  string args = 2;
  // execution dir
  string dir = 3;
}

message BuildCommandEnd {
  reserved 2;

  repeated TargetPattern unresolved_target_patterns = 1;
}

message BxlCommandEnd {
  // The full bxl label that was run, excluding the arguments to the bxl
  string bxl_label = 1;
}

message LspCommandEnd {}

message StarlarkDebugAttachCommandEnd {}

message TargetsCommandEnd {
  // TODO(swgillespie) fill this with useful fields
}

message ConfiguredTargetsCommandEnd {}

message QueryCommandEnd {
  // TODO(swgillespie) fill this with useful fields
}

message CQueryCommandEnd {
  // TODO(swgillespie) fill this with useful fields
}

message AqueryCommandEnd {
  // TODO(swgillespie) fill this with useful fields
}

message TestCommandEnd {
  repeated TargetPattern unresolved_target_patterns = 1;
}

message DocsCommandEnd {
  // TODO(nmj) fill this with useful fields
}

message CleanCommandEnd {
  optional CleanStaleStats clean_stale_stats = 1;
}

message CleanStaleStats {
  uint64 stale_artifact_count = 1;
  uint64 stale_bytes = 2;
  uint64 retained_artifact_count = 3;
  uint64 retained_bytes = 4;
  uint64 untracked_artifact_count = 5;
  uint64 untracked_bytes = 6;
  uint64 cleaned_path_count = 7;
  uint64 cleaned_artifact_count = 8;
  uint64 cleaned_bytes = 9;
}

message InstallCommandEnd {
  repeated TargetPattern unresolved_target_patterns = 1;
}

message MaterializeCommandEnd {
  // TODO fill this with useful fields
}

message FileStatusCommandEnd {}

message ProfileCommandEnd {}

message LoadPackageStart {
  string path = 1;
}

message LoadPackageEnd {
  reserved 2;
  string path = 1;
  optional ErrorReport error = 3;
}

message LoadBuildFileStart {
  string module_id = 1;
  string cell = 2;
}

message LoadBuildFileEnd {
  string module_id = 1;
  string cell = 2;
  optional string error = 3;
}

message SharedTaskStart {
  string owner_trace_id = 1;
}

message SharedTaskEnd {}

message FakeStart {
  string caramba = 1;
}

message FakeEnd {}

// A unique key identifying a particular action.
message ActionKey {
  // A deferred ID associated with this action. Opaque to consumers.
  bytes id = 1;

  // The configured target label that this action contributes to.
  oneof owner {
    ConfiguredTargetLabel target_label = 2;
    BxlFunctionKey bxl_key = 4;
    ConfiguredTargetLabel test_target_label = 5;
    AnonTarget anon_target = 6;
  }

  // The full deferred key associated with this action. Opaque to consumers.
  string key = 3;
}

enum ActionKind {
  NOT_SET = 0;
  COPY = 1;
  DOWNLOAD_FILE = 2;
  RUN = 3;
  SYMLINKED_DIR = 4;
  WRITE = 5;
  WRITE_MACROS_TO_FILE = 6;
  CAS_ARTIFACT = 7;
}

// The kinds of ways an action can be executed by buck2.
enum ActionExecutionKind {
  ACTION_EXECUTION_KIND_NOT_SET = 0;
  // This action was executed locally.
  ACTION_EXECUTION_KIND_LOCAL = 1;
  // This action was executed via a remote execution service.
  ACTION_EXECUTION_KIND_REMOTE = 2;
  // This action was served via a remote execution service's action cache.
  ACTION_EXECUTION_KIND_ACTION_CACHE = 3;
  // This action was served inline within buck2 due to its simplicity (e.g.
  // write, symlink, etc.
  ACTION_EXECUTION_KIND_SIMPLE = 4;
  // This action was skipped entirely because Buck2 determined it was redundant
  // (e.g. dep files hit).
  ACTION_EXECUTION_KIND_SKIPPED = 5;
  // This action was logically executed, but didn't perform all the work.
  ACTION_EXECUTION_KIND_DEFERRED = 6;
}

// A name for a particular action, suitable for offline analytics and user
// display. ActionNames are unique within the execution of a particular target.
message ActionName {
  // The category of this action. Categories are families of actions that are
  // similar but operate on different inputs, such as invocations of a C++
  // compiler (whose category would be `cxx_compile`).
  string category = 1;

  // The identifier of this action. Combined with the category, the identifier
  // describes the action umbiguously within the context of a single target.
  //
  // If only one action is expected in a single category, this field may be
  // empty.
  string identifier = 2;
}

// The beginning of execution for a particular action.
message ActionExecutionStart {
  reserved 2;

  // A unique key identifying this action within the build.
  ActionKey key = 1;
  // The kind of this action.
  ActionKind kind = 3;
  // A pair of category and identifier describing this action.
  ActionName name = 4;
}

message OmittedLocalCommand {
  string action_digest = 1;
}

message CommandExecutionDetails {
  reserved 6;

  // The exit code of the command.
  optional uint32 exit_code = 1;
  // Same as exit_code but allowing negative values
  optional sint32 signed_exit_code = 4;
  // The stdout of the command. This may be omitted for successful commands.
  string stdout = 2;
  // The stderr of the command.
  string stderr = 3;

  oneof command {
    // The command, if it was local.
    LocalCommand local_command = 7;
    // The command, if it was remote.
    RemoteCommand remote_command = 8;
    // The command, if it was local and omitted from this log record for
    // brevity.
    OmittedLocalCommand omitted_local_command = 9;
  }

  // We should probably get the some more fields from CommandExecutionMetadata
  // in there.
  optional CommandExecutionStats execution_stats = 10;
}

message CommandOutputsMissing {
  // A description of what outputs are missing.
  string message = 2;
}

message CommandTimedOut {
  string message = 2;
}

// Serialization of CommandExecutionReport
message CommandExecution {
  CommandExecutionDetails details = 1;

  message Success {}

  message Failure {}

  message Timeout {
    google.protobuf.Duration duration = 1;
  }

  message Error {
    string stage = 1;
    string error = 2;
  }

  // (Hybrid execution only) This executor released its claim in order to allow
  // another executor to proceed. We use this to cancel local tasks when racing
  // local & RE.
  message Cancelled {}

  reserved 6;

  // Serialization of CommandExecutionStatus.
  oneof status {
    Success success = 2;
    Failure failure = 3;
    Timeout timeout = 4;
    Error error = 5;
    Cancelled cancelled = 7;
  }
}

// NOTE: This is an empty message. When this is returned as an error, the
// relevant execution details are in the reports field.
message CommandExecutionError {}

message ActionOutput {
  string tiny_digest = 1;
}

message ActionExecutionEnd {
  reserved 2, 20;

  // A unique key identifying this action within the build.
  ActionKey key = 1;
  // The kind of this action.
  ActionKind kind = 4;
  // A pair of category and identifier describing this action.
  ActionName name = 5;
  // Whether or not this action failed. The default value of this field is
  // "false", indicating that an action was successful. This polarity was chosen
  // deliberately; our hypothesis is that a large majority of actions are
  // successful and, when a boolean is sent over the wire as its default value
  // (false), it is not serialized at all.
  bool failed = 6;
  // If this action failed, contains an object that represents the nature of the
  // error. Can be just a string, in which case it is `unknown`, or may be a
  // richer object depending on the error.
  oneof error {
    // An error message whose nature is unknown. This often comes from cases
    // where action execution fails for reasons other than the command failing.
    // This should not be preferred, and should be an error type of last resort.
    // TODO (torozco): Remove
    string unknown = 7;

    // Command executed successfully but did not produce the desired outputs.
    CommandOutputsMissing missing_outputs = 9;

    // TODO (torozco): Rename to command_failed.
    CommandExecutionError command_execution_error = 11;
  };
  // If not-empty, the stderr for the process. This may contain ANSI control
  // characters, so consumers should sanitize it before displaying it to users.
  // If it is empty, the stderr contents are available elsewhere, e.g. in an
  // error message for failed actions.
  // Whether, in the normal case, stderr should be printed for successful
  // actions. It *may* still be presented to users if they request it
  // specifically.
  bool always_print_stderr = 21;
  // The kind of execution used to service this action.
  // TODO (torozco): Remove the command variants? This should probably just be
  // "Command" if there was a command and then we should look at the command
  // reports to tell if it was RE or Local.
  ActionExecutionKind execution_kind = 22;
  /// How long this build waited for this action to complete. Omits queue time.
  google.protobuf.Duration wall_time = 23;
  // the total size of the outputs of this action.
  uint64 output_size = 24;
  // The commands executed by this action. These are in the order they were
  // attempted. If a command was executed, the one that should be shown to the
  // user will always be last.
  repeated CommandExecution commands = 25;
  // The outputs produced by this action
  repeated ActionOutput outputs = 26;

  // For commands, their local preference.
  bool prefers_local = 27;
  bool requires_local = 28;
  bool allows_cache_upload = 29;
  bool did_cache_upload = 30;

  // Revision hash (version) for this action
  optional string buck2_revision = 31;
  // Time when the buck2 binary servicing this action was built.
  optional string buck2_build_time = 32;

  // Was this command eligible for full hybrid execution (i.e. no exclusions
  // from the command, hybrid is turned on).
  optional bool eligible_for_full_hybrid = 33;
}

// The beginning of materialization for the output of a target requested,
// inclusive of all dependent artifacts it might recursively request to
// materialize.
message MaterializeRequestedArtifactStart {
  BuildArtifact artifact = 1;
}

message MaterializeRequestedArtifactEnd {
  BuildArtifact artifact = 1;
}

message AnalysisProfile {
  uint64 starlark_allocated_bytes = 1;
  uint64 starlark_available_bytes = 2;
}

message AnalysisStart {
  oneof target {
    ConfiguredTargetLabel standard_target = 1;
    AnonTarget anon_target = 3;
  }
  string rule = 2;
}

message AnalysisEnd {
  oneof target {
    ConfiguredTargetLabel standard_target = 1;
    AnonTarget anon_target = 4;
  }
  string rule = 3;
  AnalysisProfile profile = 2;
}

message AnalysisStageStart {
  oneof stage {
    google.protobuf.Empty resolve_queries = 1;
    google.protobuf.Empty evaluate_rule = 2;
  }
}

message AnalysisStageEnd {}

message ExecutorStageStart {
  oneof stage {
    ReStage re = 20;
    LocalStage local = 21;
    CacheQuery cache_query = 22;
    CacheHit cache_hit = 23;
    PrepareAction prepare = 24;
  }
}

message PrepareAction {}

message CacheQuery {
  string action_digest = 1;
}

message CacheHit {
  string action_digest = 1;
}

message ReStage {
  reserved 1, 2, 4;

  oneof stage {
    ReUpload upload = 3;
    ReExecute execute = 5;
    ReDownload download = 6;
    ReQueue queue = 7;
    ReWorkerDownload worker_download = 8;
    ReWorkerUpload worker_upload = 9;
    ReUnknown unknown = 10;
  }
}

message ReUpload {}

message ReExecute {
  string action_digest = 1;
  RePlatform platform = 2;
  optional string action_key = 3;
}

message RePlatform {
  message Property {
    string name = 1;
    string value = 2;
  }
  repeated Property properties = 1;
}

message ReDownload {}

message ReQueue {
  string action_digest = 1;
}

message ReWorkerDownload {
  string action_digest = 1;
}

message ReWorkerUpload {
  string action_digest = 1;
}

message ReUnknown {
  string action_digest = 1;
}

message LocalStage {
  oneof stage {
    LocalQueued queued = 1;
    LocalExecute execute = 2;
    LocalMaterializeInputs materialize_inputs = 3;
    LocalPrepareOutputDirs prepare_outputs = 4;
  }
}

message LocalQueued {}

message LocalExecute {
  LocalCommand command = 1;
}

message LocalMaterializeInputs {}

message LocalPrepareOutputDirs {}

message ExecutorStageEnd {}

// For most tests, tpx calls the test orchestrator's `execute` method.
// The `execute` method calls a test binary.
// We instrument the span associated specifically with the execution of this
// binary, ignoring time spent resolving deps, etc.
//
// `Execute` is called in two different ways:
// - Discovery: `tpx` is trying to figure out what tests to run for a suite.
// - SuiteRun: `tpx` wants to run one or more tests for a suite.
// These different ways are tracked using the span events below.

message TestDiscoveryStart {
  // Trying to find the test suite(s) associated with this binary.
  string suite_name = 1;
}

message TestDiscoveryEnd {}

message TestRunStart {
  TestSuite suite = 1;
}

message TestRunEnd {}

message FileWatcherStart {
  FileWatcherProvider provider = 1;
}

enum FileWatcherProvider {
  WATCHMAN = 0;
  // The Rust `notify` crate
  RUST_NOTIFY = 1;
}

enum FileWatcherEventType {
  CREATE = 0;
  MODIFY = 1;
  DELETE = 2;
}

enum FileWatcherKind {
  FILE = 0;
  DIRECTORY = 1;
  SYMLINK = 2;
}

message FileWatcherEvent {
  FileWatcherEventType event = 1;
  FileWatcherKind kind = 2;
  string path = 3;
}

// Stats for a file watching (e.g. Watchman) update. We ignore events that are
// outside of the cells we care about, which is why events_total and
// events_processed might differ.
message FileWatcherStats {
  reserved 5;

  bool fresh_instance = 1;
  uint64 events_total = 2;
  uint64 events_processed = 3;
  optional string branched_from_revision = 4;
  repeated FileWatcherEvent events = 6;
  // Present if the results are incomplete
  optional string incomplete_events_reason = 7;
  // Present if it is using Watchman
  optional string watchman_version = 8;
}

message FileWatcherEnd {
  FileWatcherStats stats = 1;
}

message MatchDepFilesStart {}

message MatchDepFilesEnd {}

// Returned when a Span is dropped before terminating.
message SpanCancelled {}

// A configured target label, which is a target label plus a configuration.
message ConfiguredTargetLabel {
  TargetLabel label = 1;
  Configuration configuration = 2;
  // Only present on toolchain_deps
  optional Configuration execution_configuration = 3;
}

message AnonTarget {
  TargetLabel name = 1;
  Configuration execution_configuration = 2;
  string hash = 3;
}

// A bxl function key, which is a bxl function and its args
message BxlFunctionKey {
  reserved 2;
  BxlFunctionLabel label = 1;
}

// A bxl function label, which is its defining file and the function name
message BxlFunctionLabel {
  string bxl_path = 1;
  string name = 2;
}

// A configuration, identified by its full name.
message Configuration {
  string full_name = 2;
}

// A target label, consisting of a package and a name.
message TargetLabel {
  string package = 1;
  string name = 2;
}

message BuildArtifact {
  ActionKey key = 1;
  string path = 2;
}

// A target pattern, representing a set of targets. See
// `<https://buck.build/concept/build_target_pattern.html#content>` for Buck's
// documentation on target patterns.
message TargetPattern {
  string value = 1;
}

/// A message that should be printed to the user, generally via stderr
///
/// The formatting used is up to the user, and may have things like ANSI
/// control characters removed.
///
/// Generally, one should rely on properly typed events, rather than raw
/// console events if additional formatting is required.
message ConsoleMessage {
  string message = 1;
}

/// A representation of a command that we executed locally.
message LocalCommand {
  message EnvironmentEntry {
    // The environment key.
    string key = 1;
    // The environment value.
    string value = 2;
  }

  repeated string argv = 1;
  repeated EnvironmentEntry env = 2;
  string action_digest = 3;
}

// A representation of a command we executed remotely.
message RemoteCommand {
  string action_digest = 1;
  bool cache_hit = 2;

  /// How long this build waited in queue.
  google.protobuf.Duration queue_time = 3;
}

// A representation of an invocation
message Invocation {
  repeated string command_line_args = 1;
  string working_dir = 2;
  optional string trace_id = 3;
}

message RecordEvent {
  oneof data {
    InvocationRecord invocation_record = 1;
  }
}

// An arbitrary tag on the command. Usually used to mark A/B experiments
message TagEvent {
  repeated string tags = 1;
}

// Unambiguous provider patterns that this command is requesting be brought
// up-to-date. These patterns are not exactly the same as the patterns
// directly provided to the buck2 command-line; rather, these patterns have
// been disambiguated using the client's working directory and cell
// configuration.
message ResolvedTargetPatterns {
  repeated TargetPattern target_patterns = 1;
}

message TypedMetadata {
  map<string, int64> ints = 1;
  map<string, string> strings = 2;
}

message InvocationRecord {
  reserved 22, 36;

  // Optional - present if ever sent to client.
  CommandStart command_start = 1;
  // Optional - present if ever sent to client.
  // Will be missing on a cancelled build.
  CommandEnd command_end = 2;
  // Optional - present if event-log had RemoteExecutionSessionCreated.
  string re_session_id = 3;
  repeated string cli_args = 4;
  // Optional - present if CommandEnd sent to client.
  google.protobuf.Duration command_duration = 5;
  // Required. The walltime as measured by the client.
  google.protobuf.Duration client_walltime = 6;
  // Optional - present if BuildGraphExecutionInfo sent to client.
  google.protobuf.Duration critical_path_duration = 7;
  // Optional - any contents are copied directly to scuba buck2_builds.
  TypedMetadata metadata = 8;
  // Tags for this command
  repeated string tags = 9;
  // Count of actions that were executed locally
  uint64 run_local_count = 10;
  // Count of actions that were executed remotely
  uint64 run_remote_count = 11;
  // Count of actions that downloaded action cache
  uint64 run_action_cache_count = 12;
  // Count of actions that were skipped. Actions are usually skipped due to a
  // dep-files hit.
  uint64 run_skipped_count = 13;
  // Optional - Count of actions that used fallback if fallback was used
  optional uint64 run_fallback_count = 14;
  // Optional - the first snapshot sent.
  Snapshot first_snapshot = 20;
  // Optional - the last snapshot sent.
  Snapshot last_snapshot = 21;
  // If any, the name of the RE experiment config that was used by the RE
  // client in this build.
  string re_experiment_name = 23;
  // Minimum build count among the targets that were involved in the command
  uint64 min_build_count_since_rebase = 24;
  // The number of cache uploads done by this build.
  uint64 cache_upload_count = 25;
  // The number of cache uploads attempted by this build.
  uint64 cache_upload_attempt_count = 26;
  // Optional - present if ever sent to client.
  CommandCriticalStart command_critical_start = 27;
  // Optional - present if ever sent to client.
  // Will be missing on a cancelled build.
  CommandCriticalEnd command_critical_end = 28;
  // The target pattern for the command, fully resolved
  ResolvedTargetPatterns resolved_target_patterns = 29;
  // Whether repository is Eden filesystem / mount (EdenFS)
  string filesystem = 30;
  // Test session
  optional string test_info = 31;
  // Whether there were any full-hybrid-eligible actions.
  optional bool eligible_for_full_hybrid = 32;
  // Max delay between time a server generates an event and time the client
  // observes it.
  optional uint64 max_event_client_delay_ms = 33;
  // Stateful max for malloc_bytes_active over the lifetime of invocation.
  optional uint64 max_malloc_bytes_active = 34;
  // Stateful max for malloc_bytes_allocated over the lifetime of invocation.
  optional uint64 max_malloc_bytes_allocated = 35;
  optional uint64 run_command_failure_count = 37;
  optional uint64 event_count = 38;
  // Time elapsed from a build's start until the first action begins execution.
  optional uint64 time_to_first_action_execution_ms = 39;
  // Total size, in bytes, of all materialized outputs.
  optional uint64 materialization_output_size = 40;
  // Time elapsed from a build's start until the command starts.
  optional uint64 time_to_command_start_ms = 41;
  // Time elapsed from a build's start until command enters critical section.
  optional uint64 time_to_command_critical_section_ms = 42;
  // Time elapsed from build start until analysis of first action.
  optional uint64 time_to_first_analysis_ms = 43;
  // Time elapsed from build start until first build file is loaded.
  optional uint64 time_to_load_first_build_file_ms = 44;
  // Time elapsed from a build's start until first command begins execution.
  optional uint64 time_to_first_command_execution_start_ms = 45;
  // Total system memory in bytes
  optional uint64 system_total_memory_bytes = 46;
  // Information of file changes provided by file watcher
  FileWatcherStats file_watcher_stats = 47;
  // Time elapsed from a build's start until the last action ends execution.
  optional uint64 time_to_last_action_execution_end_ms = 48;
  // Isolation directory.
  optional string isolation_dir = 49;
  // Number of materializer entries loaded from db on daemon start.
  optional uint64 initial_materializer_entries_from_sqlite = 50;
  // Sink write statistics for the command
  optional uint64 sink_success_count = 51;
  optional uint64 sink_failure_count = 52;
  optional uint64 sink_dropped_count = 53;
  optional uint64 sink_max_buffer_depth = 54;
  // Version number of watchman
  optional string watchman_version = 55;
  optional string command_name = 56;
  // Any soft errors we hit during this invocation.
  repeated string soft_error_categories = 57;
  // Version number of EdenFS if mount is EdenFS
  optional string eden_version = 58;
  // Duration of when the concurrent command is blocking
  google.protobuf.Duration concurrent_command_blocking_duration = 59;
  // How many analyses were executed
  optional uint64 analysis_count = 60;
  // Total concurrent commands.
  optional uint32 total_concurrent_commands = 61;
  optional bool exit_when_different_state = 62;
}

message CacheUploadStart {
  // A unique key identifying this action within the build.
  ActionKey key = 1;
  // A pair of category and identifier describing this action.
  ActionName name = 2;
  // The digest of the action being uploaded.
  string action_digest = 3;
}

message CacheUploadEnd {
  // A unique key identifying this action within the build.
  ActionKey key = 1;
  // A pair of category and identifier describing this action.
  ActionName name = 2;
  // The digest of the action being uploaded.
  string action_digest = 3;
  // Whether the upload was actually completed. This may be false if it wasn't
  // representable in RE, or if an error occurred.
  bool success = 4;
  // An error, if any occurred.
  string error = 5;
  // The files we uploaded.
  repeated string file_digests = 6;
  // The directories we uploaded.
  repeated string tree_digests = 7;
  optional uint64 output_bytes = 8;
  // If a RE error occurred, the error code.
  optional string re_error_code = 9;
}

message CreateOutputSymlinksStart {};

message CreateOutputSymlinksEnd {
  uint64 created = 1;
};

message InstallEventInfoStart {
  string artifact_name = 1;
  string file_path = 2;
};

message InstallEventInfoEnd {};

message DiceStateUpdateStart {}

message DiceStateUpdateEnd {}

message MaterializationStart {
  // The digest of the action being materialized.
  optional string action_digest = 1;
};

enum MaterializationMethod {
  MATERIALIZATION_METHOD_CAS_DOWNLOAD = 0;
  MATERIALIZATION_METHOD_LOCAL_COPY = 1;
  MATERIALIZATION_METHOD_HTTP_DOWNLOAD = 2;
  MATERIALIZATION_METHOD_WRITE = 3;
}

message MaterializationEnd {
  uint64 file_count = 1;
  uint64 total_bytes = 2;
  string path = 3;

  // The digest of the action being materialized.
  optional string action_digest = 4;

  // Whether the materialization was actually completed. This may be false if it
  // wasn't in RE, or if an error occurred.
  bool success = 5;
  // An error, if any occurred.
  optional string error = 6;

  // The type of entry that was materialized
  optional MaterializationMethod method = 7;
};

message ExclusiveCommandWaitStart {
  optional string command_name = 1;
}

message ExclusiveCommandWaitEnd {}

message DiceCriticalSectionStart {}

message DiceCriticalSectionEnd {}

message DiceSynchronizeSectionStart {}

message DiceSynchronizeSectionEnd {}

message ExitWhenDifferentState {}

message BxlExecutionStart {
  string name = 1;
}

message BxlExecutionEnd {}

message BxlDiceInvocationStart {}

message BxlDiceInvocationEnd {}

message DiceBlockConcurrentCommandStart {
  string current_active_trace_id = 1;
  string cmd_args = 2;
}

message DiceBlockConcurrentCommandEnd {
  string ending_active_trace_id = 1;
}

message DiceCleanupStart {
  uint64 epoch = 1;
}

message DiceCleanupEnd {}

message DiceEqualityCheck {
  bool is_equal = 1;
}

message NoActiveDiceState {}

enum ErrorCategory {
  USER = 0;
  INFRA = 1;
}

enum ErrorCause {
  INVALID_PACKAGE = 0;
  DAEMON_IS_BUSY = 1;
  // Add causes here as needed
}

message ErrorReport {
  optional ErrorCategory category = 1;
  optional ErrorCause cause = 2;
  string error_message = 3;
}

message MaterializerStateInfo {
  // Number of entries loaded from sqlite
  uint64 num_entries_from_sqlite = 1;
}

message IoProviderInfo {
  optional string eden_version = 1;
}

message DiceConcurrentCommands {
  uint32 total_concurrent_commands = 1;
}

message StarlarkFailNoStacktrace {
  string trace = 1;
}

message NoopEvent {}

message DaemonShutdown {
  reserved 3;
  string reason = 1;
  repeated string callers = 4;
}

message ConsolePreferences {
  uint64 max_lines = 1;
}

message SubscriptionCommandStart {}

message SubscriptionCommandEnd {}

message DeferredPreparationStageStart {
  oneof stage {
    MaterializedArtifacts materialized_artifacts = 1;
  }
}

message MaterializedArtifacts {}

message DeferredPreparationStageEnd {}

message DynamicLambdaStart {
  // The configured target label that this action contributes to.
  oneof owner {
    ConfiguredTargetLabel target_label = 1;
    BxlFunctionKey bxl_key = 2;
    AnonTarget anon_target = 3;
  }
}

message DeferredEvaluationEnd {}

// Wraps the RE upload stage of execution to report useful data on network
// traffic.
// Eventually all the executor stage span definitions should be moved to
// dedicated spans.
message ReUploadStart {}

message ReUploadEnd {
  optional uint64 digests_uploaded = 1;
  optional uint64 bytes_uploaded = 2;
}

message ConnectToInstallerStart {
  uint32 tcp_port = 1;
}

message ConnectToInstallerEnd {}

message CommandExecutionStats {
  optional uint64 cpu_instructions_user = 1;
  optional uint64 cpu_instructions_kernel = 2;
}

// Notify the client that we've encountered an internal error. This is normally
// indicative of an irrecoverable error that the user is not responsible for.
// Use sparingly.
message InternalError {}

message NetworkInterfaceStats {
  uint64 tx_bytes = 1;
  uint64 rx_bytes = 2;
}

message TraceIoCommandStart {}

message TraceIoCommandEnd {}
