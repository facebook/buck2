"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[20314],{2908:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"bxl/how_tos/basic_how_tos","title":"Basic How-Tos","description":"Writing a BXL","source":"@site/../docs/bxl/how_tos/basic_how_tos.md","sourceDirName":"bxl/how_tos","slug":"/bxl/how_tos/basic_how_tos","permalink":"/docs/bxl/how_tos/basic_how_tos","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"basic_how_tos","title":"Basic How-Tos"},"sidebar":"main","previous":{"title":"Tutorial","permalink":"/docs/bxl/tutorial"},"next":{"title":"How to Cache and Share Operations","permalink":"/docs/bxl/how_tos/how_to_cache_and_share_operations"}}');var s=t(74848),r=t(28453),a=t(78191);const o={id:"basic_how_tos",title:"Basic How-Tos"},c=void 0,l={},d=[{value:"Writing a BXL",id:"writing-a-bxl",level:2},{value:"Running a BXL",id:"running-a-bxl",level:2},{value:"Return information from BXL",id:"return-information-from-bxl",level:2},{value:"Passing in and using CLI args",id:"passing-in-and-using-cli-args",level:2},{value:"Running actions",id:"running-actions",level:2},{value:"Getting providers from an analysis",id:"getting-providers-from-an-analysis",level:2},{value:"Get a specific provider from an analysis",id:"get-a-specific-provider-from-an-analysis",level:2},{value:"Get a specific subtarget from an analysis",id:"get-a-specific-subtarget-from-an-analysis",level:2},{value:"Building a target/subtarget without blocking",id:"building-a-targetsubtarget-without-blocking",level:2},{value:"Accessing Unconfigured/Configured Target Node Attributes",id:"accessing-unconfiguredconfigured-target-node-attributes",level:2},{value:"Deprecated apis",id:"deprecated-apis",level:3},{value:"Example",id:"example",level:3},{value:"Inspecting a struct",id:"inspecting-a-struct",level:2},{value:"Set addition/subtraction on a <code>target_set</code>",id:"set-additionsubtraction-on-a-target_set",level:2},{value:"Initializing configured/unconfigured <code>target_set</code>",id:"initializing-configuredunconfigured-target_set",level:2},{value:"Profiling, Testing, and Debugging a BXL script",id:"profiling-testing-and-debugging-a-bxl-script",level:2},{value:"Getting the path of an artifact as a string",id:"getting-the-path-of-an-artifact-as-a-string",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"writing-a-bxl",children:"Writing a BXL"}),"\n",(0,s.jsxs)(n.p,{children:["To create a BXL, first, create a script somewhere in the repository ending in\n",(0,s.jsx)(n.code,{children:".bxl"}),". (Note that you can define a single bxl per file, or multiple BXLs per\nfile like in Starlark rules)."]}),"\n",(0,s.jsx)(n.p,{children:"In it, define a BXL function as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def _your_implementation(ctx):\n    # ...\n    pass\n\nyour_function_name = bxl_main(\n    impl = _your_implementation,\n    cli_args = {\n        # cli args that you want to receive from the command line\n        "bool_arg": cli_args.bool(),\n        # cli_args will be converted to snakecase. e.g. for this case, passed as --list-type, accessed via ctx.cli_args.list_type\n        "list-type": cli_args.list(cli_args.int()),\n        "optional": cli_args.option(cli_args.string()),\n        "target": cli_args.target_label(),\n    },\n)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This exposes ",(0,s.jsx)(n.code,{children:"your_function_name"})," as a function, with whatever arguments you\ndefined it, so that on the command line you can invoke:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"buck2 bxl //myscript.bxl:your_function_name -- --bool_arg true --list-type 1 --list-type 2 --target //foo:bar\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The implementation function takes a single context as parameter (see the\ndocumentation for ",(0,s.jsx)(n.a,{href:"../../../api/bxl/Context",children:(0,s.jsx)(n.code,{children:"bxl.Context"})}),"). Using it, you'll\nbe able to access functions that enable you to perform queries, analysis,\nbuilds, and even create your own actions within BXL to build artifacts as part\nof a BXL function."]}),"\n",(0,s.jsx)(n.h2,{id:"running-a-bxl",children:"Running a BXL"}),"\n",(0,s.jsx)(n.p,{children:"To run a BXL function, invoke the buck2 command:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"buck2 bxl <bxl function> -- <function args>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Where ",(0,s.jsx)(n.code,{children:"<bxl function>"})," is of the form ",(0,s.jsx)(n.code,{children:"<cell path to function>:<function name>"}),",\nand ",(0,s.jsx)(n.code,{children:"<function args>"})," are the arguments that the function accepts from the\ncommand line."]}),"\n",(0,s.jsx)(n.p,{children:"The documentation for a BXL function can be seen by running:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:" buck2 bxl <bxl function> -- --help\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Note that this is different from ",(0,s.jsx)(n.code,{children:"buck2 bxl --help"}),", which generates the help\nfor the buck2 command instead of the function."]}),"\n",(0,s.jsx)(n.h2,{id:"return-information-from-bxl",children:"Return information from BXL"}),"\n",(0,s.jsxs)(n.p,{children:["The primary method to return information from BXL is to either print them, or\nbuild some artifact (for details, see the\n",(0,s.jsx)(n.a,{href:"../../../api/bxl/OutputStream",children:(0,s.jsx)(n.code,{children:"bxl.OutputStream"})})," documentation, available as\npart of ",(0,s.jsx)(n.code,{children:"ctx.output"}),"). At high level, ",(0,s.jsx)(n.code,{children:"ctx.output.print(..)"})," prints results to\nstdout, and ",(0,s.jsx)(n.code,{children:"ctx.output.ensure(artifact)"})," marks artifacts as to be materialized\ninto buck-out by the end of the BXL function, returning an object that lets you\nprint the output path via ",(0,s.jsx)(n.code,{children:"ctx.output.print(ensured)"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"passing-in-and-using-cli-args",children:"Passing in and using CLI args"}),"\n",(0,s.jsxs)(n.p,{children:["A BXL function can accept a ",(0,s.jsx)(n.code,{children:"cli_args"})," attribute where args names and types are\nspecified to use within your script, as shown in the following example:"]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def _impl_example(ctx):\n    # ...\n    pass\n\nexample = bxl_main(\n    impl = _impl_example,\n    cli_args = {\n        # cli args that you want to receive from the command line\n        "bool_arg": cli_args.bool(),\n        "list_type": cli_args.list(cli_args.int()),\n        "optional": cli_args.option(cli_args.string()),\n        "target": cli_args.target_label(),\n    },\n)\n'})}),"\n",(0,s.jsx)(n.p,{children:"On the command line, you can invoke the arguments as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"buck2 bxl //myscript.bxl:example -- --bool_arg true --list_type 1 --list_type 2 --target //foo:bar\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For BXL functions, to read the arguments, use them as attributes from the\n",(0,s.jsx)(n.code,{children:"cli_args"})," attribute on the BXL ",(0,s.jsx)(n.code,{children:"ctx"})," object, as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def _impl_example(ctx):\n    my_bool_arg = ctx.cli_args.bool_arg\n"})}),"\n",(0,s.jsx)(n.h2,{id:"running-actions",children:"Running actions"}),"\n",(0,s.jsxs)(n.p,{children:["You can create actions within BXL via the ",(0,s.jsx)(n.code,{children:"actions_factory"}),". This is called once\nglobally then used on demand:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def _impl_example(ctx):\n    actions = ctx.bxl_actions().actions # call once, reuse wherever needed\n    output = actions.write("my_output", "out")\n'})}),"\n",(0,s.jsxs)(n.p,{children:["You will need to have\n",(0,s.jsx)(n.a,{href:"/docs/rule_authors/configurations#execution-platforms",children:"execution platforms"}),"\nenabled for your project, or else you will get an error. You can specify the\nexecution platform resolution by setting named parameters when instantiating\n",(0,s.jsx)(n.code,{children:"bxl_actions"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"exec_deps"})," - These are dependencies you wish to access as executables for\ncreating the action. This is usually the same set of targets one would pass to\nrule's ",(0,s.jsx)(n.code,{children:"attr.exec_dep"}),". Accepts a list of strings, subtarget labels, target\nlabels, or target nodes."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"toolchains"})," - The set of toolchains needed for the actions you intend to\ncreate. Accepts a list of strings, subtarget labels, target labels, or target\nnodes."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"target_platform"})," - The intended target platform for your toolchains. Accepts\na string or target label."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"exec_compatible_with"})," - Explicit list of configuration nodes (like platforms\nor constraints) that these actions are compatible with. This is the\n",(0,s.jsx)(n.code,{children:"exec_compatible_with"})," attribute of a target. Accepts a list of strings,\ntarget labels, or target nodes."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["If you specify ",(0,s.jsx)(n.code,{children:"exec_deps"})," or ",(0,s.jsx)(n.code,{children:"toolchains"}),", you can access the resolved\n",(0,s.jsx)(n.code,{children:"dependency"})," objects on the ",(0,s.jsx)(n.code,{children:"bxl_actions"})," object. The ",(0,s.jsx)(n.code,{children:"bxl_actions"})," object will\nhave ",(0,s.jsx)(n.code,{children:"exec_deps"})," and ",(0,s.jsx)(n.code,{children:"toolchains"})," attributes, which are ",(0,s.jsx)(n.code,{children:"dict"}),"s where the keys\nare the unconfigured subtarget labels, and the values are the\nconfigured/resolved ",(0,s.jsx)(n.code,{children:"dependency"})," objects."]}),"\n",(0,s.jsxs)(n.p,{children:["Note that the keys of ",(0,s.jsx)(n.code,{children:"exec_deps"})," and ",(0,s.jsx)(n.code,{children:"toolchains"})," must be unconfigured\nsubtarget labels (",(0,s.jsx)(n.code,{children:"StarlarkProvidersLabel"}),"), and not unconfigured target labels.\nYou can use ",(0,s.jsx)(n.code,{children:"ctx.unconfigured_sub_targets(...)"})," or ",(0,s.jsx)(n.code,{children:"with_sub_target()"})," on\n",(0,s.jsx)(n.code,{children:"target_label"})," to create the label."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def _impl_example(ctx):\n    my_exec_dep = ctx.unconfigured_sub_targets("foo//bar:baz") # has some provider that you would use in the action\n    bxl_actions = ctx.bxl_actions(exec_deps = [my_exec_dep]) # call once, reuse wherever needed\n    output = bxl_actions.actions.run(\n        [\n            "python3",\n            bxl_actions.exec_deps[my_exec_dep][RunInfo], # access resolved exec_deps on the `bxl_actions`\n            out.as_output(),\n        ],\n        category = "command",\n        local_only = True,\n    )\n    ctx.output.ensure(output)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"getting-providers-from-an-analysis",children:"Getting providers from an analysis"}),"\n",(0,s.jsxs)(n.p,{children:["After calling ",(0,s.jsx)(n.code,{children:"analysis()"}),", you can get the providers collection from\n",(0,s.jsx)(n.code,{children:"providers()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def _impl_example(ctx):\n    my_providers = ctx.analysis(my_target).providers()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"get-a-specific-provider-from-an-analysis",children:"Get a specific provider from an analysis"}),"\n",(0,s.jsxs)(n.p,{children:["After calling ",(0,s.jsx)(n.code,{children:"analysis()"}),", you can also get the providers collection from\n",(0,s.jsx)(n.code,{children:"providers()"})," then grab whatever specific provider you need:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def _impl_example(ctx):\n    default_info = ctx.analysis(my_target).providers()[DefaultInfo]\n    ctx.output.print(default_info)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"get-a-specific-subtarget-from-an-analysis",children:"Get a specific subtarget from an analysis"}),"\n",(0,s.jsxs)(n.p,{children:["Once you have a provider, you can get its subtargets by using the ",(0,s.jsx)(n.code,{children:"sub_targets"}),"\nattribute on the struct to get a dict of provider labels to provider\ncollections:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def _impl_example(ctx):\n    subtarget = ctx.analysis(my_target).providers()[DefaultInfo].sub_targets["my_subtarget"]\n    ctx.output.print(subtarget)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"building-a-targetsubtarget-without-blocking",children:"Building a target/subtarget without blocking"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ctx.build"})," is synchronous and should only be used when the result of the build\nis needed inline during the bxl execution. To execute builds without blocking\nthe script, retrieve the outputs from ",(0,s.jsx)(n.code,{children:"DefaultInfo"})," of the target's providers\nand use the ",(0,s.jsx)(n.code,{children:"ctx.output.ensure/ensure_multiple"})," for the outputs. Or you can use\nthe util function\n",(0,s.jsx)(n.a,{href:"../../../api/bxl_utils/ensure/#ensure_default_info",children:(0,s.jsx)(n.code,{children:"ensure_default_info"})})]}),"\n",(0,s.jsx)(n.h2,{id:"accessing-unconfiguredconfigured-target-node-attributes",children:"Accessing Unconfigured/Configured Target Node Attributes"}),"\n",(0,s.jsx)(n.p,{children:"BXL provides a unified API for accessing attributes on both unconfigured and\nconfigured target nodes."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"../../../api/bxl/ConfiguredTargetNode/#configuredtargetnodeget_attrs",children:(0,s.jsx)(n.code,{children:"node.get_attr(key)"})}),":\nGet one attribute"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"../../../api/bxl/ConfiguredTargetNode/#configuredtargetnodeget_attrs",children:(0,s.jsx)(n.code,{children:"node.get_attrs"})}),":\nGet all attributes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"../../../api/bxl/ConfiguredTargetNode/#configuredtargetnodeget_attrs",children:(0,s.jsx)(n.code,{children:"node.has_attrs(key)"})}),":\nCheck if one attribute exists"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For special attributes like ",(0,s.jsx)(n.code,{children:"rule_kind"}),", we get them directly from node:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"node.rule_kind\n"})}),"\n",(0,s.jsx)(n.h3,{id:"deprecated-apis",children:"Deprecated apis"}),"\n",(0,s.jsx)(n.p,{children:"The following attribute access api are not recommended and will be deprecated"}),"\n",(0,s.jsxs)(n.p,{children:["For ",(0,s.jsx)(n.code,{children:"ConfiguredTargetNode"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"../../../api/bxl/ConfiguredTargetNode/#configuredtargetnodeattrs_eager",children:(0,s.jsx)(n.code,{children:".attrs_eager"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"../../../api/bxl/ConfiguredTargetNode/#configuredtargetnodeattrs_lazy",children:(0,s.jsx)(n.code,{children:".attrs_lazy"})})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"../../../api/bxl/ConfiguredTargetNode/#configuredtargetnoderesolved_attrs_eager",children:(0,s.jsx)(n.code,{children:".resolved_attrs_eager"})}),","]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"../../../api/bxl/ConfiguredTargetNode/#configuredtargetnoderesolved_attrs_lazy",children:(0,s.jsx)(n.code,{children:".resolved_attrs_lazy"})})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For ",(0,s.jsx)(n.code,{children:"UnconfiguredTargetNode"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"../../../api/bxl/UnconfiguredTargetNode/#unconfiguredtargetnodeattrs",children:(0,s.jsx)(n.code,{children:".attrs"})})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def _impl_example(ctx):\n    my_configured_node = ctx.configured_targets(":foo")\n\n    # get an attribute named "foo", if not exist return None\n    foo_attr = my_configured_node.get_attr("foo")\n\n    # get all attributes, it returns a dict mapping from attribute name to attribute\n    all_attrs = my_configured_node.get_attrs()\n\n    # check if "foo" attribute exists on node\n    foo_exist = my_configured_node.has_attr("foo")\n\n    # access special attribute `rule_type`\n    rule_type = my_configured_node.rule_type\n\n    # same for UnconfiguredTargetNode\n'})}),"\n",(0,s.jsx)(n.h2,{id:"inspecting-a-struct",children:"Inspecting a struct"}),"\n",(0,s.jsxs)(n.p,{children:["You can use ",(0,s.jsx)(n.code,{children:"dir(my_struct)"})," to inspect a struct. You can also use\n",(0,s.jsx)(n.code,{children:'getattr(my_struct, "my_attr")'})," to grab individual attributes, which is\nequivalent to ",(0,s.jsx)(n.code,{children:"my_struct.my_attr"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["These are available as part of the\n",(0,s.jsx)(n.a,{href:"https://github.com/bazelbuild/starlark/blob/master/spec.md#dir",children:"Starlark language spec"}),"."]}),"\n",(0,s.jsxs)(n.h2,{id:"set-additionsubtraction-on-a-target_set",children:["Set addition/subtraction on a ",(0,s.jsx)(n.code,{children:"target_set"})]}),"\n",(0,s.jsxs)(n.p,{children:["There are a few BXL actions that return a ",(0,s.jsx)(n.code,{children:"target_set"})," (such as a cquery\n",(0,s.jsx)(n.code,{children:"eval()"}),"). The ",(0,s.jsx)(n.code,{children:"target_set"})," supports set subtraction and addition (you can use\n",(0,s.jsx)(n.code,{children:"-"})," and ",(0,s.jsx)(n.code,{children:"+"})," directly in Starlark)."]}),"\n",(0,s.jsxs)(n.h2,{id:"initializing-configuredunconfigured-target_set",children:["Initializing configured/unconfigured ",(0,s.jsx)(n.code,{children:"target_set"})]}),"\n",(0,s.jsxs)(n.p,{children:["You can use following apis to initialize ",(0,s.jsx)(n.code,{children:"target_set"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def bxl.utarget_set(nodes: None | list[bxl.UnconfiguredTargetNode]) -> bxl.UnconfiguredTargetSet\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def bxl.ctarget_set(nodes: None | list[bxl.ConfiguredTargetNode]) -> bxl.ConfiguredTargetSet\n"})}),"\n",(0,s.jsx)(n.h2,{id:"profiling-testing-and-debugging-a-bxl-script",children:"Profiling, Testing, and Debugging a BXL script"}),"\n",(0,s.jsxs)(n.p,{children:["You can use ",(0,s.jsx)(n.code,{children:"buck2 bxl profiler"}),", with various measurements, to determine where\nthe script is least efficient."]}),"\n",(0,s.jsx)(n.p,{children:"To time individual pieces of the script, you can use BXL\u2019s timestamp methods:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def _impl_example(_ctx):\n    start = now() # call once and reuse wherever is necessary\n    # do something time intensive here\n    end1 = start.elapsed_millis()\n    # do something else time intensive here\n    end2 = start.elapsed_millis()\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Debug"})," - the common way to debug a BXL script is with print statements\n(",(0,s.jsx)(n.code,{children:"print()"}),", ",(0,s.jsx)(n.code,{children:"pprint()"})," and ",(0,s.jsx)(n.code,{children:"ctx.output.print()"}),")."]}),"\n"]}),"\n",(0,s.jsx)(a.FbInternalOnly,{children:(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Debugger"})," - to use the debugger you can follow these instructions\n",(0,s.jsx)(n.a,{href:"https://fb.workplace.com/groups/buck2eng/permalink/3562907607330619/",children:"here"}),"."]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"fdb --starlark-kill-buck attach buck"})}),"\n",(0,s.jsx)(n.li,{children:"place a breakpoint to the bxl file"}),"\n",(0,s.jsx)(n.li,{children:"run the buck2 bxl command"}),"\n"]}),"\n"]}),"\n"]})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Test"})," - BXL does not have a robust testing framework for mocking. The main\nmethod to test a BXL script is to actually invoke it with required inputs then\nverify the outputs."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"getting-the-path-of-an-artifact-as-a-string",children:"Getting the path of an artifact as a string"}),"\n",(0,s.jsxs)(n.p,{children:["The starlark ",(0,s.jsx)(n.code,{children:"artifact"})," type encapsulates source artifacts, declared artifacts,\nand build artifacts. It can be dangerous to access paths and use them in further\nBXL computations. For example, if you are trying to use absolute paths for\nsomething and end up passing it into a remotely executed action, the absolute\npath may not exist on the remote machine. Or, if you are working with paths and\nexpecting the artifact to already have been materialized in further BXL\ncomputations, that would also result in errors."]}),"\n",(0,s.jsxs)(n.p,{children:["However, if you are not making any assumptions about the existence of these\nartifacts, you can use use\n",(0,s.jsx)(n.a,{href:"../../../api/bxl#get_path_without_materialization",children:(0,s.jsx)(n.code,{children:"get_path_without_materialization()"})}),",\nwhich accepts source, declared, or build artifacts. It does ",(0,s.jsx)(n.em,{children:"not"})," accept ensured\nartifacts (also see\n",(0,s.jsx)(n.a,{href:"../../faq#what-do-i-need-to-know-about-ensured-artifacts",children:"What do I need to know about ensured artifacts"}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["For getting paths of ",(0,s.jsx)(n.code,{children:"cmd_args()"})," inputs, you can use\n",(0,s.jsx)(n.a,{href:"../../../api/bxl#get_paths_without_materialization",children:(0,s.jsx)(n.code,{children:"get_paths_without_materialization()"})}),",\nbut note this is risky because the inputs could contain tsets, which, when\nexpanded, could be very large. Use these methods at your own risk."]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(96540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);