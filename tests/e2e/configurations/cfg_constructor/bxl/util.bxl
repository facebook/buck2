# Copyright (c) Meta Platforms, Inc. and affiliates.
#
# This source code is dual-licensed under either the MIT license found in the
# LICENSE-MIT file in the root directory of this source tree or the Apache
# License, Version 2.0 found in the LICENSE-APACHE file in the root directory
# of this source tree. You may select, at your option, one of the
# above-listed licenses.

load("@prelude//cfg/modifier:conditional_modifier.bzl", _get_modifier_info = "get_modifier_info_for_testing")
load("@prelude//cfg/modifier:types.bzl", "ConditionalModifierInfo", "Modifier", "ModifierInfo")
load("@prelude//configurations:util.bzl", "util")

_TARGETS = [
    "ovr_config//cpu/constraints:cpu",
    "ovr_config//cpu:x86_64",
    "ovr_config//cpu/constraints:x86_64",
    "ovr_config//cpu/constraints:arm64",
    "ovr_config//os/constraints:os",
    "ovr_config//os:linux",
    "ovr_config//os:linux-no-san",
    "ovr_config//os/constraints:linux",
    "ovr_config//os/constraints:macos",
    "ovr_config//os/constraints:windows",
    "config//os/constraints:windows",  # Cell alias for ovr_config//os/constraints:windows
    "ovr_config//build_mode:sanitizer_type",
    "ovr_config//build_mode:sanitizer_type[no-san]",
    "ovr_config//build_mode:sanitizer_type[asan]",
    "ovr_config//build_mode:sanitizer_type[asan-ubsan]",
    "ovr_config//build_mode:sanitizer_type[hwasan]",
    "ovr_config//build_mode:sanitizer_type[tsan]",
    "config//build_mode:sanitizer_type[tsan]",  # Cell alias for ovr_config//build_mode:sanitizer_type[tsan]
    # TODO: This will probably get broken by updates to clang constraints.
    # Figure out how to handle this.
    "ovr_config//toolchain/clang/constraints:15",
    "ovr_config//toolchain/clang/constraints:17",
]

ALIASES = struct(
    # OS
    linux = "ovr_config//os:linux",
    macos = "ovr_config//os:macos",
    windows = "ovr_config//os:windows",
    # CPU
    x86_64 = "ovr_config//cpu:x86_64",
    arm64 = "ovr_config//cpu:arm64",
    # Multiple modifiers
    linux_x86_64 = [
        "ovr_config//os:linux",
        "ovr_config//cpu:x86_64",
    ],
)

TestRefs = record(
    _refs = dict[str, ProviderCollection],
    get = field(typing.Callable),
    make_cfg = field(typing.Callable),
    get_modifier_info = field(typing.Callable),
)

def _parse_target_with_subtarget(ctx: bxl.Context, target_str: str):
    unconfigured = ctx.unconfigured_sub_targets(target_str)
    base_target = unconfigured.raw_target()
    configured = ctx.configured_targets(base_target)

    # If there's a subtarget, add it to the configured label
    if unconfigured.sub_target:
        return configured.label.with_sub_target(unconfigured.sub_target)
    else:
        return configured

def _get_providers(ctx: bxl.Context, targets: list[str]) -> dict[str, ProviderCollection]:
    configured = [_parse_target_with_subtarget(ctx, t) for t in targets]
    analysis_result = ctx.analysis(configured)

    # Build a mapping from resolved target to list of original target strings
    # This handles cases where multiple target strings resolve to the same target (e.g., cell aliases)
    resolved_to_originals = {}
    for original_key, configured_target in zip(targets, configured):
        # Get the resolved key for this configured target
        # configured_target can be either a ConfiguredTargetNode (has .label) or ConfiguredProvidersLabel
        if hasattr(configured_target, "label"):
            label = configured_target.label
        else:
            label = configured_target

        # Extract raw target - handle both with and without sub_target
        raw = label.raw_target() if hasattr(label, "raw_target") else label
        sub = label.sub_target if hasattr(label, "sub_target") else None
        resolved_key = str(raw.with_sub_target(sub)) if sub else str(raw)
        if resolved_key not in resolved_to_originals:
            resolved_to_originals[resolved_key] = []
        resolved_to_originals[resolved_key].append(original_key)

    result = {}
    for target, v in analysis_result.items():
        providers = v.providers()
        resolved_key = str(target.raw_target().with_sub_target(target.sub_target)) if target.sub_target else str(target.raw_target())
        result[resolved_key] = providers

        # Also add all original target strings as keys if they differ from the resolved key
        # This allows tests to use cell aliases (e.g., "config//..." instead of "ovr_config//...")
        for original_key in resolved_to_originals.get(resolved_key, []):
            if original_key != resolved_key:
                result[original_key] = providers
    return result

def get_test_refs(ctx: bxl.Context) -> TestRefs:
    def get(target: str) -> ProviderCollection:
        return self._refs[target]

    def make_cfg(targets: list[str]) -> ConfigurationInfo:
        return util.configuration_info_union([self._refs[target][ConfigurationInfo] for target in targets if target in self._refs])

    def get_modifier_info(modifier: Modifier) -> ModifierInfo:
        key_to_provider = {
            target: providers[ConfigurationInfo]
            for target, providers in self._refs.items()
            if ConfigurationInfo in providers
        }
        value_to_provider = {
            target: providers[ConditionalModifierInfo]
            for target, providers in self._refs.items()
            if ConditionalModifierInfo in providers
        }
        conditional_modifier_info = _get_modifier_info(
            modifier,
            key_to_provider,
            value_to_provider,
        )
        return conditional_modifier_info.inner

    self = TestRefs(
        _refs = _get_providers(ctx, _TARGETS),
        get = get,
        make_cfg = make_cfg,
        get_modifier_info = get_modifier_info,
    )
    return self
