"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[47114],{28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>d});var l=i(96540);const s={},r=l.createContext(s);function o(e){const n=l.useContext(r);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),l.createElement(r.Provider,{value:n},e.children)}},69860:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>t});const l=JSON.parse('{"id":"users/commands/profile","title":"profile","description":"This document provides an overview of the commands and options available under buck2 profile.","source":"@site/../docs/users/commands/profile.generated.md","sourceDirName":"users/commands","slug":"/users/commands/profile","permalink":"/docs/users/commands/profile","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"profile","title":"profile"},"sidebar":"main","previous":{"title":"lsp","permalink":"/docs/users/commands/lsp"},"next":{"title":"query","permalink":"/docs/users/commands/query"}}');var s=i(74848),r=i(28453);const o={id:"profile",title:"profile"},d="profile",c={},t=[{value:"<code>buck2 profile</code>",id:"buck2-profile",level:2},{value:"Subcommands:",id:"subcommands",level:3},{value:"Common Options:",id:"common-options",level:3},{value:"<code>buck2 profile analysis</code>",id:"buck2-profile-analysis",level:2},{value:"Arguments:",id:"arguments",level:3},{value:"Common Options:",id:"common-options-1",level:3},{value:"Options:",id:"options",level:3},{value:"<code>buck2 profile loading</code>",id:"buck2-profile-loading",level:2},{value:"Arguments:",id:"arguments-1",level:3},{value:"Common Options:",id:"common-options-2",level:3},{value:"Options:",id:"options-1",level:3},{value:"<code>buck2 profile bxl</code>",id:"buck2-profile-bxl",level:2},{value:"Arguments:",id:"arguments-2",level:3},{value:"Common Options:",id:"common-options-3",level:3},{value:"Options:",id:"options-2",level:3}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"profile",children:"profile"})}),"\n",(0,s.jsxs)(n.p,{children:["This document provides an overview of the commands and options available under ",(0,s.jsx)(n.code,{children:"buck2 profile"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-profile",children:(0,s.jsx)(n.code,{children:"buck2 profile"})}),"\n",(0,s.jsx)(n.p,{children:"Run starlark profiler"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 profile <COMMAND>"})]}),"\n",(0,s.jsx)(n.h3,{id:"subcommands",children:"Subcommands:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"analysis"}),": Profile analysis"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"loading"}),": Profile ",(0,s.jsx)(n.code,{children:"BUCK"})," file evaluation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"bxl"}),": Profile BXL script"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-profile-analysis",children:(0,s.jsx)(n.code,{children:"buck2 profile analysis"})}),"\n",(0,s.jsx)(n.p,{children:"Profile analysis"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 profile analysis [OPTIONS] --output <PATH> --mode <MODE> [TARGET_PATTERNS]..."})]}),"\n",(0,s.jsx)(n.h3,{id:"arguments",children:"Arguments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"<TARGET_PATTERNS>"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-1",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h3,{id:"options",children:"Options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-r, --recursive"}),"\nIn analysis profiling, capture the profile of the target and its dependencies, and output the merged profile"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-o, --output <PATH>"}),"\nOutput file path for profile data."]}),"\n",(0,s.jsx)(n.p,{children:"File will be created if it does not exist, and overwritten if it does."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--mode <MODE>"}),"\nProfile mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,s.jsx)(n.code,{children:"-allocated"})," or ",(0,s.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heap after analysis complete. ",(0,s.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"time-flame"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"statement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"typecheck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"coverage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-u, --target-universe <TARGET_UNIVERSE>"}),"\nComma separated list of targets to construct a configured target universe."]}),"\n",(0,s.jsxs)(n.p,{children:["When the option is specified, command targets are be resolved in this universe.\nAdditionally, ",(0,s.jsx)(n.code,{children:"--target-platforms="})," and ",(0,s.jsx)(n.code,{children:"--modifier="})," flags are be used to configure the\nuniverse targets, not the command targets."]}),"\n",(0,s.jsx)(n.p,{children:"This argument is particularly recommended on most non-trivial cqueries. In the absence of\nthis argument, buck2 will use the target literals in your cquery expression as the value\nfor this argument, which may not be what you want."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--target-platforms <PLATFORM>"}),"\nConfiguration target (one) to use to configure targets"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-m, --modifier <VALUE>"}),"\nA configuration modifier to configure all targets on the command line. This may be a constraint value target."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--disable-starlark-types"}),"\nDisable runtime type checking in Starlark interpreter."]}),"\n",(0,s.jsx)(n.p,{children:"This option is not stable, and can be used only locally to diagnose evaluation performance problems."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--stack"}),"\nRecord or show target call stacks."]}),"\n",(0,s.jsx)(n.p,{children:"Starlark call stacks will be included in duplicate targets error."}),"\n",(0,s.jsxs)(n.p,{children:["If a command outputs targets (like ",(0,s.jsx)(n.code,{children:"targets"})," command), starlark call stacks will be printed after the targets."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns <PROFILE_PATTERNS>"}),"\nEnables profiling for all evaluations whose evaluation identifier matches one of the provided patterns."]}),"\n",(0,s.jsxs)(n.p,{children:["Some examples identifiers: analysis/cell//buck2/app/buck2_action_impl",":buck2_action_impl"," (cfg",":linux-x86_64","#27ac5723e0c99706) load/cell//build_defs/json.bzl load/prelude//playground/test.bxl load/cell//build_defs/json.bzl@other_cell load_buildfile/fbcode//third-party-buck/platform010/build/ncurses load_packagefile/fbcode//cli/rust/cli_delegate anon_analysis/anon//:_anon_link_rule (anon: 766183dc9b6f680a) (fbcode//buck2/platform/execution",":linux-x86_64","#08961b14cfb182aa) bxl/prelude//playground/test.bxl",":playground"]}),"\n",(0,s.jsxs)(n.p,{children:["You can pass ",(0,s.jsx)(n.code,{children:"--profile-patterns=.*"})," to enable no-op profiling for everything (additionally pass ",(0,s.jsx)(n.code,{children:"--profile-patterns-mode=none"})," to use no-op profiling to just get a list of all the identifiers)."]}),"\n",(0,s.jsxs)(n.p,{children:["The profile results will be written to individual .profile files in ",(0,s.jsx)(n.code,{children:"<ROOT_OUTPUT>/<data+time>-<uuid>/"})," where ROOT_OUTPUT comes from the --profile-patterns-output flag. In that directory there will also be a file listing all the identifiers that were profiled."]}),"\n",(0,s.jsx)(n.p,{children:"Enabling/disabling profiling of an evaluation will invalidate the results of that evaluation and it will be recomputed. In some cases, this will cause other work to also need to be redone (for example, invalidating the result of loading PACKAGE files causes all consumers to be recomputed). But if you keep profiling options consistent between commands, only the work that is otherwise invalidated will be redone (and only for those would profiling results be created)."}),"\n",(0,s.jsx)(n.p,{children:"You must also pass --profile-patterns-mode and --profile-patterns-output."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--profile-patterns-output <PATH>"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns-mode <PROFILE_PATTERNS_MODE>"}),"\nProfile mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,s.jsx)(n.code,{children:"-allocated"})," or ",(0,s.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heaps after analysis completes. ",(0,s.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"time-flame"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"statement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"typecheck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"coverage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-profile-loading",children:(0,s.jsx)(n.code,{children:"buck2 profile loading"})}),"\n",(0,s.jsxs)(n.p,{children:["Profile ",(0,s.jsx)(n.code,{children:"BUCK"})," file evaluation"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 profile loading [OPTIONS] --output <PATH> --mode <MODE> [TARGET_PATTERNS]..."})]}),"\n",(0,s.jsx)(n.h3,{id:"arguments-1",children:"Arguments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"<TARGET_PATTERNS>"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-2",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h3,{id:"options-1",children:"Options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-r, --recursive"}),"\nIn analysis profiling, capture the profile of the target and its dependencies, and output the merged profile"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-o, --output <PATH>"}),"\nOutput file path for profile data."]}),"\n",(0,s.jsx)(n.p,{children:"File will be created if it does not exist, and overwritten if it does."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--mode <MODE>"}),"\nProfile mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,s.jsx)(n.code,{children:"-allocated"})," or ",(0,s.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heap after analysis complete. ",(0,s.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"time-flame"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"statement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"typecheck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"coverage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-u, --target-universe <TARGET_UNIVERSE>"}),"\nComma separated list of targets to construct a configured target universe."]}),"\n",(0,s.jsxs)(n.p,{children:["When the option is specified, command targets are be resolved in this universe.\nAdditionally, ",(0,s.jsx)(n.code,{children:"--target-platforms="})," and ",(0,s.jsx)(n.code,{children:"--modifier="})," flags are be used to configure the\nuniverse targets, not the command targets."]}),"\n",(0,s.jsx)(n.p,{children:"This argument is particularly recommended on most non-trivial cqueries. In the absence of\nthis argument, buck2 will use the target literals in your cquery expression as the value\nfor this argument, which may not be what you want."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--target-platforms <PLATFORM>"}),"\nConfiguration target (one) to use to configure targets"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-m, --modifier <VALUE>"}),"\nA configuration modifier to configure all targets on the command line. This may be a constraint value target."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--disable-starlark-types"}),"\nDisable runtime type checking in Starlark interpreter."]}),"\n",(0,s.jsx)(n.p,{children:"This option is not stable, and can be used only locally to diagnose evaluation performance problems."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--stack"}),"\nRecord or show target call stacks."]}),"\n",(0,s.jsx)(n.p,{children:"Starlark call stacks will be included in duplicate targets error."}),"\n",(0,s.jsxs)(n.p,{children:["If a command outputs targets (like ",(0,s.jsx)(n.code,{children:"targets"})," command), starlark call stacks will be printed after the targets."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns <PROFILE_PATTERNS>"}),"\nEnables profiling for all evaluations whose evaluation identifier matches one of the provided patterns."]}),"\n",(0,s.jsxs)(n.p,{children:["Some examples identifiers: analysis/cell//buck2/app/buck2_action_impl",":buck2_action_impl"," (cfg",":linux-x86_64","#27ac5723e0c99706) load/cell//build_defs/json.bzl load/prelude//playground/test.bxl load/cell//build_defs/json.bzl@other_cell load_buildfile/fbcode//third-party-buck/platform010/build/ncurses load_packagefile/fbcode//cli/rust/cli_delegate anon_analysis/anon//:_anon_link_rule (anon: 766183dc9b6f680a) (fbcode//buck2/platform/execution",":linux-x86_64","#08961b14cfb182aa) bxl/prelude//playground/test.bxl",":playground"]}),"\n",(0,s.jsxs)(n.p,{children:["You can pass ",(0,s.jsx)(n.code,{children:"--profile-patterns=.*"})," to enable no-op profiling for everything (additionally pass ",(0,s.jsx)(n.code,{children:"--profile-patterns-mode=none"})," to use no-op profiling to just get a list of all the identifiers)."]}),"\n",(0,s.jsxs)(n.p,{children:["The profile results will be written to individual .profile files in ",(0,s.jsx)(n.code,{children:"<ROOT_OUTPUT>/<data+time>-<uuid>/"})," where ROOT_OUTPUT comes from the --profile-patterns-output flag. In that directory there will also be a file listing all the identifiers that were profiled."]}),"\n",(0,s.jsx)(n.p,{children:"Enabling/disabling profiling of an evaluation will invalidate the results of that evaluation and it will be recomputed. In some cases, this will cause other work to also need to be redone (for example, invalidating the result of loading PACKAGE files causes all consumers to be recomputed). But if you keep profiling options consistent between commands, only the work that is otherwise invalidated will be redone (and only for those would profiling results be created)."}),"\n",(0,s.jsx)(n.p,{children:"You must also pass --profile-patterns-mode and --profile-patterns-output."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--profile-patterns-output <PATH>"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns-mode <PROFILE_PATTERNS_MODE>"}),"\nProfile mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,s.jsx)(n.code,{children:"-allocated"})," or ",(0,s.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heaps after analysis completes. ",(0,s.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"time-flame"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"statement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"typecheck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"coverage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-profile-bxl",children:(0,s.jsx)(n.code,{children:"buck2 profile bxl"})}),"\n",(0,s.jsx)(n.p,{children:"Profile BXL script"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 profile bxl [OPTIONS] --output <PATH> --mode <MODE> <BXL label> [-- <BXL INPUT ARGS>...]"})]}),"\n",(0,s.jsx)(n.h3,{id:"arguments-2",children:"Arguments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"<BXL label>"}),"\nThe bxl function to execute as defined by the label of form ",(0,s.jsx)(n.code,{children:"<cell>//path/file.bxl:<function>"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"<BXL INPUT ARGS>"}),"\nArguments passed to the bxl script"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-3",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h3,{id:"options-2",children:"Options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-M, --materializations <MATERIALIZATIONS>"}),"\nMaterialize (or skip) the final artifacts, bypassing buckconfig."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"all"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--upload-final-artifacts <UPLOAD_FINAL_ARTIFACTS>"}),"\nUpload (or skip) the final artifacts."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"always"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"never"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--user-event-log <PATH>"}),"\nWrite user events to this log file. Both user and internal events are written to main event log. If this flag is specified, user events are additionally written to user event log. Log format is JSONL, uncompressed if no known extensions are detected, or you can explicitly specify the compression via the file extension (ex: ",(0,s.jsx)(n.code,{children:".json-lines.gz"})," would be gzip compressed, ",(0,s.jsx)(n.code,{children:".json-lines.zst"})," would be zstd compressed). Resulting log is is compatible with ",(0,s.jsx)(n.code,{children:"buck2 log show-user"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--build-report <PATH>"}),"\nPrint a build report"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--build-report=-"})," will print the build report to stdout ",(0,s.jsx)(n.code,{children:"--build-report=<filepath>"})," will write the build report to the file"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--enable-optional-validations <VALIDATION_NAMES>"}),"\nComma separated list of validation names to run that are marked optional."]}),"\n",(0,s.jsx)(n.p,{children:"By default, validations marked as optional are skipped. This option overrides the behaviour and executes those validations."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--build-report-options <BUILD_REPORT_OPTIONS>"}),"\nComma separated list of build report options."]}),"\n",(0,s.jsx)(n.p,{children:"The following options are supported:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"fill-out-failures"}),": fill out failures the same way Buck1 would."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"package-project-relative-paths"}),": emit the project-relative path of packages for the targets that were built."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"exclude-action-error-diagnostics"}),": exclude error_diagnostics field from action errors in the build report."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--streaming-build-report <PATH>"}),"\nStream intermediary build reports to a file in json lines format."]}),"\n",(0,s.jsx)(n.p,{children:"Each output materialization will trigger a new build report which will be written to the file as a single line json."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-j, --num-threads <THREADS>"}),"\nNumber of threads to use during execution (default is # cores)"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--local-only"}),"\nEnable only local execution. Will reject actions that cannot execute locally"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--remote-only"}),"\nEnable only remote execution. Will reject actions that cannot execute remotely"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--prefer-local"}),"\nEnable hybrid execution. Will prefer executing actions that can execute locally on the local host"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--prefer-remote"}),"\nEnable hybrid execution. Will prefer executing actions that can execute remotely on RE and will avoid racing local and remote execution"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--unstable-no-execution"}),"\nExperimental: Disable all execution"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--no-remote-cache"}),"\nDo not perform remote cache queries or cache writes. If remote execution is enabled, the RE service might still deduplicate actions, so for e.g. benchmarking, using a random isolation dir is preferred"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--write-to-cache-anyway"}),"\nCould be used to enable the action cache writes on the RE worker when no_remote_cache is specified"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--eager-dep-files"}),"\nProcess dep files when they are generated (i.e. after running a command that produces dep files), rather than when they are used (i.e. before re-running a command that previously produced dep files). Use this when debugging commands that produce dep files. Note that commands that previously produced dep files will not re-run: only dep files produced during this command will be eagerly loaded"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--upload-all-actions"}),"\nUploads every action to the RE service, regardless of whether the action needs to execute on RE."]}),"\n",(0,s.jsx)(n.p,{children:"This is useful when debugging builds and trying to inspect actions which executed remotely. It's possible that the action result is cached but the action itself has expired. In this case, downloading the action itself would fail. Enabling this option would unconditionally upload all actions, thus you will not hit any expiration issues."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--fail-fast"}),"\nIf Buck hits an error, do as little work as possible before exiting."]}),"\n",(0,s.jsxs)(n.p,{children:["To illustrate the effect of this flag, consider an invocation of ",(0,s.jsx)(n.code,{children:"build :foo :bar"}),". The default behavior of buck is to do enough work to get a result for the builds of each of ",(0,s.jsx)(n.code,{children:":foo"})," and ",(0,s.jsx)(n.code,{children:":bar"}),", and no more. This means that buck will continue to complete the build of ",(0,s.jsx)(n.code,{children:":bar"})," after the build of ",(0,s.jsx)(n.code,{children:":foo"})," has failed; however, once one dependency of ",(0,s.jsx)(n.code,{children:":foo"})," has failed, other dependencies will be cancelled unless they are needed by ",(0,s.jsx)(n.code,{children:":bar"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["This flag changes the behavior of buck to not wait on ",(0,s.jsx)(n.code,{children:":bar"})," to complete once ",(0,s.jsx)(n.code,{children:":foo"})," has failed. Generally, this flag only has an effect on builds that specify multiple targets."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--keep-going"})," changes the behavior of buck to not only wait on ",(0,s.jsx)(n.code,{children:":bar"})," once one dependency of ",(0,s.jsx)(n.code,{children:":foo"})," has failed, but to additionally attempt to build other dependencies of ",(0,s.jsx)(n.code,{children:":foo"})," if possible."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--keep-going"}),"\nIf Buck hits an error, continue doing as much work as possible before exiting."]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.code,{children:"--fail-fast"})," for more details."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--skip-missing-targets"}),"\nIf target is missing, then skip building instead of throwing error"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--skip-incompatible-targets"}),"\nIf target is incompatible with the specified configuration, skip building instead of throwing error. This does not apply to targets specified with glob patterns ",(0,s.jsx)(n.code,{children:"/..."})," or ",(0,s.jsx)(n.code,{children:":"})," which are skipped unconditionally"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--materialize-failed-inputs"}),"\nMaterializes inputs for failed actions which ran on RE"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--materialize-failed-outputs"}),"\nMaterializes outputs (if present) for failed actions which ran on RE"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-o, --output <PATH>"}),"\nOutput file path for profile data."]}),"\n",(0,s.jsx)(n.p,{children:"File will be created if it does not exist, and overwritten if it does."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--mode <MODE>"}),"\nProfile mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,s.jsx)(n.code,{children:"-allocated"})," or ",(0,s.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heap after analysis complete. ",(0,s.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"time-flame"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"statement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"typecheck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"coverage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-u, --target-universe <TARGET_UNIVERSE>"}),"\nComma separated list of targets to construct a configured target universe."]}),"\n",(0,s.jsxs)(n.p,{children:["When the option is specified, command targets are be resolved in this universe.\nAdditionally, ",(0,s.jsx)(n.code,{children:"--target-platforms="})," and ",(0,s.jsx)(n.code,{children:"--modifier="})," flags are be used to configure the\nuniverse targets, not the command targets."]}),"\n",(0,s.jsx)(n.p,{children:"This argument is particularly recommended on most non-trivial cqueries. In the absence of\nthis argument, buck2 will use the target literals in your cquery expression as the value\nfor this argument, which may not be what you want."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--target-platforms <PLATFORM>"}),"\nConfiguration target (one) to use to configure targets"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-m, --modifier <VALUE>"}),"\nA configuration modifier to configure all targets on the command line. This may be a constraint value target."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--disable-starlark-types"}),"\nDisable runtime type checking in Starlark interpreter."]}),"\n",(0,s.jsx)(n.p,{children:"This option is not stable, and can be used only locally to diagnose evaluation performance problems."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--stack"}),"\nRecord or show target call stacks."]}),"\n",(0,s.jsx)(n.p,{children:"Starlark call stacks will be included in duplicate targets error."}),"\n",(0,s.jsxs)(n.p,{children:["If a command outputs targets (like ",(0,s.jsx)(n.code,{children:"targets"})," command), starlark call stacks will be printed after the targets."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns <PROFILE_PATTERNS>"}),"\nEnables profiling for all evaluations whose evaluation identifier matches one of the provided patterns."]}),"\n",(0,s.jsxs)(n.p,{children:["Some examples identifiers: analysis/cell//buck2/app/buck2_action_impl",":buck2_action_impl"," (cfg",":linux-x86_64","#27ac5723e0c99706) load/cell//build_defs/json.bzl load/prelude//playground/test.bxl load/cell//build_defs/json.bzl@other_cell load_buildfile/fbcode//third-party-buck/platform010/build/ncurses load_packagefile/fbcode//cli/rust/cli_delegate anon_analysis/anon//:_anon_link_rule (anon: 766183dc9b6f680a) (fbcode//buck2/platform/execution",":linux-x86_64","#08961b14cfb182aa) bxl/prelude//playground/test.bxl",":playground"]}),"\n",(0,s.jsxs)(n.p,{children:["You can pass ",(0,s.jsx)(n.code,{children:"--profile-patterns=.*"})," to enable no-op profiling for everything (additionally pass ",(0,s.jsx)(n.code,{children:"--profile-patterns-mode=none"})," to use no-op profiling to just get a list of all the identifiers)."]}),"\n",(0,s.jsxs)(n.p,{children:["The profile results will be written to individual .profile files in ",(0,s.jsx)(n.code,{children:"<ROOT_OUTPUT>/<data+time>-<uuid>/"})," where ROOT_OUTPUT comes from the --profile-patterns-output flag. In that directory there will also be a file listing all the identifiers that were profiled."]}),"\n",(0,s.jsx)(n.p,{children:"Enabling/disabling profiling of an evaluation will invalidate the results of that evaluation and it will be recomputed. In some cases, this will cause other work to also need to be redone (for example, invalidating the result of loading PACKAGE files causes all consumers to be recomputed). But if you keep profiling options consistent between commands, only the work that is otherwise invalidated will be redone (and only for those would profiling results be created)."}),"\n",(0,s.jsx)(n.p,{children:"You must also pass --profile-patterns-mode and --profile-patterns-output."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--profile-patterns-output <PATH>"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns-mode <PROFILE_PATTERNS_MODE>"}),"\nProfile mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,s.jsx)(n.code,{children:"-allocated"})," or ",(0,s.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heaps after analysis completes. ",(0,s.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"time-flame"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"statement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"typecheck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"coverage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}}}]);