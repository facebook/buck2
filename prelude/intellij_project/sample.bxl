load(
    "@fbcode//buck2/prelude/java:java_providers.bzl",
    "JavaLibraryInfo",
)

def impl(ctx):
    all_nodes = ctx.cquery().deps(ctx.cli_args.roots, -1)
    all_analysis = ctx.analysis(all_nodes)

    # keep a dict of your module graph?
    modules = {}

    for node in all_nodes:
        if all_analysis[configured_sub_target(node.label)].providers()[JavaLibraryInfo]:
            _info = node.providers[JavaLibraryInfo]
            # do stuff with info

        if node.rule_type == "fbcode//buck2/prelude/java_library.bzl:java_library":
            ctx.output.print(len(ctx.cquery().rdeps(ctx.cli_args.roots, node, 1)))

        modules[node.label] = None  # do something here?

    # now output the modules
    action_factory = ctx.bxl_actions.action_factory()

    output_module = action_factory.declare_output(".idea/modules.xml")
    action_factory.write(output_module, """\
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
<component name="ProjectModuleManager">
<modules>
</modules>
</component>
</project>
    """)
    # There are a few choices here, I believe you write multiple files, so you could declare an action for each, or have one uber action to write them all. With multiple, you use buck2â€™s internal caching to avoid repeated work, but with one uber action, you can take advantage of incremental actions api to do incremental updates.

    ctx.output.print(ctx.output.ensure(output_module).abs_path())

project_gen = bxl(
    implementation = impl,
    cli_args = {
        "mode": cli_args.string(),
        "roots": cli_args.list(cli_args.target_label()),
    },
)
