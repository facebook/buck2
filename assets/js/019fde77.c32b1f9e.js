"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[66016],{28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>s});var a=n(96540);const r={},l=a.createContext(r);function i(e){const t=a.useContext(l);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(l.Provider,{value:t},e.children)}},77813:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"api/bxl/LazyContext","title":"LazyContext","description":"Context for lazy/batch/error handling operations.","source":"@site/../docs/api/bxl/LazyContext.md","sourceDirName":"api/bxl","slug":"/api/bxl/LazyContext","permalink":"/docs/api/bxl/LazyContext","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"apiSidebar","previous":{"title":"LazyAttrs","permalink":"/docs/api/bxl/LazyAttrs"},"next":{"title":"LazyCqueryContext","permalink":"/docs/api/bxl/LazyCqueryContext"}}');var r=n(74848),l=n(28453),i=n(56289);const s={},o="LazyContext",d={},c=[{value:"LazyContext.analysis",id:"lazycontextanalysis",level:2},{value:"LazyContext.build_artifact",id:"lazycontextbuild_artifact",level:2},{value:"LazyContext.configured_target_node",id:"lazycontextconfigured_target_node",level:2},{value:"LazyContext.cquery",id:"lazycontextcquery",level:2},{value:"LazyContext.join",id:"lazycontextjoin",level:2},{value:"LazyContext.join_all",id:"lazycontextjoin_all",level:2},{value:"LazyContext.unconfigured_target_node",id:"lazycontextunconfigured_target_node",level:2},{value:"LazyContext.unconfigured_target_nodes_keep_going",id:"lazycontextunconfigured_target_nodes_keep_going",level:2},{value:"LazyContext.uquery",id:"lazycontextuquery",level:2}];function x(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"lazycontext",children:"LazyContext"})}),"\n",(0,r.jsx)(t.p,{children:"Context for lazy/batch/error handling operations."}),"\n",(0,r.jsxs)(t.p,{children:["Available as ",(0,r.jsx)(t.a,{href:"../Context#contextlazy",children:(0,r.jsx)(t.code,{children:"bxl.Context.lazy"})}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"lazycontextanalysis",children:"LazyContext.analysis"}),"\n",(0,r.jsx)("pre",{class:"language-python",children:(0,r.jsxs)("code",{children:["def LazyContext.analysis(\nlabel: ",(0,r.jsx)(i.default,{to:"/docs/api/build/ConfiguredTargetLabel",children:"ConfiguredTargetLabel"})," | ",(0,r.jsx)(i.default,{to:"/docs/api/build/Label",children:"Label"})," | ",(0,r.jsx)(i.default,{to:"/docs/api/bxl/ConfiguredTargetNode",children:"bxl.ConfiguredTargetNode"}),",\n/,\n) -> ",(0,r.jsx)(i.default,{to:"/docs/api/bxl/Lazy",children:"bxl.Lazy"})]})}),"\n",(0,r.jsx)(t.p,{children:"Analyze a target lazily. This will return a lazy operation that can be evaluated later. The target should be a ConfiguredTargetLabel, a ConfiguredProvidersLabel, or a ConfiguredTargetNode."}),"\n",(0,r.jsx)(t.p,{children:"Example:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'def _impl(ctx):\n    target = ctx.configured_targets("cell//path/to:target")\n    # Get the analysis result without catching errors\n    analysis_result = ctx.lazy.analysis(target).resolve()\n    # Catch errors. It will return a `bxl.Result`\n    result = ctx.lazy.analysis(target).catch().resolve()\n    if result.is_ok():\n        analysis_result = result.unwrap()\n    else:\n        err = result.unwrap_err()\n'})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"lazycontextbuild_artifact",children:"LazyContext.build_artifact"}),"\n",(0,r.jsx)("pre",{class:"language-python",children:(0,r.jsxs)("code",{children:["def LazyContext.build_artifact(\nartifact: ",(0,r.jsx)(i.default,{to:"/docs/api/build/PromiseArtifact",children:"Artifact"}),",\n/,\n) -> ",(0,r.jsx)(i.default,{to:"/docs/api/bxl/Lazy",children:"bxl.Lazy"})]})}),"\n",(0,r.jsxs)(t.p,{children:["Build the given artifact, but it will not materialize the artifact. If the artifact need to be materialized, call ",(0,r.jsx)(t.code,{children:"ctx.output.ensure"})," for the resolved value to defer materialization of the artifact."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Attention"}),": This api does not accept declared artifact. If you want to materialize a declared artifact, use ",(0,r.jsx)(t.code,{children:"ctx.output.ensure"}),"."]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"lazycontextconfigured_target_node",children:"LazyContext.configured_target_node"}),"\n",(0,r.jsx)("pre",{class:"language-python",children:(0,r.jsxs)("code",{children:["def LazyContext.configured_target_node(\nexpr: ",(0,r.jsx)(i.default,{to:"/docs/api/build/ConfiguredTargetLabel",children:"ConfiguredTargetLabel"})," | ",(0,r.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})," | ",(0,r.jsx)(i.default,{to:"/docs/api/bxl/ConfiguredTargetNode",children:"bxl.ConfiguredTargetNode"})," | ",(0,r.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetNode",children:"bxl.UnconfiguredTargetNode"})," | ",(0,r.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"}),",\n/,\n*,\ntarget_platform: None | ",(0,r.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})," | ",(0,r.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"})," = ...,\nmodifiers: list[",(0,r.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"}),"] = [],\n) -> ",(0,r.jsx)(i.default,{to:"/docs/api/bxl/Lazy",children:"bxl.Lazy"})]})}),"\n",(0,r.jsxs)(t.p,{children:["Gets the configured target node for the ",(0,r.jsx)(t.code,{children:"expr"}),". If given a string target pattern, it will resolve to a target set of configured target nodes. it also accepts an optional ",(0,r.jsx)(t.code,{children:"target_platform"})," and an optional modifiers list which is used to resolve configurations of any unconfigured target nodes. The ",(0,r.jsx)(t.code,{children:"target_platform"})," is either a string that can be parsed as a target label, or a target label."]}),"\n",(0,r.jsxs)(t.p,{children:["The given ",(0,r.jsx)(t.code,{children:"expr"})," is either:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"a single string that is a target or a target pattern."}),"\n",(0,r.jsx)(t.li,{children:"a single target node or label, configured or unconfigured"}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["Note that this function does not accept ",(0,r.jsx)(t.code,{children:"ConfiguredProviderLabel"})," (which is a configured provider label), since this\nis the label of a subtarget. You can get the underlying configured target label on the ",(0,r.jsx)(t.code,{children:"Label"}),"\nusing ",(0,r.jsx)(t.code,{children:"configured_targets()"})," (ex: ",(0,r.jsx)(t.code,{children:"my_label.configured_target()"}),")."]}),"\n",(0,r.jsxs)(t.p,{children:["This returns either a target set of ",(0,r.jsx)(t.code,{children:"ConfiguredTargetNode"}),"s if the given ",(0,r.jsx)(t.code,{children:"expr"})," is a target pattern string,\nelse a single ",(0,r.jsx)(t.code,{children:"ConfiguredTargetNode"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["When the given a target pattern (returns the target set), for the incompatible targets, it will print the warning message of these incompatible targets.\nElse (returns a single ",(0,r.jsx)(t.code,{children:"ConfiguredTargetNode"}),"), it will raise an error if incompatible when resolve. Use ",(0,r.jsx)(t.code,{children:"Lazy.catch()"})," to catch the error."]}),"\n",(0,r.jsx)(t.p,{children:"Example:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'def _impl(ctx):\n    # returns a single `ConfiguredTargetNode`\n    node = ctx.lazy.configured_target_node("cell//path/to:target").resolve()\n\n    # returns a target set of `ConfiguredTargetNode`s\n    target_set = ctx.lazy.configured_target_node("cell//path/to:").resolve()\n'})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"lazycontextcquery",children:"LazyContext.cquery"}),"\n",(0,r.jsx)("pre",{class:"language-python",children:(0,r.jsxs)("code",{children:["def LazyContext.cquery(\n*,\ntarget_platform: None | ",(0,r.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})," | ",(0,r.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"})," = ...,\nmodifiers: list[",(0,r.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"}),"] = [],\n) -> ",(0,r.jsx)(i.default,{to:"/docs/api/bxl/LazyCqueryContext",children:"bxl.LazyCqueryContext"})]})}),"\n",(0,r.jsx)(t.p,{children:"Gets the lazy cquery context."}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"lazycontextjoin",children:"LazyContext.join"}),"\n",(0,r.jsx)("pre",{class:"language-python",children:(0,r.jsxs)("code",{children:["def LazyContext.join(\nlazy0: ",(0,r.jsx)(i.default,{to:"/docs/api/bxl/Lazy",children:"bxl.Lazy"}),",\nlazy1: ",(0,r.jsx)(i.default,{to:"/docs/api/bxl/Lazy",children:"bxl.Lazy"}),",\n/,\n) -> ",(0,r.jsx)(i.default,{to:"/docs/api/bxl/Lazy",children:"bxl.Lazy"})]})}),"\n",(0,r.jsx)(t.p,{children:"Join two lazy operations into a single operation that can be evaluated."}),"\n",(0,r.jsx)(t.p,{children:"Example:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"def _impl(ctx):\n    ...\n    joined = ctx.lazy.join(ctx.lazy.analysis(t1), ctx.lazy.analysis(t2))\n    (res1, res2) = joined.resolve()\n    ctx.output.print(res1)\n    ctx.output.print(res2)\n"})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"lazycontextjoin_all",children:"LazyContext.join_all"}),"\n",(0,r.jsx)("pre",{class:"language-python",children:(0,r.jsxs)("code",{children:["def LazyContext.join_all(\noperations: list[",(0,r.jsx)(i.default,{to:"/docs/api/bxl/Lazy",children:"bxl.Lazy"}),"],\n/,\n) -> ",(0,r.jsx)(i.default,{to:"/docs/api/bxl/Lazy",children:"bxl.Lazy"})]})}),"\n",(0,r.jsxs)(t.p,{children:["Join a list of lazy operations into a single operation that can be evaluated. This is useful when you want to evaluate multiple operations in parallel. Using ",(0,r.jsx)(t.code,{children:".catch().resolve()"})," can catch errors for the individual operations."]}),"\n",(0,r.jsx)(t.p,{children:"Example:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"def _impl(ctx):\n    ...\n    joined = ctx.lazy.join_all([ctx.lazy.analysis(t) for t in targets])\n    analysis_results = joined.resolve()\n    ctx.output.print(analysis_results)\n"})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"lazycontextunconfigured_target_node",children:"LazyContext.unconfigured_target_node"}),"\n",(0,r.jsx)("pre",{class:"language-python",children:(0,r.jsxs)("code",{children:["def LazyContext.unconfigured_target_node(\nexpr: ",(0,r.jsx)(i.default,{to:"/docs/api/build/TargetLabel",children:"TargetLabel"})," | ",(0,r.jsx)(i.default,{to:"/docs/api/bxl/UnconfiguredTargetNode",children:"bxl.UnconfiguredTargetNode"})," | ",(0,r.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"}),",\n/,\n) -> ",(0,r.jsx)(i.default,{to:"/docs/api/bxl/Lazy",children:"bxl.Lazy"})]})}),"\n",(0,r.jsxs)(t.p,{children:["Gets the unconfigured target node(s) for the ",(0,r.jsx)(t.code,{children:"expr"})]}),"\n",(0,r.jsxs)(t.p,{children:["The given ",(0,r.jsx)(t.code,{children:"expr"})," is either:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"a single string that is a target or a target pattern."}),"\n",(0,r.jsx)(t.li,{children:"a single unconfigured target node or label"}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["This returns either a target set of ",(0,r.jsx)(t.code,{children:"UnconfiguredTargetNode"}),"s if the given ",(0,r.jsx)(t.code,{children:"expr"})," is a target pattern string,\nelse a single ",(0,r.jsx)(t.code,{children:"UnconfiguredTargetNode"}),"."]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"lazycontextunconfigured_target_nodes_keep_going",children:"LazyContext.unconfigured_target_nodes_keep_going"}),"\n",(0,r.jsx)("pre",{class:"language-python",children:(0,r.jsxs)("code",{children:["def LazyContext.unconfigured_target_nodes_keep_going(\npattern: ",(0,r.jsx)(i.default,{to:"/docs/api/starlark/str",children:"str"}),",\n/,\n) -> ",(0,r.jsx)(i.default,{to:"/docs/api/bxl/Lazy",children:"bxl.Lazy"})]})}),"\n",(0,r.jsxs)(t.p,{children:["Gets the unconfigured target nodes for the given target pattern with keep-going behavior. This method will continue processing even when errors are encountered, similar to ",(0,r.jsx)(t.code,{children:"buck2 targets --keep-going"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["Unlike ",(0,r.jsx)(t.code,{children:"ctx.lazy.unconfigured_target_node"}),", this method accepts only a single string target pattern\nand returns a lazy operation that resolves to a tuple containing both successful results and errors,\nallowing you to handle failures gracefully rather than failing fast."]}),"\n",(0,r.jsxs)(t.p,{children:["The given ",(0,r.jsx)(t.code,{children:"pattern"})," must be a string that is a valid target pattern, such as:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:'"//path/to:target"'})," - A specific target"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:'"//path/to:"'})," - All targets in a package"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:'"//path/to/..."'})," - All targets in a path"]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["This returns a lazy operation (",(0,r.jsx)(t.code,{children:"bxl.Lazy[(UnconfiguredTargetSet, dict[PackagePath, bxl.Error])]"}),") that resolves to a tuple where:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["First element: A ",(0,r.jsx)(t.code,{children:"UnconfiguredTargetSet"})," containing successfully loaded unconfigured target nodes"]}),"\n",(0,r.jsxs)(t.li,{children:["Second element: A dict mapping ",(0,r.jsx)(t.code,{children:"PackagePath"})," to ",(0,r.jsx)(t.code,{children:"Error"})," for packages that failed to load"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Sample usage:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'def _impl_keep_going(ctx):\n    lazy_result = ctx.lazy.unconfigured_target_nodes_keep_going("//my/package/...")\n    success_targets, error_map = lazy_result.resolve()\n\n    # Process successful targets\n    for target in success_targets:\n        ctx.output.print(f"Successfully loaded: {target.label}")\n\n    # Handle errors\n    for package_path, error in error_map.items():\n        ctx.output.print(f"Failed to load package {package_path}: {error}")\n'})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"lazycontextuquery",children:"LazyContext.uquery"}),"\n",(0,r.jsx)("pre",{class:"language-python",children:(0,r.jsxs)("code",{children:["def LazyContext.uquery(\n) -> ",(0,r.jsx)(i.default,{to:"/docs/api/bxl/LazyUqueryContext",children:"bxl.LazyUqueryContext"})]})}),"\n",(0,r.jsx)(t.p,{children:"Gets the lazy uquery context."})]})}function h(e={}){const{wrapper:t}={...(0,l.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(x,{...e})}):x(e)}}}]);