"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[24605],{28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>d});var i=s(96540);const o={},t=i.createContext(o);function r(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(t.Provider,{value:n},e.children)}},76297:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"developers/starlark/environment","title":"Environments","description":"Some of the information within this page is outdated. However, the explanation","source":"@site/../docs/developers/starlark/environment.generated.md","sourceDirName":"developers/starlark","slug":"/developers/starlark/environment","permalink":"/docs/developers/starlark/environment","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"environment"},"sidebar":"main","previous":{"title":"Finding Commands That Buck2 Ran","permalink":"/docs/developers/what-ran"},"next":{"title":"A Moving Garbage Collector","permalink":"/docs/developers/starlark/gc"}}');var o=s(74848),t=s(28453);const r={id:"environment"},d="Environments",l={},a=[{value:"Global Environment",id:"global-environment",level:2},{value:"Slots",id:"slots",level:2},{value:"Module Environment",id:"module-environment",level:2},{value:"Function Environment",id:"function-environment",level:2},{value:"Optimisations",id:"optimisations",level:2}];function c(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"environments",children:"Environments"})}),"\n",(0,o.jsx)(n.admonition,{type:"warning",children:(0,o.jsx)(n.p,{children:"Some of the information within this page is outdated. However, the explanation\nof the problem, and thought process behind it, remains useful. The storage of\nvalues is similar but implemented using different types."})}),"\n",(0,o.jsxs)(n.p,{children:["Starlark (with a nested ",(0,o.jsx)(n.code,{children:"def"}),") has a series of environments that may be active\nduring an evaluation, as illustrated in the following example:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"x = []\ndef foo():\n    y = True\n    def bar():\n        z = 1\n        list.append(x, 1)\n"})}),"\n",(0,o.jsx)(n.p,{children:"The above example features the following environments:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Global environment - defining things like ",(0,o.jsx)(n.code,{children:"list.append"})]}),"\n",(0,o.jsxs)(n.li,{children:["Module environment - defining ",(0,o.jsx)(n.code,{children:"x"})]}),"\n",(0,o.jsxs)(n.li,{children:["Environment of ",(0,o.jsx)(n.code,{children:"foo"})," - defining ",(0,o.jsx)(n.code,{children:"y"})]}),"\n",(0,o.jsxs)(n.li,{children:["Environment of ",(0,o.jsx)(n.code,{children:"bar"})," - defining ",(0,o.jsx)(n.code,{children:"z"})]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["A scope can ",(0,o.jsx)(n.em,{children:"access"})," variables defined above it, and often ",(0,o.jsx)(n.em,{children:"mutate"})," them, but\nnot ",(0,o.jsx)(n.em,{children:"assign"})," them."]}),"\n",(0,o.jsx)(n.p,{children:"To unpack that:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["From the statements inside ",(0,o.jsx)(n.code,{children:"bar"}),", you can access ",(0,o.jsx)(n.code,{children:"list.append"}),", ",(0,o.jsx)(n.code,{children:"x"}),", ",(0,o.jsx)(n.code,{children:"y"}),", and\n",(0,o.jsx)(n.code,{children:"z"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["From inside ",(0,o.jsx)(n.code,{children:"bar"}),", you can mutate the variables to be accessed with statements\nlike ",(0,o.jsx)(n.code,{children:"list.append(x, 1)"})," (which may also be termed ",(0,o.jsx)(n.code,{children:"x.append(1)"}),").","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["However, before this module is imported by another module, all of its\nexports become ",(0,o.jsx)(n.em,{children:"frozen"}),", which means it isn't possible to mutate a global\nlist, and if ",(0,o.jsx)(n.code,{children:"foo"})," is called from a different module, then ",(0,o.jsx)(n.code,{children:"x"})," can't be\nmodified."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["If ",(0,o.jsx)(n.code,{children:"bar"})," does ",(0,o.jsx)(n.code,{children:"x = 1"})," that defines a local variable ",(0,o.jsx)(n.code,{children:"x"})," in the function ",(0,o.jsx)(n.code,{children:"bar"}),",\nshadowing the global ",(0,o.jsx)(n.code,{children:"x"}),". As a consequence, you cannot assign to variables\ndefined in an outer scope."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Note that assignment ",(0,o.jsx)(n.em,{children:"after"}),", or even ",(0,o.jsx)(n.em,{children:"in"})," non-executed conditional branches,\nintroduces a local variable."]}),"\n",(0,o.jsx)(n.p,{children:"For example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"x = 1\ndef f():\n    print(x)\n    if False:\n        x = 2\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In the above code, on executing ",(0,o.jsx)(n.code,{children:"f()"}),", it would complain that ",(0,o.jsx)(n.code,{children:"x"})," is referenced\nbefore assignment, as the assignment ",(0,o.jsx)(n.code,{children:"x = 2"})," makes ",(0,o.jsx)(n.code,{children:"x"})," a local variable."]}),"\n",(0,o.jsx)(n.p,{children:"The rest of this document outlines the various types of environments, how they\nare accessed, and how they are updated."}),"\n",(0,o.jsx)(n.h2,{id:"global-environment",children:"Global Environment"}),"\n",(0,o.jsxs)(n.p,{children:["The global environment is always frozen and consists of ",(0,o.jsx)(n.em,{children:"functions"})," and\n",(0,o.jsx)(n.em,{children:"type-values"}),". All things in the global environment are accessed by name."]}),"\n",(0,o.jsxs)(n.p,{children:["Type-values are things like ",(0,o.jsx)(n.code,{children:"list.append"}),", which is used when you do either\n",(0,o.jsx)(n.code,{children:"list.append(xs, 1)"})," or ",(0,o.jsx)(n.code,{children:"xs.append(1)"}),", assuming ",(0,o.jsx)(n.code,{children:"xs"})," is of type ",(0,o.jsx)(n.code,{children:"list"}),". The\navailable methods for a type can be queried (for example, ",(0,o.jsx)(n.code,{children:"dir(list)"}),")."]}),"\n",(0,o.jsxs)(n.p,{children:["There are also global functions, such as ",(0,o.jsx)(n.code,{children:"len"}),", ",(0,o.jsx)(n.code,{children:"range"}),", and ",(0,o.jsx)(n.code,{children:"str"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"slots",children:"Slots"}),"\n",(0,o.jsx)(n.p,{children:"To optimise evaluation, all variables are accessed by integers, which are known\nas 'slots'. Many variables can be converted to slots statically during\ncompilation, and those which can't have their slot looked up by name at runtime."}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"Slots"})," data type is defined as:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"enum Slots {\n    Frozen(FrozenSlots),\n    Slots(Rc<RefCell<Vec<Option<Value>>>>),\n}\n\nstruct FrozenSlots(Arc<Vec<Option<FrozenValue>>>);\n"})}),"\n",(0,o.jsx)(n.p,{children:"As featured in the above code:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["A set of slots are either ",(0,o.jsx)(n.code,{children:"Frozen"}),", which came from another module behind\n",(0,o.jsx)(n.code,{children:"Arc"})," or just normal ",(0,o.jsx)(n.code,{children:"Slots"}),", which can be manipulated by the current scope\n(behind a ",(0,o.jsx)(n.code,{children:"Rc"}),"/",(0,o.jsx)(n.code,{children:"RefCell"})," for single-threaded use and mutation)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Vec"})," is accessed by the slot index."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Option"})," refers to whether the slot has been assigned yet (to detect variables\nreferenced before assignment)."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"module-environment",children:"Module Environment"}),"\n",(0,o.jsxs)(n.p,{children:["The module environment is where the module executes, namely where ",(0,o.jsx)(n.code,{children:"x"})," is defined\nabove. The module environment can have values added in the following\nstandards-conforming ways:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Assignment statements (such as ",(0,o.jsx)(n.code,{children:"x = 1"})," or ",(0,o.jsx)(n.code,{children:"x += 1"}),")."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"For"})," loops (such as the ",(0,o.jsx)(n.code,{children:"x"})," in ",(0,o.jsx)(n.code,{children:"for x in []:"}),")."]}),"\n",(0,o.jsxs)(n.li,{children:["Via the ",(0,o.jsx)(n.code,{children:'load("a.bzl", "foo")'}),", which imports ",(0,o.jsx)(n.code,{children:"foo"})," frozen."]}),"\n",(0,o.jsxs)(n.li,{children:["Via ",(0,o.jsx)(n.code,{children:"def foo():"}),", which defines ",(0,o.jsx)(n.code,{children:"foo"})," in the module environment. Whether a\n",(0,o.jsx)(n.code,{children:"def"})," is frozen or not, when it's executed, its local variables are not\nfrozen."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"In addition, two non-standards-conforming ways of defining variables are\nsupported:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Some modules can be injected as bindings in advance. Given a module ",(0,o.jsx)(n.code,{children:"foo"})," that\nis injected, all the bindings of ",(0,o.jsx)(n.code,{children:"foo"})," will be inserted in this module as\nfrozen."]}),"\n",(0,o.jsxs)(n.li,{children:["The function ",(0,o.jsx)(n.code,{children:"load_symbols"})," injects a dictionary of bindings into the module\nenvironment."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Note that a module has a fixed set of variables (from the standards-conforming\nways), a pre-execution set (from the injections) and yet more variables at\nruntime (via ",(0,o.jsx)(n.code,{children:"load_symbols"}),"). To support that structure, the mapping from name\nto slot index is tracked in a struct:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"enum Names {\n    Frozen(FrozenNames),\n    Names(Rc<RefCell<HashMap<String, usize>>>),\n}\nstruct FrozenNames(Arc<HashMap<String, usize>>);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Each name is given an entry in the map with an increasing slot index. A name\nwill only be assigned a slot once, reusing it thereafter. A corresponding\n",(0,o.jsx)(n.code,{children:"Slots"})," data type provides the values associated with those names."]}),"\n",(0,o.jsxs)(n.p,{children:["Importantly, the ",(0,o.jsx)(n.code,{children:"Slots"})," can be extended at runtime by the ",(0,o.jsx)(n.code,{children:"load_symbols"}),"\nfunction. As with ",(0,o.jsx)(n.code,{children:"Slots"}),", you can either share things behind an ",(0,o.jsx)(n.code,{children:"Arc"})," or mutate\nthem behind an ",(0,o.jsx)(n.code,{children:"Rc"}),"/",(0,o.jsx)(n.code,{children:"RefCell"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"function-environment",children:"Function Environment"}),"\n",(0,o.jsxs)(n.p,{children:["A function can have variables introduced via assignments, ",(0,o.jsx)(n.code,{children:"for"})," loops, and\nparameters. No additional variables can be discovered at runtime, so all names\ncan be erased at compile time."]}),"\n",(0,o.jsx)(n.p,{children:"A function can also access variables from the functions it is statically nested\nwithin, and from the variables at the root of the module. To support this\nstructure, at runtime we pass around the context, defined as:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"struct Context {\n    names: Names,\n    slots: Vec<Slots>,\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"The above code contains the mapping of names for the module and the slots for\nthe module and each function."}),"\n",(0,o.jsxs)(n.p,{children:["When executed, the inner-most ",(0,o.jsx)(n.code,{children:"Slots"})," (at the end of ",(0,o.jsx)(n.code,{children:"slots:"}),") will never be\nfrozen, as that represents the local variables: but any other may be."]}),"\n",(0,o.jsxs)(n.p,{children:["When a function value is captured in a frozen module, use ",(0,o.jsx)(n.code,{children:"FrozenContext"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"struct FrozenContext {\n    names: FrozenNames,\n    slots: Vec<FrozenSlots>,\n}\n\n## List comprehension environments\n\nA list comprehension can be defined as:\n\n```python\n[x for x in [1,2,3]]\n"})}),"\n",(0,o.jsx)(n.p,{children:"In the above code:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The statement defines a variable ",(0,o.jsx)(n.code,{children:"x"})," that is immediately initialised and\nshadows any other variables ",(0,o.jsx)(n.code,{children:"x"})," in scope."]}),"\n",(0,o.jsxs)(n.li,{children:["The variable ",(0,o.jsx)(n.code,{children:"x"})," cannot be assigned to, other than in the list comprehension,\nas it only lives inside the comprehension and the comprehension does not\npermit assignment statements (only expressions). Such names are not available\nat the top-level, even when defined in the root of a module."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["List comprehensions are implemented by adding additional entries into the\n",(0,o.jsx)(n.code,{children:"Slots"})," data type. Even when added at the root of a module, such names are not\nadded to ",(0,o.jsx)(n.code,{children:"Names"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"optimisations",children:"Optimisations"}),"\n",(0,o.jsx)(n.p,{children:"There are a number of optimisations made to the scheme:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["When freezing a ",(0,o.jsx)(n.code,{children:"Names"})," or ",(0,o.jsx)(n.code,{children:"Slots"})," structure, it's important to only freeze a\nparticular mutable variant once, or you duplicate memory unnecessarily.\nTherefore, the ",(0,o.jsx)(n.code,{children:"Slots"})," to be ",(0,o.jsx)(n.code,{children:"Rc<RefCell<(_, Option<FrozenSlots>)>>"})," are\naugmented, and, similarly, the ",(0,o.jsx)(n.code,{children:"Names"}),".","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["When ",(0,o.jsx)(n.code,{children:"freeze"})," is called, the original value is consumed, and the ",(0,o.jsx)(n.code,{children:"Some"}),"\nvariant is added."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Note"}),": it is unsafe to ever access the slots after the ",(0,o.jsx)(n.code,{children:"freeze"}),"."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["Programs can only assign to the inner-most ",(0,o.jsx)(n.code,{children:"Slots"}),", and that slots must always\nbe mutable. Therefore, define a local ",(0,o.jsx)(n.code,{children:"Slots"})," that is always mutable, and a\nseparate AST node for referring to it.","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["For modules, it is important that this mutable local ",(0,o.jsx)(n.code,{children:"Slots"})," is ",(0,o.jsx)(n.em,{children:"also"})," in\nscope since the scope is used to retrieve unknown variables."]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}}}]);