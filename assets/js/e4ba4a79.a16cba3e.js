"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[77598],{28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var a=n(96540);const i={},s=a.createContext(i);function r(e){const t=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:t},e.children)}},76607:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>o,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"developers/architecture/buck2","title":"Architectural Model","description":"High-level Overview","source":"@site/../docs/developers/architecture/buck2.md","sourceDirName":"developers/architecture","slug":"/developers/architecture/buck2","permalink":"/docs/developers/architecture/buck2","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"buck2","title":"Architectural Model"},"sidebar":"main","previous":{"title":"FAQs","permalink":"/docs/bxl/faq"},"next":{"title":"Buck1 vs Buck2","permalink":"/docs/developers/architecture/buck1_vs_buck2"}}');var i=n(74848),s=n(28453),r=n(29030);const o={id:"buck2",title:"Architectural Model"},c=void 0,l={},h=[{value:"High-level Overview",id:"high-level-overview",level:2},{value:"Execution Model",id:"execution-model",level:2},{value:"State 0 - Build Files",id:"state-0---build-files",level:3},{value:"Phase A: Evaluation",id:"phase-a-evaluation",level:3},{value:"State 1 - Unconfigured Target Graph is generated",id:"state-1---unconfigured-target-graph-is-generated",level:3},{value:"Phase B: Configuration",id:"phase-b-configuration",level:3},{value:"State 2 - Configured Target Graph is generated",id:"state-2---configured-target-graph-is-generated",level:3},{value:"Phase C: Analysis",id:"phase-c-analysis",level:3},{value:"State 3 - Action Graph and Providers are generated",id:"state-3---action-graph-and-providers-are-generated",level:3},{value:"Phase D: Execute",id:"phase-d-execute",level:3},{value:"State 4 - Build outputs are generated",id:"state-4---build-outputs-are-generated",level:3},{value:"Phase E: Execute tests",id:"phase-e-execute-tests",level:3}];function d(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",strong:"strong",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"high-level-overview",children:"High-level Overview"}),"\n",(0,i.jsx)(t.p,{children:"Buck2 is a build system whose core is written in Rust. Starlark, which is a\ndeterministic, immutable version of Python, is used to extend the Buck2 build\nsystem, enabling Buck2 to be language-agnostic."}),"\n",(0,i.jsxs)(t.p,{children:["The high-level flow starts with a user creating a build file (a ",(0,i.jsx)(t.code,{children:"BUCK"})," file)\ncontaining one or more targets, which is specified by the target label, its\ninputs (sources, attributes, configurations, and dependencies), and the type of\nmacro or rule to use."]}),"\n",(0,i.jsxs)(t.p,{children:["Briefly, a macro is a wrapper around a rule, which runs necessary commands to\ngenerate what\u2019s needed for a target (for example, for a ",(0,i.jsx)(t.code,{children:"cxx_binary"})," target,\ngenerate the header map and run necessary ",(0,i.jsx)(t.code,{children:"clang"})," commands). Macros can be used\nto reduce boilerplate code for users (such as to supply the same set of\nattributes for a rule for all targets). Macros and rules are both written in\nStarlark and are specified by input sources, attributes, and the implementation\nfunction."]}),"\n",(0,i.jsxs)(t.p,{children:["If the target type is a macro, then the macro will fill in some details (for\nexample, for a ",(0,i.jsx)(t.code,{children:"cxx_binary"})," target, these are the compilation, debug flags to\nuse, this is the ",(0,i.jsx)(t.code,{children:"clang"})," to use). If the target type is a rule, then the macro\nlayer is skipped altogether."]}),"\n",(0,i.jsx)(t.p,{children:"This is all orchestrated by the core, which performs operations such as\nexecuting Buck2 CLI args, generating/updating the dependency graph (which\ncontains the configured target nodes, unconfigured target nodes, action nodes,\namong other types of nodes that all allow for incrementality and execution), and\nmaterializing the artifacts. The core is written in Rust."}),"\n",(0,i.jsx)(t.p,{children:"The following diagram shows the high-level overview."}),"\n",(0,i.jsx)("img",{src:(0,r.default)("/img/buck2_rule_workflow.png"),alt:"justifyContent"}),"\n",(0,i.jsxs)(t.p,{children:["The Buck2 CLI runs in a client process, which sends commands to the Buck2 daemon\nvia gRPC. The daemon goes through several phases after receiving a request from\nthe client: ",(0,i.jsx)(t.strong,{children:"evaluation, configuration, analysis, execution, and\nmaterialization"})," (see ",(0,i.jsx)(t.a,{href:"#execution-model",children:"Execution Model"}),", below). When using\n",(0,i.jsx)(t.code,{children:"buck2 test"}),", there is a final stage for ",(0,i.jsx)(t.strong,{children:"testing"}),". Note that these are the\nphases that a build goes through, but they are not always sequential."]}),"\n",(0,i.jsx)(t.p,{children:"After finishing all phases, the daemon will send the response back to the client\nvia gRPC."}),"\n",(0,i.jsx)(t.h2,{id:"execution-model",children:"Execution Model"}),"\n",(0,i.jsx)(t.p,{children:"The following diagram shows the Execution Model, which consists of 5 phases and\nstates."}),"\n",(0,i.jsx)("img",{src:(0,r.default)("/img/buck2_architecture.png"),alt:"justifyContent"}),"\n",(0,i.jsx)(t.p,{children:"Each of the phases and states shown in the Execution Model, are detailed in the\nfollowing sub-sections."}),"\n",(0,i.jsx)(t.h3,{id:"state-0---build-files",children:"State 0 - Build Files"}),"\n",(0,i.jsxs)(t.p,{children:["Build files (commonly referred to as ",(0,i.jsx)(t.code,{children:"BUCK"})," files, their default name) are the\nmain input to Buck2 and are syntactically Python."]}),"\n",(0,i.jsx)(t.p,{children:"Each build file is uniquely identified by the directory in which it's located.\nSince all build files have the same name, there cannot be two build files in the\nsame directory. This is usually represented as the relative path from the root\nof the project (the directory where the .buckconfig file is)."}),"\n",(0,i.jsx)(t.p,{children:"Each build file has a set of targets. These describe the things the user wants\nBuck2 to know about. Each target has a type and a set of named attributes,\nincluding at least a name (also known as the label) identifying it. Additional\nattributes depend on the type of the target."}),"\n",(0,i.jsx)(t.h3,{id:"phase-a-evaluation",children:"Phase A: Evaluation"}),"\n",(0,i.jsx)(t.p,{children:"First, Buck2 evaluates a build file, and then constructs an unconfigured target\ngraph."}),"\n",(0,i.jsx)(t.p,{children:"Buck2 performs directory listings to discover packages, then evaluates the build\nfiles that were found, expands any macros detected into their underlying rules,\nand then will take rule attributes and convert them from Starlark to Rust types\nto construct a target node, and insert it into the unconfigured target graph,\nwhich is a smaller portion of Buck2\u2019s larger dependency graph. The target node\nconsists of a reference to rule implementation, and the set of attributes and\nsources."}),"\n",(0,i.jsx)(t.p,{children:"The result of evaluation is a list of targets read from the build file mapped to\na target node in Buck2 unconfigured target graph."}),"\n",(0,i.jsx)(t.h3,{id:"state-1---unconfigured-target-graph-is-generated",children:"State 1 - Unconfigured Target Graph is generated"}),"\n",(0,i.jsx)(t.p,{children:"At this point, the unconfigured target graph is available for the next stage of\ntransformation, which is to configure the target nodes within the graph."}),"\n",(0,i.jsx)(t.h3,{id:"phase-b-configuration",children:"Phase B: Configuration"}),"\n",(0,i.jsx)(t.p,{children:"At the end of evaluation, the target nodes are not yet configured. Configuration\nmeans applying a list of constraints (such as resolving selects to specify the\nright CPU) to make sure the target can be run where it needs to. This is also\nknown as target platform resolution, and can be configured within the target,\nthe buckconfig, propagated from dependencies, or passed into the CLI. After\napplying configurations, the target nodes are transformed into configured target\nnodes within the Buck2 configured target graph, which is a smaller portion of\nBuck2\u2019s larger dependency graph."}),"\n",(0,i.jsx)(t.h3,{id:"state-2---configured-target-graph-is-generated",children:"State 2 - Configured Target Graph is generated"}),"\n",(0,i.jsx)(t.p,{children:"At this point, the configured target graph is available for the analysis stage\nto generate the action graph."}),"\n",(0,i.jsx)(t.h3,{id:"phase-c-analysis",children:"Phase C: Analysis"}),"\n",(0,i.jsxs)(t.p,{children:["In the analysis phase, Buck2 constructs a context object (ctx) which contains\nrelevant information (such as attributes pulled from the configuration stage),\nall converted into Starlark types and made available to the rule. For example,\nthe target\u2019s dependencies are turned into a ",(0,i.jsx)(t.code,{children:"ProviderCollection"}),", source files\nare converted into ",(0,i.jsx)(t.code,{children:"StarlarkArtifacts"}),", and String attributes are turned into a\n",(0,i.jsx)(t.code,{children:"StarlarkString"}),". This ctx object is backed by Buck2\u2019s dependency graph for\ncomputation and rules use it to tell Buck2 to run actions, create dynamic\nactions, or create new files."]}),"\n",(0,i.jsx)(t.p,{children:"The rule will return a list of providers, which is data that the rule wants to\nexpose to its dependents (that is, can flow through the dependency graph), such\nas output artifact information (such as file paths and file hashes). Providers\ncould be actions, source files, or attributes. Within the returned list,\nDefaultInfo always needs to be returned, which indicates what the default\noutputs are. Some other common built-in providers include RunInfo, TestInfo, and\nInstallInfo."}),"\n",(0,i.jsx)(t.p,{children:"The end result is a list of providers and actions (inserted into the action\ngraph) that Buck2 needs to execute to produce the desired outputs, known as\n'bound artifacts'."}),"\n",(0,i.jsx)(t.h3,{id:"state-3---action-graph-and-providers-are-generated",children:"State 3 - Action Graph and Providers are generated"}),"\n",(0,i.jsx)(t.p,{children:"At this point, the action graph and providers are available to be processed by\nthe execution stage."}),"\n",(0,i.jsx)(t.h3,{id:"phase-d-execute",children:"Phase D: Execute"}),"\n",(0,i.jsx)(t.p,{children:"Execution is where Buck2 takes all the providers (input files from the targets,\nargs from the command line), runs the actions, and then outputs the computed\nresults. The critical path is the theoretical lower bound for the duration of a\nbuild, which are the slowest set of actions."}),"\n",(0,i.jsx)(t.p,{children:"Buck2 can be run locally or on remote execution, or in a hybrid manner."}),"\n",(0,i.jsx)(t.p,{children:"For each action, a digest is created which is a hash of an action's command and\nall its inputs. Buck2 then checks if there is a result cached within RE for an\naction with a given digest."}),"\n",(0,i.jsxs)(t.p,{children:["If there is a cache hit, Buck2 does not need to run the command for the action.\nInstead, the RE returns the output action digest. This digest can be used to\ndownload the actual output artifacts at a later time. This is known as the ",(0,i.jsx)(t.strong,{children:"RE\naction cache"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["If there is a cache miss, the action needs to be run either remotely or locally.\nIf Buck2 decides to run the action remotely, it will first upload all of the\naction's inputs that are missing from the RE's content addressable storage. If\nBuck2 decides to run the action locally, it will first download and materialize\nin ",(0,i.jsx)(t.code,{children:"buck-out"})," all of the action's inputs. These inputs might be outputs of other\nactions and are stored in RE's content addressable storage but are missing on\nthe local machine. Only after those steps will Buck2 schedule the action for\nactual execution."]}),"\n",(0,i.jsxs)(t.p,{children:["Buck2 can also decide to run local and remote execution simultaneously (a\nprocess known as racing), and use the result of whichever action finishes first\nto speed up performance. This strategy is known as ",(0,i.jsx)(t.strong,{children:"hybrid execution"}),'."']}),"\n",(0,i.jsxs)(t.p,{children:["Materialization of action outputs (which involves downloading and placing them\nin the correct location in ",(0,i.jsx)(t.code,{children:"buck-out"}),") can be done immediately after the action\nhas finished executing. Alternatively, it can be deferred until it is actually\nneeded for the local execution of another action. There are various\nconfigurations that a user can set to control how this materialization is\nhandled."]}),"\n",(0,i.jsx)(t.h3,{id:"state-4---build-outputs-are-generated",children:"State 4 - Build outputs are generated"}),"\n",(0,i.jsx)(t.p,{children:"At this point, the build is complete."}),"\n",(0,i.jsxs)(t.p,{children:["If a user ran ",(0,i.jsx)(t.code,{children:"buck2 test"}),", then there is a final transformation for Buck2 to\nconstruct a command for TPX to execute the actual test."]}),"\n",(0,i.jsx)(t.h3,{id:"phase-e-execute-tests",children:"Phase E: Execute tests"}),"\n",(0,i.jsxs)(t.p,{children:["For more detail on testing, review\n",(0,i.jsx)(t.a,{href:"/docs/rule_authors/test_execution",children:"Test Execution"}),"."]})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);