"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[59579],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var i=t(96540);const r={},s=i.createContext(r);function a(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:n},e.children)}},79104:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"rfcs/bxl-streaming","title":"[RFC][BXL] Streamed Output in BXL","description":"1. Overview and Context","source":"@site/../docs/rfcs/bxl-streaming.md","sourceDirName":"rfcs","slug":"/rfcs/bxl-streaming","permalink":"/docs/rfcs/bxl-streaming","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{}}');var r=t(74848),s=t(28453);const a={},l="[RFC][BXL] Streamed Output in BXL",o={},d=[{value:"1. Overview and Context",id:"1-overview-and-context",level:2},{value:"2. Goal",id:"2-goal",level:2},{value:"3. Proposed API",id:"3-proposed-api",level:2},{value:"4. Implementation Sketch",id:"4-implementation-sketch",level:2},{value:"5. Alternative Solutions",id:"5-alternative-solutions",level:2},{value:"6. Potential Future Work",id:"6-potential-future-work",level:2}];function c(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"rfcbxl-streamed-output-in-bxl",children:"[RFC][BXL] Streamed Output in BXL"})}),"\n",(0,r.jsx)(n.h2,{id:"1-overview-and-context",children:"1. Overview and Context"}),"\n",(0,r.jsxs)(n.p,{children:["BXL scripts can primarily be divided into ",(0,r.jsx)(n.strong,{children:"two phases"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Phase 1 (Evaluation)"}),": The BXL script is interpreted. During this phase,\ncalls to ",(0,r.jsx)(n.code,{children:"ctx.output.ensure(...)"})," register artifacts that should be\nmaterialized later, but the actual materialization does not happen yet."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Phase 2 (Materialization)"}),": It materializes all artifacts previously\nregistered via ",(0,r.jsx)(n.code,{children:"ctx.output.ensure(...)"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Under the current model, all ",(0,r.jsx)(n.code,{children:"ctx.output.print(...)"})," produce their output only\nat the end of Phase 2 (i.e., after all artifacts have been materialized). This\nmake bxl users cannot get the output from bxl as soon as it is ready."]}),"\n",(0,r.jsx)(n.p,{children:"In some use cases, streaming output is desired:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Users might want partial output or intermediate query results right away,\nrather than waiting for the entire BXL script to finish."}),"\n",(0,r.jsx)(n.li,{children:"Users might want an immediate path of an artifact as soon as it is\nmaterialized, to trigger a follow-up action in a more interactive or\nincremental workflow."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"2-goal",children:"2. Goal"}),"\n",(0,r.jsx)(n.p,{children:"We aim to introduce an option that allows streaming output as soon as relevant\nartifacts or other results like query results are ready. Specifically, allow\nusers to output the information that not depends on artifacts immediately in\nPhase 1, and stream the output as relevant artifacts are available in Phase 2."}),"\n",(0,r.jsx)(n.h2,{id:"3-proposed-api",children:"3. Proposed API"}),"\n",(0,r.jsxs)(n.p,{children:["We introduce new apis ",(0,r.jsx)(n.code,{children:"ctx.output.stream/stream_json"})," that would have\n\u201cstreaming\u201d behavior:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'def ctx.output.stream(\n    *args,\n    sep: str = " ",\n    additional_waits: List[bxl.EnsuredArtifact] = []\n) -> None:\n    """\n    Print arguments either immediately (phase 1) or in a streaming manner (phase 2).\n    - If no `EnsuredArtifact` appears in args, it is output immediately during phase 1 evaluation.\n    - If there are EnsuredArtifact(s) (either in `args`\n      or in `additional_waits`), we defer printing until after these artifact(s)\n      have been materialized in phase 2. When all required artifacts\n      are materialized, the relevant string is printed immediately.\n    """\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Case 1: Streaming Behavior When No Artifacts Are Involved"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:'ctx.output.stream("Hello World")'})}),"\n",(0,r.jsx)(n.li,{children:"Evaluated during Phase 1. The message \u201cHello World\u201d is emitted immediately"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Case 2: Streaming Behavior When Artifacts Are Involved"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"args"})," have EnsuredArtifacts or ",(0,r.jsx)(n.code,{children:"additional_waits"})," is not empty."]}),"\n",(0,r.jsx)(n.li,{children:"The print is deferred until those artifacts have all been materalized."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Thus, users can write:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'ensured0 = ctx.output.ensure(my_artifact0)\nensured1 = ctx.output.ensure(my_artifact1)\n\n# Wait for ens_art to be ready, then print\nctx.output.stream("Artifact path:", ensured0, additional_waits=[ensured1])\n\n'})}),"\n",(0,r.jsx)(n.h2,{id:"4-implementation-sketch",children:"4. Implementation Sketch"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Phase 1 (BXL Evaluation)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["When we have ",(0,r.jsx)(n.strong,{children:"Case 1"}),", we will output the string to stdout by\n",(0,r.jsx)(n.code,{children:"PartialResultDispatcher"})," and save the output in the cache file associated\nwith the bxl key."]}),"\n",(0,r.jsxs)(n.li,{children:["If we have ",(0,r.jsx)(n.strong,{children:"Case 2"}),", we will store the output string and related waits on\nartifacts in the result of bxl key."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Phase 2 (Materialization)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"As artifacts materialize, mark them \u201cready.\u201d"}),"\n",(0,r.jsx)(n.li,{children:"After each artifact\u2019s materialization, check which print requests are now\nsatisfied (i.e., all required artifacts are \u201cready\u201d). Those requests are\nimmediately printed to stdout."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["If bxl key is get from cache which means we skip the ",(0,r.jsx)(n.code,{children:"Phase 1"})," and no output\nfrom that phase, get the streaming output cache and print to stdout."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"5-alternative-solutions",children:"5. Alternative Solutions"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Alternative 1: Callback-Based"})," Api would like this"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'def OutputStream.print(\n    *args,\n    sep: str = " ",\n    additional_waits: List[EnsuredArtifact] = [],\n    callback: Optional[Callable[[EnsuredArtifact], None]] = None\n) -> None\n'})}),"\n",(0,r.jsxs)(n.p,{children:["or even attaching a callback directly on ",(0,r.jsx)(n.code,{children:"ctx.output.ensure(...)"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"def OutputStream.ensure(\n    artifact: Artifact,\n    callback: Optional[Callable[[EnsuredArtifact], None]] = None\n) -> EnsuredArtifact:\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"Advantages:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Users can programmatically handle \u201cwhen artifact is ready, do X\u201d in BXL\nscripts, leading to more flexibility."}),"\n",(0,r.jsx)(n.li,{children:"More intuitive to users"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"Downsides:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["When Phase 1 finishes, we do not have BXL runtime in Phase 1. In this case, we\nneed to provide a bxl runtime and provide a ",(0,r.jsx)(n.strong,{children:"limited"})," context to execute\ncallbacks"]}),"\n",(0,r.jsx)(n.li,{children:"More complex to implement and reason about."}),"\n",(0,r.jsx)(n.li,{children:"\u201cprint once artifacts are ready\u201d use case is already covered by the proposed\nsolution."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"If user cannot implement what they want to do using the proposed solution, we\ncan provide this callback later on without introducing any breaking changes."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Alternative 2: CLI Flag for Streaming"})}),"\n",(0,r.jsxs)(n.p,{children:["Instead of use ",(0,r.jsx)(n.code,{children:"ctx.output.stream"})," at the call site, a global CLI flag\n",(0,r.jsx)(n.code,{children:"--streaming"})," could exist. That would make all ",(0,r.jsx)(n.code,{children:"ctx.output.print"})," \u201cstreaming\u201d.\nHowever:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"It lacks fine-grained control. Users cannot selectively choose which prints\nare delayed/streamed."}),"\n",(0,r.jsx)(n.li,{children:"The proposed solution offers more flexibility by controlling streaming at each\nprint call."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"6-potential-future-work",children:"6. Potential Future Work"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Prioritized Materialization:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"A flag or mechanism to ensure certain artifacts are materialized first\n(blocking the remaining artifacts), so streaming prints that depend on them\ncan happen sooner."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Streaming Build Actions:"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Stream outputs of each build actions in ",(0,r.jsx)(n.code,{children:"ctx.build"}),". With Structured Action\nErrors IDEs can easily parsed the compile errors"]}),"\n"]}),"\n",(0,r.jsxs)(n.ol,{start:"3",children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Streaming Output for Other Lazy APIs:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Extend similar streaming logic to apis like\n",(0,r.jsx)(n.code,{children:"ctx.lazy.unconfigured_target_node(patterns like cell//path/to/...)"}),",\nqueries or other lazy operations, so partial results appear earlier in\nlogs."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Instead of printing only to stdout, support more flexible transport layers\n(e.g. socket file) or structured encodings for streaming data."}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);