# Copyright (c) Meta Platforms, Inc. and affiliates.
#
# This source code is dual-licensed under either the MIT license found in the
# LICENSE-MIT file in the root directory of this source tree or the Apache
# License, Version 2.0 found in the LICENSE-APACHE file in the root directory
# of this source tree. You may select, at your option, one of the
# above-listed licenses.

"""BXL tests for checking mutually exclusive dependencies."""

load(":dependencies_test_util.bzl", "rule_list_regex")

_MAX_DEPTH = 2147483647

def _impl_check_mutually_exclusive_dependencies_test(
        ctx: bxl.Context,
        mutually_exclusive_group: list[str],
        target: TargetLabel,
        target_deps: bool):
    """Test that only one dependency from a mutually exclusive group is present.

    Verifies that the target's transitive dependencies contain at most one pattern
    from the mutually exclusive group. For example, if the group is:
    [volk:volk, volk:volk-header, static-vulkan]

    The test ensures only one (or none) of these patterns has matches in the dependency tree.

    Each pattern may contain target names (e.g. //foo/bar:bar)
    or regex patterns (e.g. //foo/.*)
    """
    if not mutually_exclusive_group or len(mutually_exclusive_group) < 2:
        fail("Self-check: mutually exclusive group must have at least 2 patterns")

    cquery = ctx.cquery()
    cquery_kwargs = {}
    if target_deps:
        cquery_kwargs["filter"] = "target_deps()"

    transitive_deps = cquery.deps(
        ctx.target_universe(target, modifiers = ctx.modifiers).target_set(),
        _MAX_DEPTH,
        **cquery_kwargs
    )

    # Find which patterns from the group have matches
    patterns_with_matches = []

    for pattern in mutually_exclusive_group:
        pattern_regex = rule_list_regex([pattern])
        matches = filter(lambda target: regex_match(pattern_regex, str(target.label.raw_target())), transitive_deps)
        match_set = ctx.target_universe(matches).target_set()

        if len(match_set) > 0:
            patterns_with_matches.append((pattern, match_set))

    # If more than one pattern has matches, fail
    if len(patterns_with_matches) > 1:
        violation_msg = "Found {} mutually exclusive dependencies (only one allowed):\n".format(len(patterns_with_matches))
        for pattern, match_set in patterns_with_matches:
            violation_msg += "\n  Pattern: {}\n".format(pattern)
            violation_msg += "  Matches:\n"
            for target in match_set:
                violation_msg += "    - {}\n".format(str(target.label.raw_target()))
        fail(violation_msg)

def _impl(ctx: bxl.Context):
    # Parse the mutually_exclusive_group from CLI args
    # Format: "pattern1,pattern2,pattern3,..."
    group_str = ctx.cli_args.mutually_exclusive_group
    group = group_str.split(",") if group_str else []

    _impl_check_mutually_exclusive_dependencies_test(
        ctx,
        group,
        ctx.cli_args.target,
        ctx.cli_args.target_deps,
    )

test = bxl_main(
    cli_args = {
        "mutually_exclusive_group": cli_args.string(),
        "target": cli_args.target_label(),
        "target_deps": cli_args.bool(default = True),
    },
    impl = _impl,
)
