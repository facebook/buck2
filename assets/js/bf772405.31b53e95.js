"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[96342],{8644:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>h,contentTitle:()=>a,default:()=>c,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"rfcs/drafts/digest-kinds","title":"Digest Kinds","description":"Use cases:","source":"@site/../docs/rfcs/drafts/digest-kinds.md","sourceDirName":"rfcs/drafts","slug":"/rfcs/drafts/digest-kinds","permalink":"/docs/rfcs/drafts/digest-kinds","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{}}');var i=s(74848),r=s(28453);const o={},a="Digest Kinds",h={},l=[{value:"Use cases:",id:"use-cases",level:2},{value:"Proposed plan",id:"proposed-plan",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Hashes received from RE",id:"hashes-received-from-re",level:3},{value:"Hashes of files",id:"hashes-of-files",level:3},{value:"Hashes of directories",id:"hashes-of-directories",level:3}];function d(e){const n={em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"digest-kinds",children:"Digest Kinds"})}),"\n",(0,i.jsx)(n.h2,{id:"use-cases",children:"Use cases:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Buck2 needs to support more than just SHA1 for open-sourcing, since publicly\navailable RE providers use SHA256."}),"\n",(0,i.jsx)(n.li,{children:"Internally, we want to migrate to (potentially keyed) Blake3, and there will\nbe a transition period where we need to support both Blake3 and SHA1."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"proposed-plan",children:"Proposed plan"}),"\n",(0,i.jsxs)(n.p,{children:["Make all the ways in which Buck2 ",(0,i.jsx)(n.em,{children:"ingests"})," digests either configurable or\nexplicit about the type of digest they expect."]}),"\n",(0,i.jsxs)(n.p,{children:["Internally, we may keep track of digest types for debugging purposes, but we\nwill never compute more than one digest. It follows that we won't expose\nconfiguration for the digests we ",(0,i.jsx)(n.em,{children:"output"})," (namely: to use on RE): if we only\nhave one digest for each blob, making it configurable has no utility since you\nnever have a choice about the hash to use."]}),"\n",(0,i.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,i.jsx)(n.h3,{id:"hashes-received-from-re",children:"Hashes received from RE"}),"\n",(0,i.jsx)(n.p,{children:"For interactions with RE, we'll expose two configurations (this can be on the\nCommandExecutorConfig):"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Preferred hash to use when Buck2 is doing the hashing (e.g. hashing\ndirectories)."}),"\n",(0,i.jsx)(n.li,{children:"Accepted hashes."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"We'll use the format of the digests we receive from RE (in particular their\nsize) to infer what algorithm they used (remember: the RE API provides no way of\nknowing the format of a digest, it's just a string)."}),"\n",(0,i.jsx)(n.h3,{id:"hashes-of-files",children:"Hashes of files"}),"\n",(0,i.jsx)(n.p,{children:"We'll expose the hash to use via a buckconfig. Our\nthings-that-produce-hashes-of-files should either use the config to choose how\nthey hash, or fail if they cannot provide the right hash format (e.g. that'll be\ntrue of Eden I/O)."}),"\n",(0,i.jsx)(n.h3,{id:"hashes-of-directories",children:"Hashes of directories"}),"\n",(0,i.jsx)(n.p,{children:"This one gets a little tricky. Our directories currently have an implementation\nof fingerprinting that receives only the directory as input, so some refactoring\nis in order."}),"\n",(0,i.jsx)(n.p,{children:"We have two options:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Pick the hashing algorithm based on the contents of the directory (pick one\nthat's already used). Dealing with empty directories is a bit annoying."}),"\n",(0,i.jsx)(n.li,{children:"Refactor the directory implementation and have directories parameterized over\ntheir fingerprints, not their hasher."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The first one is easier but has the downside of not working with keyed Blake3\n(because you don't have a way to bring in the key), so I'm aiming for the second\nimplementation for now."})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var t=s(96540);const i={},r=t.createContext(i);function o(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);