# Copyright (c) Meta Platforms, Inc. and affiliates.
#
# This source code is dual-licensed under either the MIT license found in the
# LICENSE-MIT file in the root directory of this source tree or the Apache
# License, Version 2.0 found in the LICENSE-APACHE file in the root directory
# of this source tree. You may select, at your option, one of the
# above-listed licenses.

# TODO(cjhopman): This was generated by scripts/hacks/rules_shim_with_docs.py,
# but should be manually edited going forward. There may be some errors in
# the generated docs, and so those should be verified to be accurate and
# well-formatted (and then delete this TODO)

load("@prelude//:attrs_validators.bzl", "validation_common")
load("@prelude//:validation_deps.bzl", "VALIDATION_DEPS_ATTR_NAME", "VALIDATION_DEPS_ATTR_TYPE")
load("@prelude//apple:apple_common.bzl", "apple_common")
load("@prelude//apple:apple_info_plist.bzl", "MergeOperations", "RestrictedMergeOperations", "UpdateOperations", "apple_info_plist_impl")
load("@prelude//apple:apple_metal_library.bzl", "apple_metal_library_impl")
load("@prelude//apple:apple_platforms.bzl", "APPLE_PLATFORMS_KEY")
load("@prelude//apple:apple_resource_dedupe_alias.bzl", "apple_resource_dedupe_alias_impl")
load("@prelude//apple:apple_rules_impl_utility.bzl", "AppleFrameworkBundleModuleMapType", "apple_bundle_extra_attrs", "apple_dsymutil_attrs", "apple_test_extra_attrs", "get_apple_info_plist_build_system_identification_attrs")
load("@prelude//apple:apple_simulators.bzl", "apple_simulators_impl")
load("@prelude//apple:apple_static_archive.bzl", "apple_static_archive_impl")
load("@prelude//apple:apple_test_host_app_transition.bzl", "apple_test_host_app_transition")
load("@prelude//apple:apple_toolchain_types.bzl", "AppleToolsInfo")
load("@prelude//apple:apple_tools.bzl", "apple_tools_impl")
load("@prelude//apple:apple_universal_executable.bzl", "apple_universal_executable_impl")
load("@prelude//apple:cxx_universal_executable.bzl", "cxx_universal_executable_impl")
load("@prelude//apple:resource_groups.bzl", "RESOURCE_GROUP_MAP_ATTR")
load("@prelude//apple/mockingbird:mockingbird_mock.bzl", "mockingbird_mock_attrs", "mockingbird_mock_impl")
load("@prelude//apple/swift:swift_incremental_support.bzl", "SwiftCompilationMode")
load("@prelude//apple/swift:swift_toolchain.bzl", "swift_toolchain_impl")
load("@prelude//apple/swift:swift_toolchain_types.bzl", "SwiftObjectFormat")
load("@prelude//apple/swift:swift_types.bzl", "SwiftMacroPlugin", "SwiftVersion")
load("@prelude//apple/user:apple_ipa_package.bzl", "apple_ipa_package_attribs", "apple_ipa_package_impl")
load("@prelude//apple/user:apple_macos_bundle.bzl", "apple_macos_bundle_impl")
load("@prelude//apple/user:apple_resource_bundle.bzl", "apple_resource_bundle_impl")
load("@prelude//apple/user:apple_resource_transition.bzl", "apple_resource_transition")
load("@prelude//apple/user:apple_selective_debugging.bzl", "SelectiveDebuggingJsonTypes", "apple_selective_debugging_impl")
load("@prelude//apple/user:apple_spm_package.bzl", "apple_spm_package_impl")
load("@prelude//apple/user:apple_watchos_bundle.bzl", "apple_watchos_bundle_impl")
load("@prelude//apple/user:apple_xcframework.bzl", "apple_xcframework_impl", "framework_split_transition")
load("@prelude//apple/user:cpu_split_transition.bzl", "cpu_split_transition")
load("@prelude//apple/user:macos_transition.bzl", "macos_transition")
load("@prelude//apple/user:resource_group_map.bzl", "resource_group_map_impl")
load("@prelude//apple/user:target_sdk_version_transition.bzl", "apple_test_target_sdk_version_transition", "target_sdk_version_transition")
load("@prelude//apple/user:watch_transition.bzl", "watch_transition")
load("@prelude//cxx:groups_types.bzl", "GroupFilterInfo", "Traversal")
load("@prelude//cxx:headers.bzl", "CPrecompiledHeaderInfo", "HeaderMode")
load("@prelude//cxx:link_groups_types.bzl", "LINK_GROUP_MAP_ATTR")
load("@prelude//decls:common.bzl", "CxxRuntimeType", "CxxSourceType", "HeadersAsRawHeadersMode", "IncludeType", "LinkableDepType", "buck", "prelude_rule")
load("@prelude//decls:cxx_common.bzl", "cxx_common")
load("@prelude//decls:native_common.bzl", "native_common")
load("@prelude//decls:test_common.bzl", "test_common")
load("@prelude//decls:toolchains_common.bzl", "toolchains_common")
load("@prelude//linking:execution_preference.bzl", "link_execution_preference_attr")
load("@prelude//linking:link_info.bzl", "LinkOrdering")
load("@prelude//linking:types.bzl", "Linkage")
load("@prelude//transitions:constraint_overrides.bzl", "constraint_overrides")
load("@prelude//utils:buckconfig.bzl", "read_bool")
load(":apple_app_intents.bzl", "apple_app_intents_impl")
load(":apple_asset_catalog.bzl", "apple_asset_catalog_impl")
load(":apple_binary.bzl", "apple_binary_impl")
load(":apple_bundle.bzl", "apple_bundle_impl")
load(":apple_bundle_types.bzl", "AppleBundleInfo", "ApplePackageExtension")
load(":apple_core_data.bzl", "apple_core_data_impl")
load(":apple_library.bzl", "AppleSharedLibraryMachOFileType", "apple_library_impl")
load(":apple_package.bzl", "apple_package_impl")
load(":apple_package_config.bzl", "IpaCompressionLevel")
load(":apple_resource.bzl", "apple_resource_impl")
load(
    ":apple_rules_impl_utility.bzl",
    "APPLE_ARCHIVE_OBJECTS_LOCALLY_OVERRIDE_ATTR_NAME",
    "apple_xcuitest_extra_attrs",
    "get_apple_resources_toolchain_attr",
    "get_apple_xctoolchain_attr",
    "get_apple_xctoolchain_bundle_id_attr",
    "get_enable_library_evolution",
    "get_skip_swift_incremental_outputs_attrs",
    "get_swift_incremental_file_hashing_attrs",
    "get_swift_incremental_remote_outputs_attrs",
)
load(":apple_test.bzl", "apple_test_impl")
load(":apple_toolchain.bzl", "apple_toolchain_impl")
load(":apple_xcuitest.bzl", "apple_xcuitest_impl")
load(":prebuilt_apple_framework.bzl", "prebuilt_apple_framework_impl")
load(":scene_kit_assets.bzl", "scene_kit_assets_impl")

AdditionalActions = ["pre_scheme_actions", "post_scheme_actions"]

AppleBundleExtension = ["app", "framework", "appex", "plugin", "bundle", "xctest", "dsym", "xpc", "prefpane", "qlgenerator"]

AppleResourceBundleDestination = ["resources", "frameworks", "executables", "plugins", "xpcservices", "loginitems", "systemextensions"]

LaunchStyle = ["auto", "wait"]

SchemeActionType = ["build", "launch", "test", "profile", "analyze", "archive"]

WatchInterface = ["main", "complication", "dynamic_notification", "static_notification"]

SWIFT_VERSION_FEATURE_MAP = {
    "5": [],
    "6": [],
}

def apple_bundle_base_attrs():
    return (apple_common.product_name_from_module_name_arg() |
            apple_common.asset_catalogs_compilation_options_arg() |
            apple_common.info_plist_substitutions_arg() |
            {
                "codesign_flags": attrs.list(attrs.string(), default = []),
                "codesign_identity": attrs.option(attrs.string(), default = None),
                "contacts": attrs.list(attrs.string(), default = []),
                "default_host_platform": attrs.option(attrs.configuration_label(), default = None),
                "default_platform": attrs.option(attrs.string(), default = None),
                "deps": attrs.list(attrs.dep(), default = []),
                "extension": attrs.one_of(attrs.enum(AppleBundleExtension), attrs.string()),
                "ibtool_flags": attrs.option(attrs.list(attrs.string()), default = None),
                "incremental_bundling_enabled": attrs.option(attrs.bool(), default = None),
                "info_plist": attrs.source(),
                "labels": attrs.list(attrs.string(), default = []),
                "licenses": attrs.list(attrs.source(), default = []),
                "platform_binary": attrs.option(attrs.list(attrs.tuple(attrs.regex(), attrs.dep())), default = None),
                "product_name": attrs.option(attrs.string(), default = None),
                "resource_group": attrs.option(attrs.string(), default = None),
                "resource_group_map": attrs.option(RESOURCE_GROUP_MAP_ATTR, default = None),
                "skip_copying_swift_stdlib": attrs.option(attrs.bool(), default = None),
                "try_skip_code_signing": attrs.option(attrs.bool(), default = None),
                "xcode_product_type": attrs.option(attrs.string(), default = None),
            })

def apple_bundle_default_attrs():
    attributes = {}
    attributes.update(apple_bundle_base_attrs())
    attributes.update(apple_bundle_extra_attrs())
    attributes.update({
        APPLE_PLATFORMS_KEY: attrs.dict(key = attrs.string(), value = attrs.dep(), sorted = False, default = {}),
    })
    return attributes

def apple_macos_bundle_attrs():
    attributes = apple_bundle_default_attrs()
    attributes.update({
        "bundle_type": attrs.string(default = "default"),
    })
    return attributes

def apple_watchos_bundle_attrs():
    attributes = apple_bundle_default_attrs()
    attributes.update({
        "bundle_type": attrs.string(default = "watchapp"),
    })
    return attributes

apple_asset_catalog = prelude_rule(
    name = "apple_asset_catalog",
    docs = """
        An `apple_asset_catalog()` rule contains resources stored in Apple asset catalog
        directories. This rule does not have any output on its own and can be built only as a dependency
        (either direct or transitive) of an `apple_bundle()` rule, in which case all `apple_asset_catalog()` rules
        that the bundle rule depends on are merged and placed into the final output bundle together.
    """,
    examples = """
        ```

        apple_asset_catalog(
          name = 'MyAssetCatalog',
          dirs = [
            'MyResources.xcassets',
          ],
        )

        # A asset catalog with a app icon and launch image
        apple_asset_catalog(
          name = 'AssetCatalog',
          dirs = [ 'AssetCatalog.xcassets' ],
          app_icon = 'Icon',
          launch_image = 'LaunchImage',
        )

        ```
    """,
    further = None,
    attrs = (
        # @unsorted-dict-items
        {
            "dirs": attrs.list(attrs.source(allow_directory = True), default = [], doc = """
                Set of paths of Apple asset catalogs contained by this rule. All paths have to end with the `.xcassets` extension and be compatible with the asset catalog format used by Xcode.
            """),
            "app_icon": attrs.option(attrs.string(), default = None, doc = """
                An optional reference to a `.appiconset` containing a image set representing an
                 application icon. (The extension itself should not be included.) This parameter
                 may be specified at most once in a given `apple_bundle`'s transitive dependencies.
            """),
            "launch_image": attrs.option(attrs.string(), default = None, doc = """
                An optional reference to a `.launchimage` containing a image set representing an
                 application launch image. (The extension itself should not be included.) This parameter
                 may be specified at most once in a given `apple_bundle`'s transitive dependencies.
            """),
            "contacts": attrs.list(attrs.string(), default = []),
            "default_host_platform": attrs.option(attrs.configuration_label(), default = None),
            "labels": attrs.list(attrs.string(), default = []),
            "licenses": attrs.list(attrs.source(), default = []),
        } | apple_common.skip_universal_resource_dedupe_arg()
    ),
    impl = apple_asset_catalog_impl,
    cfg = apple_resource_transition,
)

apple_app_intents = prelude_rule(
    name = "apple_app_intents",
    docs = "An `apple_app_intents()` rule represents App Intents definitions for Apple platforms.",
    examples = None,
    further = None,
    attrs = {
        "contacts": attrs.list(attrs.string(), default = []),
        "default_host_platform": attrs.option(attrs.configuration_label(), default = None),
        "labels": attrs.list(attrs.string(), default = []),
        "licenses": attrs.list(attrs.source(), default = []),
    },
    impl = apple_app_intents_impl,
)

apple_binary = prelude_rule(
    name = "apple_binary",
    docs = """
        An `apple_binary()` rule builds a native executable - such as an iOS or OSX app - from
        the supplied set of Objective-C/C++ source files and dependencies. It is similar to
        a `cxx_binary()` rule with which it shares many attributes. In addition
        to those common attributes, `apple_binary()` has a some additional attributes
        that are specific to binaries intended to be built using the Apple toolchain.
        Note, however, that `apple_binary()` and `cxx_binary()` differ
        in the way that they import header files, in order to better accommodate existing conventions.
        See the sections for the `headers` and `exported_headers` attributes for more details.


        Buck enables you to override components of the Apple toolchain with
        alternate tools, either from the Xcode search paths or from directories
        that you specify.
        See `.buckconfig`
        and `.buckconfig`
        for more information.
    """,
    examples = """
        ```

        apple_binary(
          name = 'MyBinary',
          deps = [
            ':MyLibrary',
            '//Libraries:AnotherLibrary',
          ],
          preprocessor_flags = ['-fobjc-arc'],
          headers = [
            'MyHeader.h',
          ],
          srcs = [
            'MySource.m',
          ],
          frameworks = [
            '$SDKROOT/System/Library/Frameworks/UIKit.framework',
            '$SDKROOT/System/Library/Frameworks/Foundation.framework',
          ],
        )

        ```
    """,
    further = None,
    attrs = (
        # @unsorted-dict-items
        cxx_common.srcs_arg() |
        cxx_common.platform_srcs_arg() |
        apple_common.headers_arg() |
        {
            "entitlements_file": attrs.option(attrs.source(), default = None, doc = """
                An optional name of a plist file to be embedded in the binary. Some platforms like
                 `iphonesimulator` require this to run properly.
            """),
        } |
        apple_common.apple_tools_arg() |
        apple_common.apple_toolchain_arg() |
        apple_common.exported_headers_arg() |
        apple_common.header_path_prefix_arg() |
        apple_common.frameworks_arg() |
        cxx_common.preprocessor_flags_arg() |
        cxx_common.exported_preprocessor_flags_arg(exported_preprocessor_flags_type = attrs.list(attrs.arg(), default = [])) |
        cxx_common.compiler_flags_arg() |
        cxx_common.platform_compiler_flags_arg() |
        cxx_common.linker_extra_outputs_arg() |
        cxx_common.linker_flags_arg() |
        cxx_common.exported_linker_flags_arg() |
        cxx_common.platform_linker_flags_arg() |
        native_common.link_style() |
        native_common.link_group_public_deps_label() |
        apple_common.target_sdk_version() |
        apple_common.extra_xcode_sources() |
        apple_common.extra_xcode_files() |
        apple_common.serialize_debugging_options_arg() |
        apple_common.uses_explicit_modules_arg() |
        apple_common.apple_sanitizer_compatibility_arg() |
        apple_common.executable_name_arg() |
        apple_common.info_plist_substitutions_arg() |
        cxx_common.supported_platforms_regex_arg() |
        {
            "application_extension": attrs.bool(default = False),
            "binary_linker_flags": attrs.list(attrs.arg(), default = []),
            "bridging_header": attrs.option(attrs.source(), default = None),
            "can_be_asset": attrs.option(attrs.bool(), default = None),
            "contacts": attrs.list(attrs.string(), default = []),
            "cxx_runtime_type": attrs.option(attrs.enum(CxxRuntimeType), default = None),
            "default_host_platform": attrs.option(attrs.configuration_label(), default = None),
            "default_platform": attrs.option(attrs.string(), default = None),
            "defaults": attrs.dict(key = attrs.string(), value = attrs.string(), sorted = False, default = {}),
            "deps": attrs.list(attrs.dep(), default = []),
            "devirt_enabled": attrs.bool(default = False),
            "diagnostics": attrs.dict(key = attrs.string(), value = attrs.source(), sorted = False, default = {}),
            "dist_thin_lto_codegen_flags": attrs.list(attrs.arg(), default = []),
            "enable_cxx_interop": attrs.bool(default = False),
            "enable_distributed_thinlto": attrs.bool(default = select({
                "DEFAULT": False,
                "config//build_mode/constraints:distributed-thin-lto-enabled": True,
            })),
            "enable_library_evolution": attrs.option(attrs.bool(), default = None),
            "exported_header_style": attrs.enum(IncludeType, default = "local"),
            "exported_lang_platform_preprocessor_flags": attrs.dict(key = attrs.enum(CxxSourceType), value = attrs.list(attrs.tuple(attrs.regex(), attrs.list(attrs.arg()))), sorted = False, default = {}),
            "exported_lang_preprocessor_flags": attrs.dict(key = attrs.enum(CxxSourceType), value = attrs.list(attrs.arg()), sorted = False, default = {}),
            "exported_platform_deps": attrs.list(attrs.tuple(attrs.regex(), attrs.set(attrs.dep(), sorted = True)), default = []),
            "exported_platform_headers": attrs.list(attrs.tuple(attrs.regex(), attrs.named_set(attrs.source(), sorted = True)), default = []),
            "exported_platform_linker_flags": attrs.list(attrs.tuple(attrs.regex(), attrs.list(attrs.arg())), default = []),
            "exported_platform_preprocessor_flags": attrs.list(attrs.tuple(attrs.regex(), attrs.list(attrs.arg())), default = []),
            "exported_post_linker_flags": attrs.list(attrs.arg(), default = []),
            "exported_post_platform_linker_flags": attrs.list(attrs.tuple(attrs.regex(), attrs.list(attrs.arg())), default = []),
            "fat_lto": attrs.bool(default = False),
            "focused_list_target": attrs.option(attrs.dep(), default = None),
            "force_static": attrs.option(attrs.bool(), default = None),
            "header_namespace": attrs.option(attrs.string(), default = None),
            "headers_as_raw_headers_mode": attrs.option(attrs.enum(HeadersAsRawHeadersMode), default = None),
            "include_directories": attrs.set(attrs.string(), sorted = True, default = []),
            "info_plist": attrs.option(attrs.source(), default = None),
            "labels": attrs.list(attrs.string(), default = []),
            "lang_compiler_flags": attrs.dict(key = attrs.enum(CxxSourceType), value = attrs.list(attrs.arg()), sorted = False, default = {}),
            "lang_platform_compiler_flags": attrs.dict(key = attrs.enum(CxxSourceType), value = attrs.list(attrs.tuple(attrs.regex(), attrs.list(attrs.arg()))), sorted = False, default = {}),
            "lang_platform_preprocessor_flags": attrs.dict(key = attrs.enum(CxxSourceType), value = attrs.list(attrs.tuple(attrs.regex(), attrs.list(attrs.arg()))), sorted = False, default = {}),
            "lang_preprocessor_flags": attrs.dict(key = attrs.enum(CxxSourceType), value = attrs.list(attrs.arg()), sorted = False, default = {}),
            "libraries": attrs.list(attrs.string(), default = []),
            "licenses": attrs.list(attrs.source(), default = []),
            "link_execution_preference": link_execution_preference_attr(),
            "link_group": attrs.option(attrs.string(), default = None),
            "link_group_map": LINK_GROUP_MAP_ATTR,
            "link_ordering": attrs.option(attrs.enum(LinkOrdering.values()), default = None),
            "link_whole": attrs.option(attrs.bool(), default = None),
            "modular": attrs.bool(default = False),
            "module_name": attrs.option(attrs.string(), default = None),
            "module_requires_cxx": attrs.bool(default = False),
            "platform_deps": attrs.list(attrs.tuple(attrs.regex(), attrs.set(attrs.dep(), sorted = True)), default = []),
            "platform_headers": attrs.list(attrs.tuple(attrs.regex(), attrs.named_set(attrs.source(), sorted = True)), default = []),
            "platform_preprocessor_flags": attrs.list(attrs.tuple(attrs.regex(), attrs.list(attrs.arg())), default = []),
            "post_linker_flags": attrs.list(attrs.arg(), default = []),
            "post_platform_linker_flags": attrs.list(attrs.tuple(attrs.regex(), attrs.list(attrs.arg())), default = []),
            "precompiled_header": attrs.option(attrs.dep(providers = [CPrecompiledHeaderInfo]), default = None),
            "prefer_stripped_objects": attrs.bool(default = False),
            "preferred_linkage": attrs.enum(Linkage.values(), default = "any"),
            "prefix_header": attrs.option(attrs.source(), default = None),
            "propagated_target_sdk_version": attrs.option(attrs.string(), default = None),
            "public_include_directories": attrs.set(attrs.string(), sorted = True, default = []),
            "public_system_include_directories": attrs.set(attrs.string(), sorted = True, default = []),
            "raw_headers": attrs.set(attrs.source(), sorted = True, default = []),
            "reexport_all_header_dependencies": attrs.option(attrs.bool(), default = None),
            "sanitizer_runtime_enabled": attrs.option(attrs.bool(), default = None),
            "sdk_modules": attrs.list(attrs.string(), default = []),
            "soname": attrs.option(attrs.string(), default = None),
            "static_library_basename": attrs.option(attrs.string(), default = None),
            "stripped": attrs.option(attrs.bool(), default = None),
            "supports_merged_linking": attrs.option(attrs.bool(), default = None),
            "swift_compilation_mode": attrs.enum(SwiftCompilationMode.values(), default = "wmo"),
            "swift_compiler_flags": attrs.list(attrs.arg(), default = []),
            "swift_interface_compilation_enabled": attrs.bool(default = False),
            "swift_module_skip_function_bodies": attrs.bool(default = True),
            "swift_package_name": attrs.option(attrs.string(), default = None),
            "swift_version": attrs.option(attrs.enum(SwiftVersion), default = None),
            "thin_lto": attrs.bool(default = False),
            "use_submodules": attrs.bool(default = True),
            "uses_cxx_explicit_modules": attrs.bool(default = False),
            "uses_modules": attrs.bool(default = False),
            "_apple_xctoolchain": get_apple_xctoolchain_attr(),
            "_apple_xctoolchain_bundle_id": get_apple_xctoolchain_bundle_id_attr(),
            "_enable_library_evolution": get_enable_library_evolution(),
            "_stripped_default": attrs.bool(default = False),
            "_swift_enable_testing": attrs.default_only(attrs.bool(default = False)),
            VALIDATION_DEPS_ATTR_NAME: VALIDATION_DEPS_ATTR_TYPE,
        } |
        buck.allow_cache_upload_arg() |
        validation_common.attrs_validators_arg() |
        constraint_overrides.attributes |
        apple_dsymutil_attrs() |
        get_skip_swift_incremental_outputs_attrs()
    ),
    impl = apple_binary_impl,
    cfg = target_sdk_version_transition,
)

apple_bundle = prelude_rule(
    name = "apple_bundle",
    docs = """
        An `apple_bundle()` rule takes an Apple binary and all of the resources and asset
        catalogs in the rule's transitive dependencies and generates a bundle containing all of those files.
        Optionally the generated bundle can also be signed using specified provisioning profiles.


        Code signing will embed entitlements pointed to by the `entitlements_file` arg in
        the bundle's `apple_binary`. This is the preferred way to specify entitlements
        when building with Buck.

        If the entitlements file is not present, it falls back to the `CODE_SIGN_ENTITLEMENTS` entry in
         `info_plist_substitutions`.


        If after these checks, an entitlements file is still not specified, it will be derived based
        on the entitlements of the selected provisioning profile. Provisioning profiles will be selected
        from profiles pointed to by `apple.provisioning_profile_search_path`, based on a
        non-expired profile that matches the bundle id and entitlements.


        Code signing will embed entitlements pointed to by the `CODE_SIGN_ENTITLEMENTS` entry in
        `info_plist_substitutions`. If an entitlements file is omitted, it will be derived based
        on the entitlements of the selected provisioning profile. Provisioning profiles will be selected
        from profiles pointed to by `apple.provisioning_profile_search_path`, based on a
        non-expired profile that matches the bundle id and entitlements.
    """,
    examples = """
        ```

        apple_bundle(
          name = 'AppBundle',
          binary = ':MyBinary',
          extension = 'app',
          info_plist = 'Info.plist',
        )

        ```

        ```

        # iOS app with embedded WatchOS 2.0 app/extension
        apple_bundle(
          name = 'DemoWatchAppExtension',
          binary = ':DemoWatchAppExtensionBinary',
          extension = 'appex',
          info_plist = 'WatchExtension/Resources/Info.plist',
        )

        apple_bundle(
          name = 'DemoWatchApp',
          binary = ':DemoWatchAppBinary',
          deps = [':DemoWatchAppResources', ':DemoWatchAppExtension'],
          extension = 'app',
          info_plist = 'WatchApplication/Info.plist',
        )

        apple_bundle(
          name = 'DemoApp',
          binary = ':DemoAppBinary',
          deps = [':DemoWatchApp#watch'],
          extension = 'app',
          info_plist = 'Info.plist',
        )

        ```

        ```

        # iOS app using safeAreaInsets delivering to iOS 9.x
        apple_bundle(
          name = 'DemoIBApp',
          binary = ':DemoIBAppBinary',
          deps = [':DemoIBAppResources'],
          extension = 'app',
          ibtool_flags = ["--minimum-deployment-target", "9.0"],
          info_plist = 'Info.plist',
        )

        ```
    """,
    further = None,
    attrs = (
        # @unsorted-dict-items
        {
            "deps": attrs.list(attrs.dep(), default = [], doc = """
                A list of dependencies of this bundle as build targets. You can embed application
                 extensions by specifying the extension's bundle target. To include a WatchKit app, append the
                 flavor `#watch` to the target specification. Buck will automatically substitute the appropriate
                 platform flavor (either `watchsimulator` or `watchos`) based on the parent.
            """),
            "product_name": attrs.option(attrs.string(), default = None, doc = """
                The name of the resulting bundle and binary. The setting behaves like PRODUCT\\_NAME Xcode build setting.
                 For example, if your rule is named "MyApp" and extension is "app", by default buck will generate MyApp.app bundle.
                 But if you will set product name to "SuperApp", bundle will get "SuperApp.app" name.
            """),
            "extension": attrs.one_of(attrs.enum(AppleBundleExtension), attrs.string(), doc = """
                The extension of the generated bundle. For example `'app'` for an application bundle
                 or `'appex'` for an application extension bundle.
            """),
            "binary": attrs.option(attrs.dep(), default = None, doc = """
                A `build target` identifying
                 an `apple_binary()` rule or
                 an `apple_library()` or `apple_libary_for_distribution()` rule whose output will
                 be used as the main executable binary of the generated bundle. The required rule type depends
                 on the value in the `extension` attribute. For example, application bundles expect
                 a binary (e.g. `'//Apps/MyApp:MyApp'`), application extension bundles expect a shared
                 library (e.g. `'//Libraries/MyLibrary:MyLibrary#shared'`).
            """),
        } |
        apple_common.info_plist_arg() |
        apple_common.info_plist_substitutions_arg() |
        apple_common.privacy_manifest_arg() |
        apple_common.product_name_from_module_name_arg() |
        apple_common.asset_catalogs_compilation_options_arg() |
        {
            "ibtool_flags": attrs.option(attrs.list(attrs.string()), default = None, doc = """
                List of flags to be passed to ibtool during interface builder file compilation.
            """),
            "codesign_flags": attrs.list(attrs.string(), default = []),
            "codesign_identity": attrs.option(attrs.string(), default = None),
            "contacts": attrs.list(attrs.string(), default = []),
            "default_host_platform": attrs.option(attrs.configuration_label(), default = None),
            "default_platform": attrs.option(attrs.string(), default = None),
            "incremental_bundling_enabled": attrs.option(attrs.bool(), default = None),
            "labels": attrs.list(attrs.string(), default = []),
            "licenses": attrs.list(attrs.source(), default = []),
            "platform_binary": attrs.option(attrs.list(attrs.tuple(attrs.regex(), attrs.dep())), default = None),
            "resource_group": attrs.option(attrs.string(), default = None),
            "resource_group_map": attrs.option(RESOURCE_GROUP_MAP_ATTR, default = None),
            "skip_copying_swift_stdlib": attrs.option(attrs.bool(), default = None),
            "try_skip_code_signing": attrs.option(attrs.bool(), default = None),
            "xcode_product_type": attrs.option(attrs.string(), default = None),
        } | apple_bundle_extra_attrs()
    ),
    impl = apple_bundle_impl,
    cfg = target_sdk_version_transition,
)

apple_library = prelude_rule(
    name = "apple_library",
    docs = """
        An `apple_library()` rule represents a set of Objective-C/C++/Swift
        source files and is similar to a `cxx_library()` rule with which it shares many
        attributes. In addition to those common attributes, `apple_library()` has a some additional attributes
        that are specific to binaries intended to be built using the Apple toolchain.
        Note, however, that `apple_library()` and `cxx_library()` differ
        in the way that they import header files, in order to better accommodate existing conventions.
        See the sections for the `headers` and `exported_headers` attributes for more details.


        Buck enables you to override components of the Apple toolchain with
        alternate tools, either from the Xcode search paths or from directories
        that you specify.
        See `.buckconfig`
        and `.buckconfig`
        for more information.
    """,
    examples = """
        ```

        apple_library(
          name = 'MyLibrary',
          deps = [
            ':OtherLibrary',
            '//Libraries:YetAnotherLibrary',
          ],
          preprocessor_flags = ['-fobjc-arc'],
          headers = [
            'MyHeader.h',
          ],
          srcs = [
            'MySource.m',
            'MySource.swift',
          ],
          frameworks = [
            '$SDKROOT/System/Library/Frameworks/UIKit.framework',
            '$SDKROOT/System/Library/Frameworks/Foundation.framework',
          ],
        )

        ```
    """,
    further = None,
    attrs = (
        # @unsorted-dict-items
        cxx_common.srcs_arg() |
        cxx_common.platform_srcs_arg() |
        apple_common.headers_arg() |
        apple_common.exported_headers_arg() |
        apple_common.header_path_prefix_arg() |
        cxx_common.header_namespace_arg() |
        apple_common.frameworks_arg() |
        cxx_common.preprocessor_flags_arg() |
        cxx_common.exported_preprocessor_flags_arg(exported_preprocessor_flags_type = attrs.list(attrs.arg(), default = [])) |
        cxx_common.compiler_flags_arg() |
        cxx_common.platform_compiler_flags_arg() |
        cxx_common.linker_extra_outputs_arg() |
        cxx_common.linker_flags_arg() |
        cxx_common.exported_linker_flags_arg() |
        cxx_common.exported_platform_linker_flags_arg() |
        apple_common.target_sdk_version() |
        native_common.preferred_linkage(preferred_linkage_type = attrs.option(attrs.enum(Linkage.values()), default = None)) |
        native_common.link_style() |
        native_common.link_whole(link_whole_type = attrs.option(attrs.bool(), default = None)) |
        cxx_common.reexport_all_header_dependencies_arg() |
        cxx_common.exported_deps_arg() |
        cxx_common.raw_headers_arg() |
        cxx_common.include_directories_arg() |
        cxx_common.public_include_directories_arg() |
        cxx_common.public_system_include_directories_arg() |
        cxx_common.raw_headers_as_headers_mode_arg() |
        apple_common.extra_xcode_sources() |
        apple_common.extra_xcode_files() |
        apple_common.serialize_debugging_options_arg() |
        apple_common.uses_explicit_modules_arg() |
        apple_common.meta_apple_library_validation_enabled_arg() |
        apple_common.executable_name_arg() |
        apple_common.info_plist_substitutions_arg() |
        cxx_common.supported_platforms_regex_arg() |
        apple_common.apple_tools_arg() |
        apple_common.apple_toolchain_arg() |
        validation_common.attrs_validators_arg() |
        {
            "bridging_header": attrs.option(attrs.source(), default = None),
            "can_be_asset": attrs.option(attrs.bool(), default = None),
            "contacts": attrs.list(attrs.string(), default = []),
            "cxx_runtime_type": attrs.option(attrs.enum(CxxRuntimeType), default = None),
            "default_host_platform": attrs.option(attrs.configuration_label(), default = None),
            "default_platform": attrs.option(attrs.string(), default = None),
            "defaults": attrs.dict(key = attrs.string(), value = attrs.string(), sorted = False, default = {}),
            "deps": attrs.list(attrs.dep(), default = []),
            "devirt_enabled": attrs.bool(default = False),
            "diagnostics": attrs.dict(key = attrs.string(), value = attrs.source(), sorted = False, default = {}),
            "dist_thin_lto_codegen_flags": attrs.list(attrs.arg(), default = []),
            "enable_cxx_interop": attrs.bool(default = False),
            "enable_distributed_thinlto": attrs.bool(default = select({
                "DEFAULT": False,
                "config//build_mode/constraints:distributed-thin-lto-enabled": True,
            })),
            "enable_library_evolution": attrs.option(attrs.bool(), default = None),
            "exported_header_style": attrs.enum(IncludeType, default = "local"),
            "exported_lang_platform_preprocessor_flags": attrs.dict(key = attrs.enum(CxxSourceType), value = attrs.list(attrs.tuple(attrs.regex(), attrs.list(attrs.arg()))), sorted = False, default = {}),
            "exported_lang_preprocessor_flags": attrs.dict(key = attrs.enum(CxxSourceType), value = attrs.list(attrs.arg()), sorted = False, default = {}),
            "exported_platform_deps": attrs.list(attrs.tuple(attrs.regex(), attrs.set(attrs.dep(), sorted = True)), default = []),
            "exported_platform_headers": attrs.list(attrs.tuple(attrs.regex(), attrs.named_set(attrs.source(), sorted = True)), default = []),
            "exported_platform_preprocessor_flags": attrs.list(attrs.tuple(attrs.regex(), attrs.list(attrs.arg())), default = []),
            "exported_post_linker_flags": attrs.list(attrs.arg(), default = []),
            "exported_post_platform_linker_flags": attrs.list(attrs.tuple(attrs.regex(), attrs.list(attrs.arg())), default = []),
            "fat_lto": attrs.bool(default = False),
            "focused_list_target": attrs.option(attrs.dep(), default = None),
            "force_static": attrs.option(attrs.bool(), default = None),
            "header_mode": attrs.option(attrs.enum(HeaderMode.values()), default = None),
            "headers_as_raw_headers_mode": attrs.option(attrs.enum(HeadersAsRawHeadersMode), default = None),
            "info_plist": attrs.option(attrs.source(), default = None),
            "labels": attrs.list(attrs.string(), default = []),
            "lang_compiler_flags": attrs.dict(key = attrs.enum(CxxSourceType), value = attrs.list(attrs.arg()), sorted = False, default = {}),
            "lang_platform_compiler_flags": attrs.dict(key = attrs.enum(CxxSourceType), value = attrs.list(attrs.tuple(attrs.regex(), attrs.list(attrs.arg()))), sorted = False, default = {}),
            "lang_platform_preprocessor_flags": attrs.dict(key = attrs.enum(CxxSourceType), value = attrs.list(attrs.tuple(attrs.regex(), attrs.list(attrs.arg()))), sorted = False, default = {}),
            "lang_preprocessor_flags": attrs.dict(key = attrs.enum(CxxSourceType), value = attrs.list(attrs.arg()), sorted = False, default = {}),
            "libraries": attrs.list(attrs.string(), default = []),
            "licenses": attrs.list(attrs.source(), default = []),
            "link_execution_preference": link_execution_preference_attr(),
            "link_group": attrs.option(attrs.string(), default = None),
            "link_group_map": LINK_GROUP_MAP_ATTR,
            "link_ordering": attrs.option(attrs.enum(LinkOrdering.values()), default = None),
            "modular": attrs.bool(default = False),
            "module_name": attrs.option(attrs.string(), default = None),
            "module_requires_cxx": attrs.bool(default = False),
            "platform_deps": attrs.list(attrs.tuple(attrs.regex(), attrs.set(attrs.dep(), sorted = True)), default = []),
            "platform_headers": attrs.list(attrs.tuple(attrs.regex(), attrs.named_set(attrs.source(), sorted = True)), default = []),
            "platform_linker_flags": attrs.list(attrs.tuple(attrs.regex(), attrs.list(attrs.arg())), default = []),
            "platform_preprocessor_flags": attrs.list(attrs.tuple(attrs.regex(), attrs.list(attrs.arg())), default = []),
            "post_linker_flags": attrs.list(attrs.arg(), default = []),
            "post_platform_linker_flags": attrs.list(attrs.tuple(attrs.regex(), attrs.list(attrs.arg())), default = []),
            "precompiled_header": attrs.option(attrs.dep(providers = [CPrecompiledHeaderInfo]), default = None),
            "preferred_linkage": attrs.enum(Linkage.values(), default = "any"),
            "prefix_header": attrs.option(attrs.source(), default = None),
            "propagated_target_sdk_version": attrs.option(attrs.string(), default = None),
            "public_framework_headers": attrs.named_set(attrs.source(), sorted = True, default = []),
            "sdk_modules": attrs.list(attrs.string(), default = []),
            # Mach-O file type for binary when the target is built as a shared library.
            "shared_library_macho_file_type": attrs.enum(AppleSharedLibraryMachOFileType.values(), default = "dylib"),
            "soname": attrs.option(attrs.string(), default = None),
            "static_library_basename": attrs.option(attrs.string(), default = None),
            "stripped": attrs.option(attrs.bool(), default = None),
            "supports_header_symlink_subtarget": attrs.bool(default = False),
            "supports_merged_linking": attrs.option(attrs.bool(), default = None),
            "supports_shlib_interfaces": attrs.bool(default = True),
            "swift_compilation_mode": attrs.enum(SwiftCompilationMode.values(), default = "wmo"),
            "swift_compiler_flags": attrs.list(attrs.arg(), default = []),
            "swift_interface_compilation_enabled": attrs.bool(default = True),
            "swift_macro_deps": attrs.list(attrs.plugin_dep(kind = SwiftMacroPlugin), default = []),
            "swift_module_skip_function_bodies": attrs.bool(default = True),
            "swift_package_name": attrs.option(attrs.string(), default = None),
            "swift_version": attrs.option(attrs.enum(SwiftVersion), default = None),
            "thin_lto": attrs.bool(default = False),
            "use_submodules": attrs.bool(default = True),
            "uses_cxx_explicit_modules": attrs.bool(default = False),
            "use_archive": attrs.option(attrs.bool(), default = None),
            "uses_modules": attrs.bool(default = False),
            "_apple_xctoolchain": get_apple_xctoolchain_attr(),
            "_apple_xctoolchain_bundle_id": get_apple_xctoolchain_bundle_id_attr(),
            "_enable_library_evolution": get_enable_library_evolution(),
            "_stripped_default": attrs.bool(default = False),
            "_swift_enable_testing": attrs.bool(default = select({
                "DEFAULT": False,
                "config//features/apple:swift_enable_testing_enabled": True,
            })),
            "uses_experimental_content_based_path_hashing": attrs.bool(default = select({
                "DEFAULT": read_bool("apple", "uses_experimental_content_based_path_hashing", False),
                "config//features/apple:content_based_path_hashing_enabled": True,
                "config//features/apple:content_based_path_hashing_disabled": False,
            })),
            APPLE_ARCHIVE_OBJECTS_LOCALLY_OVERRIDE_ATTR_NAME: attrs.option(attrs.bool(), default = None),
            VALIDATION_DEPS_ATTR_NAME: VALIDATION_DEPS_ATTR_TYPE,
        } |
        buck.allow_cache_upload_arg() |
        apple_dsymutil_attrs() |
        get_swift_incremental_file_hashing_attrs() |
        get_swift_incremental_remote_outputs_attrs() |
        get_skip_swift_incremental_outputs_attrs()
    ),
    uses_plugins = [SwiftMacroPlugin],
    impl = apple_library_impl,
    cfg = target_sdk_version_transition,
)

apple_library_for_distribution = prelude_rule(
    name = "apple_library_for_distribution",
    docs = """
        An `apple_library_for_distribution()` rule creates a library for distribution
        (for instance via a Framework or Xcframework) with link group support.
    """,
    examples = None,
    further = None,
    attrs = (
        apple_library.attrs |
        {
            "distribution_dep": attrs.dep(),
        }
    ),
    uses_plugins = [SwiftMacroPlugin],
    impl = apple_library_impl,
    cfg = target_sdk_version_transition,
)

apple_metal_library = prelude_rule(
    name = "apple_metal_library",
    impl = apple_metal_library_impl,
    docs = """
        An `apple_metal_library()` rule contains .metal and .h source files
        to be bundled together to create a .metallib
    """,
    examples = """
        ```

        apple_metal_library(
          name = 'MyShaderLibrary',
          srcs = [
              MyShaderFile.metal,
              SharedShaderHelpers.metal,
          ],
          headers = [ SharedShaderHelpers.h ],
        )

        ```
    """,
    further = None,
    attrs = (
        {
            "headers": attrs.list(attrs.source(), default = []),
            "labels": attrs.list(attrs.string(), default = []),
            "metal_compiler_flags": attrs.list(attrs.arg(), default = [], doc = """
                Flags to use when compiling Metal sources.
            """),
            "metal_linker_flags": attrs.list(attrs.arg(), default = [], doc = """
                Flags to use when linking Metal `.air` files using `metallib`.
            """),
            "metal_version": attrs.option(attrs.string(), default = None),
            "out": attrs.option(attrs.string(), default = None, doc = """
                The name of the compiled library (must end in `.metallib`). Defaults to the target's name.
            """),
            "srcs": attrs.list(attrs.source(), default = []),
            "_apple_toolchain": get_apple_resources_toolchain_attr(),
        }
    ),
)

apple_package = prelude_rule(
    name = "apple_package",
    docs = """
        An `apple_package()` rule takes the output of
        an `apple_bundle()` rule and compresses it in
        an IPA (iOS App Store Package) file.

        This rule can be customized using the config options `.buckconfig`
        and `.buckconfig`
        .
    """,
    examples = """
        ```

        apple_package(
          name = 'AppPackage',
          bundle = ':AppBundle',
        )

        ```
    """,
    further = None,
    attrs = (
        # @unsorted-dict-items
        {
            "bundle": attrs.dep(providers = [AppleBundleInfo], doc = """
                A build target identifying
                 an `apple_bundle()` rule whose output will
                 be stored in the IPA package generated by this rule.
            """),
            "ext": attrs.enum(ApplePackageExtension.values(), default = "ipa"),
            "contacts": attrs.list(attrs.string(), default = []),
            "default_host_platform": attrs.option(attrs.configuration_label(), default = None),
            "default_platform": attrs.option(attrs.string(), default = None),
            "labels": attrs.list(attrs.string(), default = []),
            "licenses": attrs.list(attrs.source(), default = []),
            "need_android_tools": attrs.bool(default = False),
            "package_name": attrs.option(attrs.string(), default = None),
            "packager": attrs.option(attrs.exec_dep(providers = [RunInfo]), default = None),
            "packager_args": attrs.list(attrs.arg(), default = []),
            "prepackaged_validators": attrs.list(
                attrs.one_of(
                    attrs.exec_dep(providers = [RunInfo]),
                    attrs.tuple(attrs.exec_dep(providers = [RunInfo]), attrs.list(attrs.arg())),
                ),
                default = [],
            ),
            "_ipa_compression_level": attrs.enum(IpaCompressionLevel.values()),
            "_ipa_package": attrs.dep(),
        } |
        apple_common.apple_tools_arg()
    ),
    impl = apple_package_impl,
)

apple_resource = prelude_rule(
    name = "apple_resource",
    docs = """
        An `apple_resource()` rule contains sets of resource directories, files and file variants
        that can be bundled in an application bundle. This rule does not have any output on its own and can
        be built only as a dependency (either direct or transitive) of
        an `apple_bundle()` rule.
    """,
    examples = """
        ```

        apple_resource(
          name = 'Images',
          files = glob([
            '*.png',
          ]),
          dirs = [
            'PrettyImages',
          ],
        )

        ```
    """,
    further = None,
    attrs = (
        # @unsorted-dict-items
        {
            "dirs": attrs.list(attrs.source(allow_directory = True), default = [], doc = """
                Set of paths of resource directories that should be placed in an application bundle.
            """),
            "content_dirs": attrs.list(attrs.source(allow_directory = True), default = [], doc = """
                Set of paths of directories containing resource files that should be placed in an application bundle. Unlike `dirs`, the directories themselves are not placed in the bundle.
            """),
            "files": attrs.list(attrs.one_of(attrs.dep(), attrs.source()), default = [], doc = """
                Set of paths of resource files that should be placed in an application bundle.
            """),
            "variants": attrs.list(attrs.source(), default = [], doc = """
                Set of paths of resource file variants that should be placed in an application bundle. The files
                 mentioned here should be placed in a directory named `$VARIANT_NAME.lproj`,
                 where `$VARIANT_NAME` is the name of the variant
                 (e.g. `Base`, `en`). This argument makes it possible to use different
                 resource files based on the active locale.
            """),
            "named_variants": attrs.dict(key = attrs.string(), value = attrs.set(attrs.source(), sorted = False), sorted = False, default = {}, doc = """
                Mapping from a variant name to the list of resource file paths which should be placed in an application bundle. Those files
                 will be placed in a directory with name equal to the corresponding key in this mapping. Keys should end with `.lproj` suffix.
                 (e.g. `Base.lproj`, `en.lproj`).
            """),
            "resources_from_deps": attrs.list(attrs.dep(), default = [], doc = """
                Set of build targets whose transitive `apple_resource`s should be considered as part of
                 the current resource when collecting resources for bundles.

                 Usually, an `apple_bundle` collects all `apple_resource` rules transitively
                 reachable through apple\\_library rules. This field allows for resources which are not reachable
                 using the above traversal strategy to be considered for inclusion in the bundle.
            """),
            "destination": attrs.option(attrs.enum(AppleResourceBundleDestination), default = None, doc = """
                Specifies the destination in the final application bundle where resource will be copied. Possible
                 values: "resources", "frameworks", "executables", "plugins", "xpcservices".
            """),
            "codesign_on_copy": attrs.bool(default = False, doc = """
                Indicates whether the files specified in the files arg in this resource should be code signed with the identity used to sign the overall bundle. This is useful for e.g.
                 dylibs or other additional binaries copied into the bundle. The caller is responsible to ensure that the file format is valid for codesigning.
            """),
            "codesign_entitlements": attrs.option(attrs.source(), default = None),
            "codesign_flags_override": attrs.option(attrs.list(attrs.string()), default = None),
            "contacts": attrs.list(attrs.string(), default = []),
            "default_host_platform": attrs.option(attrs.configuration_label(), default = None),
            "labels": attrs.list(attrs.string(), default = []),
            "licenses": attrs.list(attrs.source(), default = []),
        } |
        apple_common.skip_universal_resource_dedupe_arg()
    ),
    impl = apple_resource_impl,
    cfg = apple_resource_transition,
)

apple_test = prelude_rule(
    name = "apple_test",
    docs = """
        An `apple_test()` rule contains Objective-C/C++ code which can be built and used to test
        code contained in other rules. The tests can be executed by running `buck test`.
    """,
    examples = """
        ```

        apple_test(
          name = 'MyTest',
          info_plist = 'MyTest-Info.plist',
          preprocessor_flags = ['-fobjc-arc'],
          srcs = [
            'MyTest.m',
          ],
          deps = [
            ':MyLibrary',
          ],
          frameworks = [
            '$SDKROOT/System/Library/Frameworks/Foundation.framework',
            '$SDKROOT/System/Library/Frameworks/UIKit.framework',
            '$PLATFORM_DIR/Developer/Library/Frameworks/XCTest.framework',
          ],
        )

        ```
    """,
    further = None,
    attrs = (
        # @unsorted-dict-items
        apple_common.info_plist_arg() |
        apple_common.info_plist_substitutions_arg() |
        {
            "test_host_app": attrs.option(attrs.transition_dep(cfg = apple_test_host_app_transition), default = None, doc = """
                A build target identifying
                 an `apple_bundle()` rule that builds an
                 application bundle. Output of the specified rule will be used as a test host of this test. This
                 implies `run_test_separately`.
                 Since symbols that are defined in the test host application and its dependencies will not be
                 linked into the test binary, to make those symbols accessible to the test target they need
                 to be specified as a dependency of this target and `['-undefined', 'dynamic_lookup']`  needs to be added to this target's `linker_flags` (this will suppress undefined
                 reference errors during compilation, but if the symbols do not exist, it might result in runtime
                 crashes).
            """),
            "embed_xctest_frameworks_in_test_host_app": attrs.option(attrs.bool(), default = None, doc = """
                Controls whether a marker constraint is added to the `test_host_app`.
            """),
        } |
        cxx_common.srcs_arg() |
        cxx_common.platform_srcs_arg() |
        apple_common.headers_arg() |
        apple_common.header_path_prefix_arg() |
        apple_common.frameworks_arg() |
        cxx_common.preprocessor_flags_arg() |
        cxx_common.compiler_flags_arg() |
        cxx_common.platform_compiler_flags_arg() |
        cxx_common.linker_flags_arg() |
        apple_common.target_sdk_version() |
        buck.run_test_separately_arg(run_test_separately_type = attrs.bool(default = False)) |
        buck.test_label_arg() |
        apple_common.extra_xcode_sources() |
        apple_common.extra_xcode_files() |
        apple_common.serialize_debugging_options_arg() |
        apple_common.uses_explicit_modules_arg() |
        apple_common.apple_sanitizer_compatibility_arg() |
        apple_common.executable_name_arg() |
        apple_common.asset_catalogs_compilation_options_arg() |
        cxx_common.supported_platforms_regex_arg() |
        {
            "bridging_header": attrs.option(attrs.source(), default = None),
            "can_be_asset": attrs.option(attrs.bool(), default = None),
            "codesign_flags": attrs.list(attrs.string(), default = []),
            "codesign_identity": attrs.option(attrs.string(), default = None),
            "contacts": attrs.list(attrs.string(), default = []),
            "cxx_runtime_type": attrs.option(attrs.enum(CxxRuntimeType), default = None),
            "default_host_platform": attrs.option(attrs.configuration_label(), default = None),
            "default_platform": attrs.option(attrs.string(), default = None),
            "defaults": attrs.dict(key = attrs.string(), value = attrs.string(), sorted = False, default = {}),
            "deps": attrs.list(attrs.dep(), default = []),
            "destination_specifier": attrs.dict(key = attrs.string(), value = attrs.string(), sorted = False, default = {}),
            "devirt_enabled": attrs.bool(default = False),
            "diagnostics": attrs.dict(key = attrs.string(), value = attrs.source(), sorted = False, default = {}),
            "enable_cxx_interop": attrs.bool(default = False),
            "entitlements_file": attrs.option(attrs.source(), default = None),
            "env": attrs.option(attrs.dict(key = attrs.string(), value = attrs.arg(), sorted = False), default = None),
            "exported_header_style": attrs.enum(IncludeType, default = "local"),
            # Need to keep both `exported_headers` and `headers` for Swift mixed modules
            # to hide C++ code importing.
            "exported_headers": attrs.named_set(attrs.source(), sorted = True, default = []),
            "exported_lang_platform_preprocessor_flags": attrs.dict(key = attrs.enum(CxxSourceType), value = attrs.list(attrs.tuple(attrs.regex(), attrs.list(attrs.arg()))), sorted = False, default = {}),
            "exported_lang_preprocessor_flags": attrs.dict(key = attrs.enum(CxxSourceType), value = attrs.list(attrs.arg()), sorted = False, default = {}),
            "exported_linker_flags": attrs.list(attrs.arg(), default = []),
            "exported_platform_deps": attrs.list(attrs.tuple(attrs.regex(), attrs.set(attrs.dep(), sorted = True)), default = []),
            "exported_platform_headers": attrs.list(attrs.tuple(attrs.regex(), attrs.named_set(attrs.source(), sorted = True)), default = []),
            "exported_platform_linker_flags": attrs.list(attrs.tuple(attrs.regex(), attrs.list(attrs.arg())), default = []),
            "exported_platform_preprocessor_flags": attrs.list(attrs.tuple(attrs.regex(), attrs.list(attrs.arg())), default = []),
            "exported_post_linker_flags": attrs.list(attrs.arg(), default = []),
            "exported_post_platform_linker_flags": attrs.list(attrs.tuple(attrs.regex(), attrs.list(attrs.arg())), default = []),
            "exported_preprocessor_flags": attrs.list(attrs.arg(), default = []),
            "fat_lto": attrs.bool(default = False),
            "focused_list_target": attrs.option(attrs.dep(), default = None),
            "force_static": attrs.option(attrs.bool(), default = None),
            "header_namespace": attrs.option(attrs.string(), default = None),
            "headers_as_raw_headers_mode": attrs.option(attrs.enum(HeadersAsRawHeadersMode), default = None),
            "include_directories": attrs.set(attrs.string(), sorted = True, default = []),
            "incremental_bundling_enabled": attrs.option(attrs.bool(), default = None),
            "is_ui_test": attrs.bool(default = False),
            "lang_compiler_flags": attrs.dict(key = attrs.enum(CxxSourceType), value = attrs.list(attrs.arg()), sorted = False, default = {}),
            "lang_platform_compiler_flags": attrs.dict(key = attrs.enum(CxxSourceType), value = attrs.list(attrs.tuple(attrs.regex(), attrs.list(attrs.arg()))), sorted = False, default = {}),
            "lang_platform_preprocessor_flags": attrs.dict(key = attrs.enum(CxxSourceType), value = attrs.list(attrs.tuple(attrs.regex(), attrs.list(attrs.arg()))), sorted = False, default = {}),
            "lang_preprocessor_flags": attrs.dict(key = attrs.enum(CxxSourceType), value = attrs.list(attrs.arg()), sorted = False, default = {}),
            "libraries": attrs.list(attrs.string(), default = []),
            "licenses": attrs.list(attrs.source(), default = []),
            "link_group": attrs.option(attrs.string(), default = None),
            "link_group_map": LINK_GROUP_MAP_ATTR,
            # Used to create the shared test library. Any library deps whose `preferred_linkage` isn't "shared" will
            # be treated as "static" deps and linked into the shared test library.
            "link_style": attrs.enum(LinkableDepType, default = "static"),
            "link_whole": attrs.option(attrs.bool(), default = None),
            "linker_extra_outputs": attrs.list(attrs.string(), default = []),
            "modular": attrs.bool(default = False),
            "module_name": attrs.option(attrs.string(), default = None),
            "module_requires_cxx": attrs.bool(default = False),
            "platform_deps": attrs.list(attrs.tuple(attrs.regex(), attrs.set(attrs.dep(), sorted = True)), default = []),
            "platform_headers": attrs.list(attrs.tuple(attrs.regex(), attrs.named_set(attrs.source(), sorted = True)), default = []),
            "platform_linker_flags": attrs.list(attrs.tuple(attrs.regex(), attrs.list(attrs.arg())), default = []),
            "platform_preprocessor_flags": attrs.list(attrs.tuple(attrs.regex(), attrs.list(attrs.arg())), default = []),
            "post_linker_flags": attrs.list(attrs.arg(), default = []),
            "post_platform_linker_flags": attrs.list(attrs.tuple(attrs.regex(), attrs.list(attrs.arg())), default = []),
            # The test source code and lib dependencies should be built into a shared library.
            "preferred_linkage": attrs.enum(Linkage.values(), default = "shared"),
            "prefix_header": attrs.option(attrs.source(), default = None),
            "public_include_directories": attrs.set(attrs.string(), sorted = True, default = []),
            "public_system_include_directories": attrs.set(attrs.string(), sorted = True, default = []),
            "raw_headers": attrs.set(attrs.source(), sorted = True, default = []),
            "reexport_all_header_dependencies": attrs.option(attrs.bool(), default = None),
            "runner": attrs.option(attrs.dep(), default = None),
            "sdk_modules": attrs.list(attrs.string(), default = []),
            "skip_copying_swift_stdlib": attrs.option(attrs.bool(), default = None),
            "snapshot_reference_images_path": attrs.option(attrs.one_of(attrs.source(), attrs.string()), default = None),
            "soname": attrs.option(attrs.string(), default = None),
            "specs": attrs.option(attrs.arg(json = True), default = None),
            "static_library_basename": attrs.option(attrs.string(), default = None),
            "supports_merged_linking": attrs.option(attrs.bool(), default = None),
            "swift_compiler_flags": attrs.list(attrs.arg(), default = []),
            "swift_interface_compilation_enabled": attrs.bool(default = False),
            "swift_module_skip_function_bodies": attrs.bool(default = True),
            "swift_version": attrs.option(attrs.enum(SwiftVersion), default = None),
            "test_rule_timeout_ms": attrs.option(attrs.int(), default = None),
            "thin_lto": attrs.bool(default = False),
            "try_skip_code_signing": attrs.option(attrs.bool(), default = None),
            "ui_test_target_app": attrs.option(attrs.dep(), default = None),
            "use_submodules": attrs.bool(default = True),
            "uses_cxx_explicit_modules": attrs.bool(default = False),
            "uses_modules": attrs.bool(default = False),
            "xcode_product_type": attrs.option(attrs.string(), default = None),
        } |
        buck.allow_cache_upload_arg() |
        buck.inject_test_env_arg() |
        apple_test_extra_attrs() |
        test_common.attributes() |
        constraint_overrides.attributes
    ),
    impl = apple_test_impl,
    cfg = apple_test_target_sdk_version_transition,
)

apple_toolchain = prelude_rule(
    name = "apple_toolchain",
    docs = "",
    examples = None,
    further = None,
    attrs = (
        {
            "actool": attrs.exec_dep(providers = [RunInfo]),
            "app_intents_metadata_processor": attrs.option(attrs.exec_dep(providers = [RunInfo]), default = None),
            "app_intents_nl_training_processor": attrs.option(attrs.exec_dep(providers = [RunInfo]), default = None),
            "architecture": attrs.string(default = ""),
            "build_version": attrs.option(attrs.string(), default = None),
            "codesign": attrs.exec_dep(providers = [RunInfo]),
            "codesign_allocate": attrs.exec_dep(providers = [RunInfo]),
            "codesign_identities_command": attrs.option(attrs.exec_dep(providers = [RunInfo]), default = None),
            # Controls invocations of `ibtool`, `actool` `mapc` and `momc`
            "compile_resources_locally": attrs.bool(default = False),
            "contacts": attrs.list(attrs.string(), default = []),
            "copy_scene_kit_assets": attrs.exec_dep(providers = [RunInfo]),
            "cxx_toolchain": attrs.toolchain_dep(),
            "default_host_platform": attrs.option(attrs.configuration_label(), default = None),
            "developer_path": attrs.option(attrs.source(), default = None),
            "dsymutil": attrs.exec_dep(providers = [RunInfo]),
            "dwarfdump": attrs.option(attrs.exec_dep(providers = [RunInfo]), default = None),
            "extra_linker_outputs": attrs.set(attrs.string(), default = []),
            "ibtool": attrs.exec_dep(providers = [RunInfo]),
            "labels": attrs.list(attrs.string(), default = []),
            "libtool": attrs.exec_dep(providers = [RunInfo]),
            "licenses": attrs.list(attrs.source(), default = []),
            "lipo": attrs.exec_dep(providers = [RunInfo]),
            "mapc": attrs.option(attrs.exec_dep(providers = [RunInfo]), default = None),
            "merge_index_store": attrs.default_only(attrs.dep(providers = [RunInfo], default = "prelude//apple/tools/index:merge_index_store")),
            "metal": attrs.option(attrs.exec_dep(providers = [RunInfo]), default = None),
            "metallib": attrs.option(attrs.exec_dep(providers = [RunInfo]), default = None),
            "min_version": attrs.string(default = ""),
            "momc": attrs.exec_dep(providers = [RunInfo]),
            "objdump": attrs.option(attrs.exec_dep(providers = [RunInfo]), default = None),
            # A placeholder tool that can be used to set up toolchain constraints.
            # Useful when fat and thin toolchains share the same underlying tools via `command_alias()`,
            # which requires setting up separate platform-specific aliases with the correct constraints.
            "placeholder_tool": attrs.option(attrs.exec_dep(providers = [RunInfo]), default = None),
            "platform_path": attrs.option(attrs.source(), default = None),  # Mark as optional until we remove `_internal_platform_path`
            # Defines whether the Xcode project generator needs to check
            # that the selected Xcode version matches the one defined
            # by the `xcode_build_version` fields.
            "requires_xcode_version_match": attrs.bool(default = False),
            "sdk_environment": attrs.option(attrs.string(), default = None),
            "sdk_name": attrs.string(default = ""),
            "sdk_path": attrs.option(attrs.source(), default = None),  # Mark as optional until we remove `_internal_sdk_path`
            "swift_toolchain": attrs.option(attrs.toolchain_dep(), default = None),
            "version": attrs.option(attrs.string(), default = None),
            "watch_kit_stub_binary": attrs.option(attrs.source(), default = None),
            "work_around_dsymutil_lto_stack_overflow_bug": attrs.option(attrs.bool(), default = None),
            "xcode_build_version": attrs.option(attrs.string(), default = None),
            "xcode_version": attrs.string(),
            "xctest": attrs.exec_dep(providers = [RunInfo]),
            # TODO(T111858757): Mirror of `platform_path` but treated as a string. It allows us to
            #                   pass abs paths during development and using the currently selected Xcode.
            "_internal_platform_path": attrs.option(attrs.string(), default = None),
            # TODO(T111858757): Mirror of `sdk_path` but treated as a string. It allows us to
            #                   pass abs paths during development and using the currently selected Xcode.
            "_internal_sdk_path": attrs.option(attrs.string(), default = None),
        } |
        apple_common.apple_installer_arg()
    ),
    impl = apple_toolchain_impl,
)

core_data_model = prelude_rule(
    name = "core_data_model",
    docs = """
        An `core_data_model()` rule contains models for Apple's Core Data framework. This rule does not have any output on its own and can be built only as a dependency
        (either direct or transitive) of an `apple_bundle()` rule in which case all `core_data_model()` rules
        that the bundle rule depends on are merged and placed into the final output bundle together.
    """,
    examples = """
        ```

        core_data_model(
          name = 'MyCoreDataModel',
          path = 'MyCoreDataModel.xcdatamodeld',
        )

        ```
    """,
    further = None,
    attrs = (
        # @unsorted-dict-items
        {
            "path": attrs.source(allow_directory = True, doc = """
                Relative path of the .xcdatamodeld package directory.
            """),
            "contacts": attrs.list(attrs.string(), default = []),
            "default_host_platform": attrs.option(attrs.configuration_label(), default = None),
            "labels": attrs.list(attrs.string(), default = []),
            "licenses": attrs.list(attrs.source(), default = []),
            "module": attrs.option(attrs.string(), default = None),
        }
    ),
    impl = apple_core_data_impl,
)

prebuilt_apple_framework = prelude_rule(
    name = "prebuilt_apple_framework",
    docs = """
        A `prebuilt_apple_framework()` rule represents a set of
         Objective-C/C++ source files and is very similar to a `prebuilt_cxx_library()` rule.
    """,
    examples = """
        ```

        prebuilt_apple_framework(
          name = 'MyPrebuiltFramework',
          framework = 'myPrebuiltFramework.framework',
          preferred_linkage = 'static',
          visibility = [
            'PUBLIC'
          ]
        )

        ```
    """,
    further = None,
    attrs = (
        # @unsorted-dict-items
        {
            "preferred_linkage": attrs.enum(Linkage.values(), default = "any", doc = """
                How to link to a binary: use `dynamic` for a dynamic
                 framework, and `static` for old universal static
                 frameworks manually lipo-ed together. `dynamic` will
                 copy the frameworks into the `Frameworks` directory
                 of an Apple bundle, and configure framework search paths and linker flags.
                 `static` will copy the resources of the framework into
                 an Apple bundle.
            """),
            "binary": attrs.option(attrs.string(), default = None, doc = """
              Optional name for the binary contained in the framework. Otherwise the framework name is used.
              Therefore, if your framework binary is named something like `libFrameworkName-iPhone.a` instead
              of `FrameworkName`, you can declare this here.
            """),
            "contacts": attrs.list(attrs.string(), default = []),
            "contains_swift": attrs.bool(default = False),
            "default_host_platform": attrs.option(attrs.configuration_label(), default = None),
            "dsyms": attrs.list(attrs.source(allow_directory = True), default = []),
            "deps": attrs.list(attrs.dep(), default = []),
            "exported_linker_flags": attrs.list(attrs.string(), default = []),
            "exported_platform_linker_flags": attrs.list(attrs.tuple(attrs.regex(), attrs.list(attrs.string())), default = []),
            "framework": attrs.option(attrs.source(allow_directory = True), default = None),
            "frameworks": attrs.list(attrs.string(), default = []),
            "labels": attrs.list(attrs.string(), default = []),
            "libraries": attrs.list(attrs.string(), default = []),
            "licenses": attrs.list(attrs.source(), default = []),
            "modular": attrs.bool(default = True),
            "sdk_modules": attrs.list(attrs.string(), default = []),
            "stripped": attrs.option(attrs.bool(), default = None),
            "extra_codesign_paths": attrs.list(attrs.string(), default = [], doc = """
                A list of extra paths, relative to the framework root, that will be codesigned.
                """),
            "_stripped_default": attrs.bool(default = False),
        } |
        apple_common.apple_tools_arg() |
        apple_common.apple_toolchain_arg() |
        cxx_common.supported_platforms_regex_arg()
    ),
    impl = prebuilt_apple_framework_impl,
)

scene_kit_assets = prelude_rule(
    name = "scene_kit_assets",
    docs = "",
    examples = None,
    further = None,
    attrs = (
        # @unsorted-dict-items
        {
            "contacts": attrs.list(attrs.string(), default = []),
            "default_host_platform": attrs.option(attrs.configuration_label(), default = None),
            "labels": attrs.list(attrs.string(), default = []),
            "licenses": attrs.list(attrs.source(), default = []),
            "path": attrs.source(allow_directory = True),
        }
    ),
    impl = scene_kit_assets_impl,
)

swift_toolchain = prelude_rule(
    name = "swift_toolchain",
    docs = "",
    examples = None,
    further = None,
    attrs = (
        {
            "architecture": attrs.string(),
            "contacts": attrs.list(attrs.string(), default = []),
            "default_host_platform": attrs.option(attrs.configuration_label(), default = None),
            "labels": attrs.list(attrs.string(), default = []),
            "licenses": attrs.list(attrs.source(), default = []),
            "make_swift_comp_db": attrs.default_only(attrs.dep(providers = [RunInfo], default = "prelude//apple/tools:make_swift_comp_db")),
            "make_swift_interface": attrs.default_only(attrs.dep(providers = [RunInfo], default = "prelude//apple/tools:make_swift_interface")),
            "object_format": attrs.enum(SwiftObjectFormat.values(), default = "object"),
            # A placeholder tool that can be used to set up toolchain constraints.
            # Useful when fat and thin toolchahins share the same underlying tools via `command_alias()`,
            # which requires setting up separate platform-specific aliases with the correct constraints.
            "placeholder_tool": attrs.option(attrs.exec_dep(providers = [RunInfo]), default = None),
            "platform_path": attrs.option(attrs.source(), default = None),
            "provide_swift_debug_info": attrs.bool(default = True),
            "resource_dir": attrs.option(attrs.source(), default = None),
            "runtime_paths_for_bundling": attrs.list(attrs.string(), default = []),
            "runtime_paths_for_linking": attrs.list(attrs.string(), default = []),
            "sdk_module_path_prefixes": attrs.dict(key = attrs.string(), value = attrs.source(), default = {}),
            "sdk_modules": attrs.list(attrs.exec_dep(), default = []),  # A list or a root target that represent a graph of sdk modules (e.g Frameworks)
            "sdk_path": attrs.option(attrs.source(), default = None),  # Mark as optional until we remove `_internal_sdk_path`
            "serialized_diags_to_json": attrs.option(attrs.exec_dep(providers = [RunInfo]), default = None),
            "supports_explicit_module_debug_serialization": attrs.bool(default = False),
            "supports_incremental_file_hashing": attrs.bool(default = False),
            "supports_relative_resource_dir": attrs.bool(default = False),
            "swift_experimental_features": attrs.dict(key = attrs.enum(SwiftVersion), value = attrs.list(attrs.string()), sorted = False, default = SWIFT_VERSION_FEATURE_MAP),
            "swift_ide_test_tool": attrs.option(attrs.exec_dep(providers = [RunInfo]), default = None),
            "swift_stdlib_tool": attrs.exec_dep(providers = [RunInfo]),
            "swift_stdlib_tool_flags": attrs.list(attrs.arg(), default = []),
            "swift_upcoming_features": attrs.dict(key = attrs.enum(SwiftVersion), value = attrs.list(attrs.string()), sorted = False, default = SWIFT_VERSION_FEATURE_MAP),
            "swiftc": attrs.exec_dep(providers = [RunInfo]),
            "swiftc_flags": attrs.list(attrs.arg(), default = []),
            "use_depsfiles": attrs.bool(default = False),
            # TODO(T111858757): Mirror of `sdk_path` but treated as a string. It allows us to
            #                   pass abs paths during development and using the currently selected Xcode.
            "_internal_sdk_path": attrs.option(attrs.string(), default = None),
            "_library_interface_uses_swiftinterface": attrs.bool(default = select({
                "DEFAULT": False,
                "config//features/apple:swift_library_interface_uses_swiftinterface_enabled": True,
            })),
            "_swiftc_wrapper": attrs.exec_dep(providers = [RunInfo], default = "prelude//apple/tools:swift_exec"),
        }
    ),
    impl = swift_toolchain_impl,
)

apple_universal_executable = prelude_rule(
    name = "apple_universal_executable",
    impl = apple_universal_executable_impl,
    docs = """
        An `apple_universal_executable()` rule takes a target via its
        `binary` attribute, builds it for multiple architectures and
        combines the result into a single binary using `lipo`.

        The output of the rule is a universal binary:
        - If `config//cpu/constraints:universal-enabled` is present in the target platform.
        - If the `universal` attribute is set to `True`.

        If none of the conditions are met, then the rule acts as a nop `alias()`.

        The `universal` attribute, if present, takes precedence over constraint.
        For example, if `universal = False`, then the presence of the constraint
        would not affect the output.

        `apple_bundle()` supports building of universal binaries,
        `apple_universal_executable()` is only needed if you have a standalone
        binary target which is not embedded in an `apple_bundle()` (usually a
        CLI tool).
    """,
    examples = None,
    further = None,
    attrs = (
        {
            "executable": attrs.split_transition_dep(cfg = cpu_split_transition, doc = """
                    A build target identifying the binary which will be built for multiple architectures.
                    The target will be transitioned into different configurations, with distinct architectures.

                    The target can be one of:
                    - `apple_binary()` and `cxx_binary()`
                    - `[shared]` subtarget of `apple_library()` and `cxx_library()`
                    - `apple_library()` and `cxx_library()` which have `preferred_linkage = shared` attribute
                """),
            "labels": attrs.list(attrs.string(), default = []),
            "split_arch_dsym": attrs.bool(default = False, doc = """
                    If enabled, each architecture gets its own dSYM binary. Use this if the combined
                    universal dSYM binary exceeds 4GiB.
                """),
            "universal": attrs.option(attrs.bool(), default = None, doc = """
                    Controls whether the output is universal binary. Any value overrides the presence
                    of the `config//cpu/constraints:universal-enabled` constraint. Read the rule docs
                    for more information on resolution.
                """),
        } |
        apple_common.executable_name_for_universal_arg() |
        apple_common.apple_toolchain_arg() |
        apple_common.apple_tools_arg() |
        apple_dsymutil_attrs()
    ),
)

apple_simulators = prelude_rule(
    name = "apple_simulators",
    impl = apple_simulators_impl,
    examples = None,
    further = None,
    attrs = {
        "args": attrs.list(attrs.string(), default = []),
        "broker": attrs.exec_dep(providers = [RunInfo]),
        "idb_targets": attrs.exec_dep(providers = [RunInfo]),
        "setup_timeout_seconds": attrs.option(attrs.int(), default = None),
        "_simulator_device": attrs.default_only(attrs.string(default = read_root_config("apple", "simulator_device", ""))),
        "_simulator_os_version": attrs.default_only(attrs.string(default = read_root_config("apple", "simulator_os_version", ""))),
    },
)

apple_tools = prelude_rule(
    name = "apple_tools",
    impl = apple_tools_impl,
    docs = """
        The `apple_tools` rule exposes a set of supplementary tools
        required by the Apple rules _internally_. Such tools are not
        toolchain/SDK specific, they're just internal helper tools.
    """,
    examples = None,
    further = None,
    attrs = {
        "adhoc_codesign_tool": attrs.option(attrs.exec_dep(providers = [RunInfo]), default = None),
        "assemble_bundle": attrs.exec_dep(providers = [RunInfo]),
        "codesign_manifest_tree_postprocessor": attrs.exec_dep(providers = [RunInfo]),
        "dry_codesign_tool": attrs.exec_dep(providers = [RunInfo]),
        "framework_sanitizer": attrs.exec_dep(providers = [RunInfo]),
        "info_plist_processor": attrs.exec_dep(providers = [RunInfo]),
        "ipa_package_maker": attrs.exec_dep(providers = [RunInfo]),
        "make_modulemap": attrs.exec_dep(providers = [RunInfo]),
        "make_vfsoverlay": attrs.exec_dep(providers = [RunInfo]),
        "selective_debugging_scrubber": attrs.exec_dep(providers = [RunInfo]),
        "signing_context": attrs.exec_dep(providers = [RunInfo]),
        "signing_context_tree_postprocessor": attrs.exec_dep(providers = [RunInfo]),
        "split_arch_combine_dsym_bundles_tool": attrs.exec_dep(providers = [RunInfo]),
        "spm_packager": attrs.exec_dep(providers = [RunInfo]),
        "static_archive_linker": attrs.exec_dep(providers = [RunInfo]),
        "xcframework_maker": attrs.exec_dep(providers = [RunInfo]),
    },
)

cxx_universal_executable = prelude_rule(
    name = "cxx_universal_executable",
    impl = cxx_universal_executable_impl,
    docs = """
        A `cxx_universal_executable()` rule takes a target via its
        `binary` attribute, builds it for multiple architectures and
        combines the result into a single binary using `lipo`.

        The output of the rule is a universal binary:
        - If `config//cpu/constraints:universal-enabled` is present in the target platform.
        - If the `universal` attribute is set to `True`.

        If none of the conditions are met, then the rule acts as a nop `alias()`.

        The `universal` attribute, if present, takes precedence over constraint.
        For example, if `universal = False`, then the presence of the constraint
        would not affect the output.
    """,
    examples = None,
    further = None,
    attrs = (
        {
            "executable": attrs.split_transition_dep(cfg = cpu_split_transition, doc = """
                    A build target identifying the binary which will be built for multiple architectures.
                    The target will be transitioned into different configurations, with distinct architectures.

                    The target can be one of:
                    - `cxx_binary()`
                    - `[shared]` subtarget `cxx_library()`
                    - `cxx_library()` which have `preferred_linkage = shared` attribute
                """),
            "labels": attrs.list(attrs.string(), default = []),
            "universal": attrs.option(attrs.bool(), default = None, doc = """
                    Controls whether the output is universal binary. Any value overrides the presence
                    of the `config//cpu/constraints:universal-enabled` constraint. Read the rule docs
                    for more information on resolution.
                """),
            "_cxx_toolchain": toolchains_common.cxx(),
        } |
        apple_common.executable_name_for_universal_arg()
    ),
)

apple_ipa_package = prelude_rule(
    name = "apple_ipa_package",
    impl = apple_ipa_package_impl,
    attrs = apple_ipa_package_attribs(),
)

apple_xcframework = prelude_rule(
    name = "apple_xcframework",
    impl = apple_xcframework_impl,
    attrs = {
        "framework": attrs.split_transition_dep(cfg = framework_split_transition),
        "framework_name": attrs.option(attrs.string(), default = None),
        "framework_name_from_product_name": attrs.bool(default = False),
        "include_dsym": attrs.option(attrs.bool(), default = None),
        "platforms": attrs.list(attrs.string(), default = []),
    } | apple_common.apple_tools_arg(),
)

apple_spm_package = prelude_rule(
    name = "apple_spm_package",
    impl = apple_spm_package_impl,
    attrs = {
        "deps": attrs.list(attrs.dep(), default = []),
        "package_name": attrs.string(),
        "_apple_tools": attrs.exec_dep(default = "prelude//apple/tools:apple-tools", providers = [AppleToolsInfo]),
    },
)

apple_static_archive = prelude_rule(
    name = "apple_static_archive",
    impl = apple_static_archive_impl,
    attrs = {
        "archive_name": attrs.option(attrs.string(), default = None),
        "deps": attrs.list(attrs.dep(), default = []),
        "distribution_flat_dep": attrs.option(attrs.dep(), default = None),
        "flat_deps": attrs.list(attrs.dep(), default = []),
        "labels": attrs.list(attrs.string(), default = []),
        VALIDATION_DEPS_ATTR_NAME: VALIDATION_DEPS_ATTR_TYPE,
    } | apple_common.apple_tools_arg() | apple_common.apple_toolchain_arg(),
)

apple_selective_debugging = prelude_rule(
    name = "apple_selective_debugging",
    impl = apple_selective_debugging_impl,
    attrs = {
        "exclude_build_target_patterns": attrs.list(attrs.string(), default = []),
        "exclude_regular_expressions": attrs.list(attrs.string(), default = []),
        "include_build_target_patterns": attrs.list(attrs.string(), default = []),
        "include_regular_expressions": attrs.list(attrs.string(), default = []),
        "json_type": attrs.enum(SelectiveDebuggingJsonTypes),
        "targets_json_file": attrs.option(attrs.source(), default = None),
    } | apple_common.apple_tools_arg(),
)

apple_macos_bundle = prelude_rule(
    name = "apple_macos_bundle",
    impl = apple_macos_bundle_impl,
    attrs = apple_macos_bundle_attrs(),
    cfg = macos_transition,
)

apple_watchos_bundle = prelude_rule(
    name = "apple_watchos_bundle",
    impl = apple_watchos_bundle_impl,
    attrs = apple_watchos_bundle_attrs(),
    cfg = watch_transition,
)

apple_resource_bundle = prelude_rule(
    name = "apple_resource_bundle",
    impl = apple_resource_bundle_impl,
    attrs = (
        {
            "binary": attrs.option(attrs.split_transition_dep(cfg = cpu_split_transition), default = None),
            "copy_public_framework_headers": attrs.option(attrs.bool(), default = None),
            "deps": attrs.list(attrs.dep(), default = []),
            "extension": attrs.one_of(attrs.enum(AppleBundleExtension), attrs.string()),
            "ibtool_flags": attrs.option(attrs.list(attrs.string()), default = None),
            "info_plist": attrs.source(),
            "labels": attrs.list(attrs.string(), default = []),
            "module_map": attrs.option(attrs.one_of(attrs.enum(AppleFrameworkBundleModuleMapType), attrs.source()), default = None),
            "privacy_manifest": attrs.option(attrs.source(), default = None),
            "product_name": attrs.option(attrs.string(), default = None),
            "product_name_from_module_name": attrs.bool(default = False),
            "resource_group": attrs.option(attrs.string(), default = None),
            "resource_group_map": RESOURCE_GROUP_MAP_ATTR,
            "universal": attrs.option(attrs.bool(), default = None),
            # Only include macOS hosted toolchains, so we compile resources directly on Mac RE
            "_apple_toolchain": get_apple_resources_toolchain_attr(),
            # Because `apple_resource_bundle` is a proxy for `apple_bundle`, we need to get `name`
            # field of the `apple_bundle`, as it's used as a fallback value in Info.plist.
            "_bundle_target_name": attrs.string(),
            "_compile_resources_locally_override": attrs.option(attrs.bool(), default = None),
        } | get_apple_info_plist_build_system_identification_attrs() |
        apple_common.apple_tools_arg() |
        apple_common.asset_catalogs_compilation_options_arg() |
        apple_common.info_plist_substitutions_arg() |
        apple_common.enforce_minimum_os_plist_key()
    ),
)

apple_resource_dedupe_alias = prelude_rule(
    name = "apple_resource_dedupe_alias",
    impl = apple_resource_dedupe_alias_impl,
    attrs = {
        "actual": attrs.transition_dep(cfg = apple_resource_transition),
    } | apple_common.skip_universal_resource_dedupe_arg(),
)

mockingbird_mock = prelude_rule(
    name = "mockingbird_mock",
    impl = mockingbird_mock_impl,
    attrs = mockingbird_mock_attrs(),
)

resource_group_map = prelude_rule(
    name = "resource_group_map",
    impl = resource_group_map_impl,
    attrs = {
        "map": attrs.list(
            attrs.tuple(
                attrs.string(),
                attrs.list(
                    attrs.tuple(
                        attrs.one_of(attrs.dep(), attrs.list(attrs.dep())),
                        attrs.enum(Traversal.values()),
                        attrs.option(attrs.one_of(attrs.dep(providers = [GroupFilterInfo]), attrs.string())),
                    ),
                ),
            ),
        ),
    },
)

apple_xcuitest = prelude_rule(
    name = "apple_xcuitest",
    impl = apple_xcuitest_impl,
    attrs = apple_xcuitest_extra_attrs(),
)

apple_info_plist = prelude_rule(
    name = "apple_info_plist",
    impl = apple_info_plist_impl,
    attrs = {
        "mutations": attrs.list(attrs.one_of(
            attrs.tuple(
                attrs.enum(UpdateOperations.values()),
                attrs.dict(key = attrs.string(), value = attrs.one_of(attrs.string(), attrs.bool(), attrs.int())),
            ),
            attrs.tuple(attrs.enum(MergeOperations.values()), attrs.source()),
            attrs.tuple(attrs.enum(RestrictedMergeOperations.values()), attrs.source(), attrs.dict(key = attrs.string(), value = attrs.one_of(attrs.string(), attrs.bool()))),
        )),
        "src": attrs.source(),
        "xml": attrs.bool(default = False),
        "_apple_tools": attrs.exec_dep(default = "prelude//apple/tools:apple-tools", providers = [AppleToolsInfo]),
    },
)

apple_rules = struct(
    apple_app_intents = apple_app_intents,
    apple_asset_catalog = apple_asset_catalog,
    apple_binary = apple_binary,
    apple_bundle = apple_bundle,
    apple_info_plist = apple_info_plist,
    apple_library = apple_library,
    apple_library_for_distribution = apple_library_for_distribution,
    apple_macos_bundle = apple_macos_bundle,
    apple_metal_library = apple_metal_library,
    apple_package = apple_package,
    apple_ipa_package = apple_ipa_package,
    apple_resource = apple_resource,
    apple_test = apple_test,
    apple_toolchain = apple_toolchain,
    apple_tools = apple_tools,
    apple_resource_bundle = apple_resource_bundle,
    apple_resource_dedupe_alias = apple_resource_dedupe_alias,
    apple_selective_debugging = apple_selective_debugging,
    apple_simulators = apple_simulators,
    apple_spm_package = apple_spm_package,
    apple_static_archive = apple_static_archive,
    apple_universal_executable = apple_universal_executable,
    apple_watchos_bundle = apple_watchos_bundle,
    apple_xcframework = apple_xcframework,
    apple_xcuitest = apple_xcuitest,
    core_data_model = core_data_model,
    cxx_universal_executable = cxx_universal_executable,
    mockingbird_mock = mockingbird_mock,
    prebuilt_apple_framework = prebuilt_apple_framework,
    resource_group_map = resource_group_map,
    scene_kit_assets = scene_kit_assets,
    swift_toolchain = swift_toolchain,
)
