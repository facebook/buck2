"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[26864],{28453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>l});var r=o(96540);const t={},a=r.createContext(t);function s(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(a.Provider,{value:n},e.children)}},40111:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>i,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"developers/starlark/gc","title":"A Moving Garbage Collector","description":"This page describes a two-space garbage collector that can deal with cycles.","source":"@site/../docs/developers/starlark/gc.generated.md","sourceDirName":"developers/starlark","slug":"/developers/starlark/gc","permalink":"/docs/developers/starlark/gc","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"gc"},"sidebar":"main","previous":{"title":"Environments","permalink":"/docs/developers/starlark/environment"},"next":{"title":"Heaps and Heap References","permalink":"/docs/developers/starlark/heaps"}}');var t=o(74848),a=o(28453);const s={id:"gc"},l="A Moving Garbage Collector",i={},c=[{value:"A worked example",id:"a-worked-example",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"a-moving-garbage-collector",children:"A Moving Garbage Collector"})}),"\n",(0,t.jsx)(n.p,{children:"This page describes a two-space garbage collector that can deal with cycles."}),"\n",(0,t.jsx)(n.p,{children:"In Starlark, this pattern is used both when doing a real garbage collection, and\nwhen freezing. For both cases, it starts out with a memory block, which has\npointers referring to things inside it, and ends up with a new memory block with\nequivalent pointers inside it. However, only pointers reachable from outside the\noriginal memory block are available in the new memory block. The garbage\ncollector can deal with cyclic data structures and the time spent is\nproportional to the amount of live data in the heap (memory that is dropped is\nnot even visited)."}),"\n",(0,t.jsx)(n.h2,{id:"a-worked-example",children:"A worked example"}),"\n",(0,t.jsx)(n.p,{children:"Given a heap with the following layout:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'X := Data("world")\nY := Data("hello", X, Y)\nZ := Data("universe")\n'})}),"\n",(0,t.jsxs)(n.p,{children:["All of ",(0,t.jsx)(n.code,{children:"X"}),", ",(0,t.jsx)(n.code,{children:"Y"})," and ",(0,t.jsx)(n.code,{children:"Z"})," are memory locations. The ",(0,t.jsx)(n.code,{children:"Y"})," memory location has both\nsome data of its own (",(0,t.jsx)(n.code,{children:'"hello"'}),") and two pointers (",(0,t.jsx)(n.code,{children:"X"})," and ",(0,t.jsx)(n.code,{children:"Y"})," itself)."]}),"\n",(0,t.jsxs)(n.p,{children:["The pointers from outside the heap into the heap are known as ",(0,t.jsx)(n.em,{children:"roots"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Assuming, in the above example, that ",(0,t.jsx)(n.code,{children:"Y"})," is the only root, then, since ",(0,t.jsx)(n.code,{children:"Y"})," is\nused from outside, ",(0,t.jsx)(n.code,{children:"Y"})," must be moved to the new memory block. Consequently, the\ndata ",(0,t.jsx)(n.code,{children:"X"})," needs to be copied, but ",(0,t.jsx)(n.code,{children:"Z"})," can be dropped."]}),"\n",(0,t.jsx)(n.p,{children:"Following are the required steps for using a garbage collector:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["To copy ",(0,t.jsx)(n.code,{children:"Y"}),", allocate a value in the new heap ",(0,t.jsx)(n.code,{children:"A"})," with a sentinel value in it\n(that that sentinel is called a ",(0,t.jsx)(n.code,{children:"Blackhole"}),"). Then, turn ",(0,t.jsx)(n.code,{children:"Y"})," into a\n",(0,t.jsx)(n.code,{children:"Forward(A)"})," pointer, so that if anyone else in this cycle tries to collect\n",(0,t.jsx)(n.code,{children:"Y"}),' they immediately "forward" to the new value and the data from ',(0,t.jsx)(n.code,{children:"Y"})," is\ngrabbed so its pointers can be traversed. That results in the following:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'X := Data("world")\nY := Forward(A)\nZ := Data("universe")\n\nA := Blackhole\n'})}),"\n",(0,t.jsxs)(n.p,{children:["With ",(0,t.jsx)(n.code,{children:'Data("hello", X, Y)'})," as the current item being processed."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Walk the pointers of the current value, performing a garbage collection on\neach of them. To copy ",(0,t.jsx)(n.code,{children:"Y"}),", it can be seen that ",(0,t.jsx)(n.code,{children:"Y"})," points at a ",(0,t.jsx)(n.code,{children:"Forward(A)"}),"\nnode, so there's no need to do anything. To copy ",(0,t.jsx)(n.code,{children:"X"}),", follow the process\nstarting at step 1, but for ",(0,t.jsx)(n.code,{children:"X"})," (which ends up at ",(0,t.jsx)(n.code,{children:"B"}),"). Performing that move\nleads to the following:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'X := Forward(B)\nY := Forward(A)\nZ := Data("universe")\n\nA := Blackhole\nB := Data("world")\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Replace all the pointers with the forwarded value, and write it back over the\n",(0,t.jsx)(n.code,{children:"Blackhole"})," in ",(0,t.jsx)(n.code,{children:"A"}),". This gives the following:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'X := Forward(B)\nY := Forward(A)\nZ := Data("universe")\n\nA := Data("hello", B, A)\nB := Data("world")\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Adjust any roots pointing at ",(0,t.jsx)(n.code,{children:"Y"})," to point at ",(0,t.jsx)(n.code,{children:"A"})," and throw away the original\nheap, which produces the following:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'A := Data("hello", B, A)\nB := Data("world")\n'})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"These above four steps successfully garbage collects a cyclic data structure,\nwhile preserving the cycles and getting rid of the unused data."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);