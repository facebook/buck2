"""
Sets up all the execution platforms for buck2 builds.

buck2 execution platform resolution takes a list of execution platforms and
selects the first one that is compatible with the execution deps of a target.
execution platforms are used only for execution deps (i.e. build tools).

We have a couple different platform types here with some adhoc naming:

hybrid platform - this is a platform with both local and remote execution enabled
local_only platform - a platform with only local execution, generally these would only exist matching the host platform
remote_only platform - a platform with only remote execution
fat platform - a platform where execution may happen on one of several possible platforms. for example, a mac-linux fat platform
  could run on either mac or linux. it may be configured with linux RE workers but also enable local execution on either of a mac
  or linux host.

fat platforms are used so that we can use the cheaper linux RE workers for actions running
on a mac host while preserving the option to run those actions locally.

For fat platforms, we introduce constraint setting like `fat_platform_mac` with
values like `fat_platform_mac=some_mac_platform` and then those constraints can
be used for transitions to the specific platforms. There's a helper `fat_platform_transition`
to do a split transition to all the individual platforms to support binaries that want
to support the fat platform but need os-specific deps (for example, you could have a
simple wrapper over a c++ binary that supported a fat platform by delegating to the appropriate
os-specific binary at runtime).
"""

load("@fbsource//tools/build_defs:buckconfig.bzl", "read_bool", "read_int")
load(
    ":defs.bzl",
    "execution_platform",
    "execution_platforms",
    "fat_platform_transition_helper",
    "linux_execution_base_platforms",
    "mac_execution_base_platforms",
    "ordered_platforms_by_host_type",
)
load(":util.bzl", "fat_platform_incompatible")

prelude = native
host_is_mac = host_info().os.is_macos
host_is_linux = host_info().os.is_linux
host_is_windows = host_info().os.is_windows

local_mac_execution = read_bool("build", "enable_local_mac_execution", host_is_mac)
remote_mac_execution = read_bool("build", "enable_remote_mac_execution", True)
local_linux_execution = read_bool("build", "enable_local_linux_execution", host_is_linux)
local_windows_execution = read_bool("build", "enable_local_windows_execution", host_is_windows)

remote_execution_max_input_files_mebibytes = read_int("build", "remote_execution_max_input_files_mebibytes", 30 * 1024)
fat_platforms_enabled = read_bool("build", "enable_fat_platforms", True)
allow_hybrid_fallbacks_on_failure = read_bool("remoteexecution", "is_local_fallback_enabled_for_completed_actions")

# Those targets will result in extra data being injected into RE action keys.
# The targets listed here need to expose a BuildModeInfo provider.
remote_execution_action_key_providers = [
    "fbcode//buck2/platform/build_mode:build_mode",
]

mac_platforms = execution_platform(
    name = "macos",
    base_platform = mac_execution_base_platforms["x86_64-fbsource"],
    local_enabled = local_mac_execution,
    remote_enabled = remote_mac_execution,
    remote_execution_properties = {
        "platform": "mac",
        "subplatform": "xcode-13.4",
    },
    remote_execution_action_key_providers = remote_execution_action_key_providers,
    remote_execution_max_input_files_mebibytes = remote_execution_max_input_files_mebibytes,
    allow_hybrid_fallbacks_on_failure = allow_hybrid_fallbacks_on_failure,
) + execution_platform(
    name = "macos-minimal",
    base_platform = mac_execution_base_platforms["x86_64_minimal_xcode"],
    local_enabled = local_mac_execution,
    remote_enabled = remote_mac_execution,
    remote_execution_properties = {
        "platform": "mac",
        "subplatform": "xcode-13.4",
    },
    remote_execution_action_key_providers = remote_execution_action_key_providers,
    remote_execution_max_input_files_mebibytes = remote_execution_max_input_files_mebibytes,
    allow_hybrid_fallbacks_on_failure = allow_hybrid_fallbacks_on_failure,
)

linux_platforms = execution_platform(
    name = "linux",
    base_platform = linux_execution_base_platforms["platform010"],
    local_enabled = local_linux_execution,
    remote_enabled = True,
    remote_execution_properties = {
        "platform": "linux-remote-execution",
    },
    remote_execution_action_key_providers = remote_execution_action_key_providers,
    remote_execution_max_input_files_mebibytes = remote_execution_max_input_files_mebibytes,
    allow_hybrid_fallbacks_on_failure = allow_hybrid_fallbacks_on_failure,
)

windows_platforms = execution_platform(
    name = "windows",
    base_platform = "ovr_config//platform/windows:x86_64-fbsource-debug",
    local_enabled = local_windows_execution,
    remote_enabled = False,
    remote_execution_properties = {
        "platform": "windows",
    },
    remote_execution_action_key_providers = remote_execution_action_key_providers,
    remote_execution_max_input_files_mebibytes = remote_execution_max_input_files_mebibytes,
    allow_hybrid_fallbacks_on_failure = allow_hybrid_fallbacks_on_failure,
    use_windows_path_separators = True,
)

fat_mac_linux = execution_platform(
    name = "fat_mac_linux",
    base_platform = ":fat_platform_posix_platform009",
    local_enabled = True,
    remote_enabled = True,
    remote_execution_properties = {
        "platform": "linux-remote-execution",
    },
    remote_execution_action_key_providers = remote_execution_action_key_providers,
    remote_execution_max_input_files_mebibytes = remote_execution_max_input_files_mebibytes,
    make_dash_only_platforms = False,
    allow_hybrid_fallbacks_on_failure = allow_hybrid_fallbacks_on_failure,
)

fat_platforms = fat_mac_linux if fat_platforms_enabled else []

execution_platforms(
    name = "platforms",
    # Before execution platforms, we'd generally use the host platform as the
    # execution platform. We flip these orders on different hosts to roughly
    # preserve that behavior.
    # TODO(cjhopman): Our long-term goal has to be to remove this. All build
    # tooling will first need to be updated to properly specify their execution
    # requirements.
    platforms = (
        fat_platforms +
        ordered_platforms_by_host_type(windows_platforms, mac_platforms, linux_platforms)
    ),
)

prelude.constraint_setting(
    name = "runs_remote",
)

prelude.constraint_value(
    name = "may_run_remote",
    constraint_setting = ":runs_remote",
    visibility = ["PUBLIC"],
)

prelude.constraint_setting(
    name = "runs_local",
    visibility = ["PUBLIC"],
)

prelude.constraint_value(
    name = "may_run_local",
    constraint_setting = ":runs_local",
    visibility = ["PUBLIC"],
)

prelude.constraint_setting(
    name = "runs_only",
)

prelude.constraint_value(
    name = "runs_only_local",
    constraint_setting = ":runs_only",
    visibility = ["PUBLIC"],
)

prelude.constraint_value(
    name = "runs_only_remote",
    constraint_setting = ":runs_only",
    visibility = ["PUBLIC"],
)

prelude.constraint_setting(
    name = "fat_platform_marker",
)

prelude.constraint_value(
    name = "fat_platform_enabled",
    constraint_setting = ":fat_platform_marker",
    visibility = ["PUBLIC"],
)

prelude.constraint_setting(
    name = "fat_platform_mac",
)

# This sets up a fat_platform_mac=specific_platform for each execution platform
# in the mac platforms (and then the same for linux). The main use for these is
# for the fat_platform_transition to know the platforms to transition to.
[
    prelude.constraint_value(
        name = "fat_platform_mac={}".format(name),
        constraint_setting = ":fat_platform_mac",
    )
    for (name, _value) in mac_execution_base_platforms.items()
]

prelude.constraint_setting(
    name = "fat_platform_linux",
)

[
    prelude.constraint_value(
        name = "fat_platform_linux={}".format(name),
        constraint_setting = ":fat_platform_linux",
        visibility = ["PUBLIC"],
    )
    for (name, _value) in linux_execution_base_platforms.items()
]

prelude.platform(
    name = "fat_platform_posix_platform009",
    # TODO(cjhopman): we probably want to actually have some base os-agnostic
    # platform that all of these, including the fat platform, depend on, but
    # the fbsource platforms just aren't that useful yet.
    constraint_values = [
        ":fat_platform_enabled",
        ":fat_platform_mac=x86_64-fbsource",
        ":fat_platform_linux=platform009",
    ],
    visibility = ["PUBLIC"],
)

# This is mostly here for a rule type to add a dependency on it to mark all
# instances of that rule type as incompatible with a fat platform. Ideally,
# toolchains could affect the target compatibility of their users directly but
# toolchains are currently all exec deps and so cannot do that. We'd like
# buck2 to support a form of dep that inherited its users execution platform
# so that toolchains could basically get visibility and affect both target and
# execution configuration, but that's not implemented yet.
export_file(
    name = "fat_platform_incompatible",
    src = "TARGETS.v2",
    target_compatible_with = fat_platform_incompatible(),
)

# This is just a helper used by the fat_platform_transition in fat_platforms.bzl
fat_platform_transition_helper(
    name = "fat_platform_transition_helper",
    mac = [[":fat_platform_mac={}".format(platform_name), platform] for (platform_name, platform) in mac_execution_base_platforms.items()],
    linux = [[":fat_platform_linux={}".format(platform_name), platform] for (platform_name, platform) in linux_execution_base_platforms.items()],
    visibility = ["PUBLIC"],
)
