---
id: build_report
title: Build Report
---

The build report is a JSON file that you can ask buck to output which contains
structured information about the result of your build. It is particularly
valuable for its reporting of _unsuccessful_ outcomes in addition to
_successful_ ones; usually, most use cases that only need to care about
successful outcomes are well served by direct usage of the CLI.

To request a build report, pass `--build-report <path>` to `buck build` on the
CLI.

At a high level, the build report outputs information for each of the targets
that you requested to have built on the CLI. As a result, it may report
information for more than one configuration or subtarget of a target. For
example, this can happen if you passed `--target-platforms` or built `:target`
and `:target[sub]`.

## Schema

```python
BuildReport {
    # A unique ID identifying this buck invocation. Currently a UUID, however
    # that may change in the future.
    trace_id: str,

    # True if all requested targets built successfully
    success: bool,

    # The error category for the build, in case it failed. One of "USER", "INFRA", "ENVIRONMENT".
    error_category: str,

    # The absolute path to the project root
    project_root: Path,

    # The results of the build, categorized by unconfigured target along with
    # any potential modifiers from the `?modifier` syntax
    results: dict[TargetLabelWithModifiers, BuildReportEntry],

    # A cache for error message lookup. This is meant for deduplicating strings
    # that might otherwise appear many times in the build report and cause an
    # unnecessary size increase. They keys are used in other fields in the build
    # report in reference to these strings.
    strings: dict[str, str],

    # BUCK1 BACKCOMPAT ONLY!
    #
    # Currently always empty. Will be filled in if a flag is passed in the future.
    #
    # A map from targets with potential `?modifier` modifiers that failed to build to error messages describing the
    # failure.
    failures: dict[TargetLabelWithModifiers, str],

    # Build metrics aggregated across all targets.
    build_metrics: AllTargetsBuildMetrics,

    # Set sketch of configured target graph stored in a hex string.
    # Enabeld by setting `-c buck2.log_total_configured_graph_sketch=true`.
    total_configured_graph_sketch: Optional[str],

    # Set sketch of unconfigured target labels in configured target graph
    # stored in a hex string.
    # Enabeld by setting
    # `-c buck2.log_total_configured_graph_unconfigured_sketch=true`.
    total_configured_graph_unconfigured_sketch: Optional[str],

    # Reports data about each configuration encountered as part of the build,
    # if requested. Currently shows total unconfigured sketch per configuration
    # if `-c buck2.log_total_per_configuration_sketch=true` is set.
    per_configuration_data: dict[str, PerConfigurationData],
}

BuildReportEntry {
    # The results of building the target in the given configurations
    configured: dict[Configuration, ConfiguredBuildReportEntry],

    # Errors encountered while building this target.
    #
    # Note that this does not include the errors that are found within the
    # `ConfiguredBuildReportEntry`s. Instead, it includes additional errors
    # which could not be associated with a specific configuration of the
    # target, typically because they occurred before the target could be
    # configured.
    errors: list[Error],

    # BUCK1 BACKCOMPAT ONLY!
    #
    # The two fields below are included for buck1 backwards compatibility only.
    # They are both computed by aggregating across all the configured targets in
    # the way you might expect.
    success: "FAIL" | "SUCCESS,
    outputs: dict[str, list[Path]],

    # The path to the package containing this target, relative to the project
    # root. This is the source code location for this target.
    package_project_relative_path: Optional[str]
}

ConfiguredBuildReportEntry {
    # Did this target build successfully or not?
    success: "FAIL" | "SUCCESS,

    # A map of subtargets that were built to a list of the successfully built
    # outputs for that subtarget.
    #
    # The keys are generated by joining the subtargets with a `|`. For example,
    # if you request to have `:target` and `:target[foo][bar]` built on the CLI,
    # this list will contain one entry for `""` and one for `"foo|bar"`.
    outputs: dict[str, list[Path]],

    # The number of targets in the configured dependency graph of this target.
    #
    # This is only included if `-c buck2.log_configured_graph_size=true` is set.
    # Otherwise, it is left as None.
    configured_graph_size: Optional[uint],

    # Information about this particular artifact. Includes things like its hash, whether it is
    # executable, etc.
    artifact_info: dict[str, ArtifactInfoFile | ArtifactInfoSymlink | ArtifactInfoExternalSymlink],

    # Set sketch of configured target graph stored in a hex string.
    # Enabeld by setting `-c buck2.log_configured_graph_sketch=true`.
    configured_graph_sketch: Optional[str],

    # Metrics for this target. Represents the aggregated metrics for top level targets.
    metrics: TargetBuildMetrics,

    # Set sketch of unconfigured taret labels in configured target graph
    # stored in a hex string.
    # Enabeld by setting
    # `-c buck2.log_configured_graph_unconfigured_sketch=true`.
    configured_graph_unconfigured_sketch: Optional[str],
}

AllTargetsBuildMetrics {
    #  The total number of nodes in the action graph, if we were able to fully traverse it.
    action_graph_size: Optional[u64],

    # Metrics aggregated across all targets.
    metrics: AggregatedBuildMetrics,
}

TargetBuildMetrics {
    # The total number of nodes in the action graph, if we were able to fully traverse it.
    action_graph_size: Optional[u64],

    # These are metrics aggregated without normalization.
    metrics: AggregatedBuildMetrics

    # "Amortized" metrics are aggregated by dividing the metric/cost evenly
    # across all top-level targets that require the node that produced the
    # metric. For example, when building four targets `//:foo`, `//:bar`,
    # `//:baz`, `//:qux` if some intermediate action is required for each of the
    # first three, its costs will be aggregated to them each multiplied by 1/3
    # while no cost will be attributed to `//:qux`.
    amortized_metrics: AggregatedBuildMetrics

    # Max value for peak memory usage across all remote actions.
    remote_max_memory_peak_bytes: Optional[u64]

    # Max value for peak memory usage across all local actions.
    local_max_memory_peak_bytes: Optional[u64]
}

AggregatedBuildMetrics {
    full_graph_execution_time_ms: float
    full_graph_output_size_bytes: float

    local_execution_time_ms: float
    remote_execution_time_ms: float

    local_executions: float
    remote_executions: float
    remote_cache_hits: float

    analysis_retained_memory: float
    declared_actions: float
}

PerConfigurationData {
    # Unique hash of the configuration. This is same hash used in buck-out.
    hash: str,
    # Sketch of unconfigured target labels for all targets of that configuration
    total_unconfigured_sketch: str,
}

Error {
    # The stringified hash of the same stringified error message that is shown to the user on the
    # console. The hash is stored as the key in the `strings` cache of the `BuildReport`
    message_content: str,

    # Structured action error. Present only if the error was actually an action error
    action_error: Optional[ActionError],

    # An index that can be used to detect duplicate errors. Two errors with the
    # same cause index have the same cause. Note that that does not mean that
    # they have the same error message.
    cause_index: uint,

    # List of error tags associated with the error. The error tags provide hints to the error category
    # that the error is associated to as determined by Buck2 internally. This is meant to classify errors
    # more precisely, helping developers better understand the nature of the error.
    error_tags: list[str],
}

ActionError {
    # The action key
    key: ActionKey,

    # The action name
    name: ActionName,

    # Digest of the action
    digest: str,

    # Stringified hash of the stderr of the action
    stderr: str,

    # Stringified hash of the stdout of the action
    stdout: str,

    # Stringified hash of the same stringified error message that is provided by the action
    error: str,

    # Optional list of error categorizations provided by an error handler which is invoked
    # in the event of a failed action, or an error message if the error handler failed.
    error_diagnostics: Optional[ActionErrorDiagnostics],
}

ActionKey {
    # The configured target, anon target, or bxl function which owns this action
    owner: str,
}

ActionName {
    # The category of the action
    category: str,

    # The optional identifier of the action
    identifier: Optional[str],
}

enum ActionErrorDiagnostics {
    # The list of sub errors if the error handler succeeded
    sub_errors: list[ActionSubError],

    # The stringified hash of the error message if the error handler failed
    handler_invocation_error: String,
}

ActionSubError {
    # Name of the error category. The category should be finer grain error categorizations
    # provided by the rule authors, and tend to be language specific. These should not be
    # any kind of shared concepts among all errors for all languages/rules. For example,
    # timeouts and infra errors should not go here - buck2 tries to categorize these types
    # of errors automatically. An example of a finer grain error category may be the error
    # code for rustc outputs.
    category: str,

    # The stringified hash of the extra message provided for the specific sub-error category.
    message_content: str,

    # List of error locations, if any
    locations: Optional[list[ActionErrorLocation]],
}

ActionErrorLocation {
    # File path where the error appeared, preferably either project-relative or absolute.
    file: str,

    # Optional line number
    line: Optional[u64]
}

ArtifactInfoFile {
    # The type of this artifact info. This will always be "file".
    kind: str,

    # CAS digest for this file, includes hash and file size.
    digest: str,
    # Whether this file is executable.
    is_exec: bool,
}

ArtifactInfoSymlink {
    # The type of this artifact info. This will always be "symlink".
    kind: str,

    # Symlink target path relative to the root directory.
    symlink_rel_path: str
}

ArtifactInfoExternalSymlink {
    # The type of this artifact info. This will always be "external_symlink".
    kind: str,

    # Symlink target path.
    target: str,
    # An optional trailing path component. Join this with the `target`
    field to get the full symlink file path.
    remaining_path: Optional[str],
}
```

### On Compatibility

The format of the build report is generally stable. However, note that new
fields may be added at any time, and you should ensure this does not cause your
parsing to fail.

A number of fields above are marked as being for buck1 backwards compatibility
only. These fields all have superior alternatives available in the build report
already. We would strongly prefer that new code neither use nor parse them, as
this increases the likelihood that they can be removed one day.

The build report additionally outputs a few fields that are intentionally not
documented here. Those fields are even less useful than ones documented as being
for backwards compatibility only, and even closer to removal. **Please** avoid
using or parsing these if at all possible.

### Limitations

The build report currently has at least the following limitations:

1.  It includes only one action error per failed target. This is the expected
    behavior when `--keep-going` is not passed, but when `--keep-going` is
    passed, this is a bug.
1.  It is currently not generated when a non-existent package is specified on
    the command line. This is also a bug.
1.  It cannot be requested for any buck2 command other than `build`
1.  Errors do not contain any additional metadata outside of the error message.
    This will be made available as such metadata is available in buck2.
1.  The "failures" field is always empty. This will be changed under a
    backcompat opt-in flag in the future.

Finally, it's worth raising that the concept of error deduplication has some
fundamental limitations; if two targets both refer to the same non-existent
dependency, do those errors have the same cause (the dependency doesn't exist)
or different causes (each target is individually broken)? As a result, the exact
details of when two errors are considered to have the same cause are not
generally stable, and may not always be what you expect.
