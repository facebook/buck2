"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[53721],{28453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>d});var c=i(96540);const r={},s=c.createContext(r);function l(e){const n=c.useContext(s);return c.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),c.createElement(s.Provider,{value:n},e.children)}},35903:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>a,frontMatter:()=>l,metadata:()=>c,toc:()=>t});const c=JSON.parse('{"id":"bxl/explanation/bxl_cquery_vs_cli_cquery","title":"BXL cquery vs. Buck2 CLI cquery - Divergence in Configuration Handling","description":"Overview","source":"@site/../docs/bxl/explanation/bxl_cquery_vs_cli_cquery.md","sourceDirName":"bxl/explanation","slug":"/bxl/explanation/bxl_cquery_vs_cli_cquery","permalink":"/docs/bxl/explanation/bxl_cquery_vs_cli_cquery","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"bxl_cquery_vs_cli_cquery","title":"BXL cquery vs. Buck2 CLI cquery - Divergence in Configuration Handling"},"sidebar":"main","previous":{"title":"Understanding Labels and Nodes in Buck2","permalink":"/docs/bxl/explanation/labels_and_nodes"},"next":{"title":"FAQs","permalink":"/docs/bxl/faq"}}');var r=i(74848),s=i(28453);const l={id:"bxl_cquery_vs_cli_cquery",title:"BXL cquery vs. Buck2 CLI cquery - Divergence in Configuration Handling"},d=void 0,o={},t=[{value:"Overview",id:"overview",level:2},{value:"A Concrete Example",id:"a-concrete-example",level:2},{value:"<code>buck2 cquery</code>",id:"buck2-cquery",level:3},{value:"<code>cquery</code> in bxl",id:"cquery-in-bxl",level:3},{value:"Core Difference",id:"core-difference",level:2},{value:"CLI <code>buck2 cquery</code>",id:"cli-buck2-cquery",level:3},{value:"Phase 1: Target Resolution",id:"phase-1-target-resolution",level:4},{value:"Phase 2: run rdeps function",id:"phase-2-run-rdeps-function",level:4},{value:"<code>cquery</code> in bxl",id:"cquery-in-bxl-1",level:3},{value:"Phase 1: resolve arguments to configured target nodes if needed",id:"phase-1-resolve-arguments-to-configured-target-nodes-if-needed",level:4},{value:"Phase 2: run rdeps function",id:"phase-2-run-rdeps-function-1",level:4},{value:"Aligning BXL with CLI Behavior",id:"aligning-bxl-with-cli-behavior",level:2},{value:"Reflection: Philosophy of Configuration Management in CLI and cquery",id:"reflection-philosophy-of-configuration-management-in-cli-and-cquery",level:2}];function h(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(n.p,{children:["The command ",(0,r.jsx)(n.code,{children:"buck2 cquery"})," and function ",(0,r.jsx)(n.code,{children:"cquery"})," in bxl share the same goal but\nsometimes yield different results. This document explains why these commands\nmight produce divergent results for identical-looking queries and how their\nunderlying mechanisms diverge. By contrasting their approaches to configuration\nuniverses, we clarify how to align BXL scripts with CLI behavior for consistent\nresults."]}),"\n",(0,r.jsx)(n.h2,{id:"a-concrete-example",children:"A Concrete Example"}),"\n",(0,r.jsx)(n.p,{children:"Imagine we have:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A target ",(0,r.jsx)(n.code,{children:"X"})," with a default configuration ",(0,r.jsx)(n.code,{children:"cfg_a"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Targets ",(0,r.jsx)(n.code,{children:"A"}),", ",(0,r.jsx)(n.code,{children:"B"}),", and ",(0,r.jsx)(n.code,{children:"C"})," in ",(0,r.jsx)(n.code,{children:"root//path/..."})," with a default configuration\n",(0,r.jsx)(n.code,{children:"cfg_b"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Both ",(0,r.jsx)(n.code,{children:"A"})," and ",(0,r.jsx)(n.code,{children:"C"})," directly depend on ",(0,r.jsx)(n.code,{children:"X"}),", but each dependency is configured as\n",(0,r.jsx)(n.code,{children:"cfg_b"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Assume that our goal is to determine the direct reverse dependencies of ",(0,r.jsx)(n.code,{children:"X"}),"\nwithin ",(0,r.jsx)(n.code,{children:"root//path/..."}),". Let's look at two approaches:"]}),"\n",(0,r.jsx)(n.h3,{id:"buck2-cquery",children:(0,r.jsx)(n.code,{children:"buck2 cquery"})}),"\n",(0,r.jsx)(n.p,{children:"We can do a query like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"buck2 cquery 'rdeps(root//path/..., X, 1)`\n"})}),"\n",(0,r.jsxs)(n.p,{children:["It will return ",(0,r.jsx)(n.code,{children:"A (cfg_b)"}),", ",(0,r.jsx)(n.code,{children:"C (cfg_b)"})," and ",(0,r.jsx)(n.code,{children:"X(cfg_b)"})]}),"\n",(0,r.jsxs)(n.h3,{id:"cquery-in-bxl",children:[(0,r.jsx)(n.code,{children:"cquery"})," in bxl"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'\ndef _main(ctx):\n    res = ctx.cquery().rdeps("root//path/...", "X", depth = 1)\n    ctx.output.print(res)\n\nmain = bxl_main(\n    cli_args = {},\n    impl = _main\n)\n\n'})}),"\n",(0,r.jsx)(n.p,{children:"It will return empty."}),"\n",(0,r.jsx)(n.h2,{id:"core-difference",children:"Core Difference"}),"\n",(0,r.jsxs)(n.h3,{id:"cli-buck2-cquery",children:["CLI ",(0,r.jsx)(n.code,{children:"buck2 cquery"})]}),"\n",(0,r.jsxs)(n.p,{children:["When no ",(0,r.jsx)(n.a,{href:"/docs/concepts/glossary#target-universe",children:"target universe"})," is\nprovided via the ",(0,r.jsx)(n.code,{children:"--target-universe"})," CLI argument, it constructs the\n",(0,r.jsx)(n.a,{href:"/docs/concepts/glossary#target-universe",children:"target universe"})," though the\nfollowing process:"]}),"\n",(0,r.jsx)(n.h4,{id:"phase-1-target-resolution",children:"Phase 1: Target Resolution"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pattern Resolution"}),": Resolve target patterns (",(0,r.jsx)(n.code,{children:"root//path/..."})," and ",(0,r.jsx)(n.code,{children:"X"}),") to\nobtain unconfigured targets: ",(0,r.jsx)(n.code,{children:"A"}),", ",(0,r.jsx)(n.code,{children:"B"}),", ",(0,r.jsx)(n.code,{children:"C"}),", and ",(0,r.jsx)(n.code,{children:"X"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Target Configuration"}),": With no additional configuration arguments, the\ndefault target platform is applied. This produces configured targets:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"A (cfg_b)"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"B (cfg_b)"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"C (cfg_b)"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"X (cfg_a)"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Universe Construction"}),": Build the target universe using these configured\ntargets. Since ",(0,r.jsx)(n.code,{children:"A (cfg_b)"})," and ",(0,r.jsx)(n.code,{children:"C (cfg_b)"})," depend on ",(0,r.jsx)(n.code,{children:"X (cfg_b)"}),", the\nuniverse includes:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"A (cfg_b)\nB (cfg_b)\nC (cfg_b)\nX (cfg_a)\nX (cfg_b)\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Resolve the literal in the universe"}),": Lookup the original patterns within\nthe constructed universe:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"root//path/..."})," resolves to ",(0,r.jsx)(n.code,{children:"A (cfg_b)"}),", ",(0,r.jsx)(n.code,{children:"B (cfg_b)"}),", ",(0,r.jsx)(n.code,{children:"C (cfg_b)"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"X"})," resolves to both configurations: ",(0,r.jsx)(n.code,{children:"X (cfg_a)"})," and ",(0,r.jsx)(n.code,{children:"X (cfg_b)"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"phase-2-run-rdeps-function",children:"Phase 2: run rdeps function"}),"\n",(0,r.jsxs)(n.p,{children:["It will go though ",(0,r.jsx)(n.code,{children:"rdeps"})," logic:"]}),"\n",(0,r.jsxs)(n.p,{children:["Within the universe of targets under ",(0,r.jsx)(n.code,{children:"root//path/..."})," (i.e., ",(0,r.jsx)(n.code,{children:"A (cfg_b)"}),",\n",(0,r.jsx)(n.code,{children:"B (cfg_b)"}),", and ",(0,r.jsx)(n.code,{children:"C (cfg_b)"}),"), identify the targets whose direct dependencies\ninclude ",(0,r.jsx)(n.code,{children:"X (cfg_a)"})," or ",(0,r.jsx)(n.code,{children:"X (cfg_b)"}),". In this case, those targets are ",(0,r.jsx)(n.code,{children:"A (cfg_b)"}),"\nand ",(0,r.jsx)(n.code,{children:"C (cfg_b)"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Furthermore, if ",(0,r.jsx)(n.code,{children:"X (cfg_a)"})," or ",(0,r.jsx)(n.code,{children:"X (cfg_b)"})," itself exists within the universe of\n",(0,r.jsx)(n.code,{children:"A (cfg_b)"}),", ",(0,r.jsx)(n.code,{children:"B (cfg_b)"}),", and ",(0,r.jsx)(n.code,{children:"C (cfg_b)"}),", it should also be included in the\nresults. In this case, ",(0,r.jsx)(n.code,{children:"X (cfg_b)"})," is part of the universe, so it is included."]}),"\n",(0,r.jsxs)(n.p,{children:["Thus, the final result is ",(0,r.jsx)(n.code,{children:"A (cfg_b)"}),", ",(0,r.jsx)(n.code,{children:"C (cfg_b)"}),", and ",(0,r.jsx)(n.code,{children:"X (cfg_b)"}),"."]}),"\n",(0,r.jsxs)(n.h3,{id:"cquery-in-bxl-1",children:[(0,r.jsx)(n.code,{children:"cquery"})," in bxl"]}),"\n",(0,r.jsxs)(n.p,{children:["The bxl logic differs from the ",(0,r.jsx)(n.code,{children:"buck2 cquery"})," approach."]}),"\n",(0,r.jsx)(n.h4,{id:"phase-1-resolve-arguments-to-configured-target-nodes-if-needed",children:"Phase 1: resolve arguments to configured target nodes if needed"}),"\n",(0,r.jsx)(n.p,{children:"If the arguments are not configured target(s), apply the default target platform\n(if not given) to do the configurations. So in this case:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The first argument resolves to ",(0,r.jsx)(n.code,{children:"A (cfg_b)"}),", ",(0,r.jsx)(n.code,{children:"B (cfg_b)"})," and ",(0,r.jsx)(n.code,{children:"C (cfg_b)"})]}),"\n",(0,r.jsxs)(n.li,{children:["The second argument resolves to ",(0,r.jsx)(n.code,{children:"X (cfg_a)"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"phase-2-run-rdeps-function-1",children:"Phase 2: run rdeps function"}),"\n",(0,r.jsxs)(n.p,{children:['This phase follows the same logic of "Phase 2" in CLI ',(0,r.jsx)(n.code,{children:"buck2 cquery"})]}),"\n",(0,r.jsxs)(n.p,{children:["But in this case, the second argument is different, it only has ",(0,r.jsx)(n.code,{children:"X (cfg_a)"}),".\nSince ",(0,r.jsx)(n.code,{children:"A (cfg_b)"}),", ",(0,r.jsx)(n.code,{children:"B (cfg_b)"})," and ",(0,r.jsx)(n.code,{children:"C (cfg_b)"})," do not directly depend on\n",(0,r.jsx)(n.code,{children:"X (cfg_a)"}),", the result will be empty here."]}),"\n",(0,r.jsx)(n.h2,{id:"aligning-bxl-with-cli-behavior",children:"Aligning BXL with CLI Behavior"}),"\n",(0,r.jsx)(n.p,{children:"To replicate the same results in BXL, you should provide a universe explicitly:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Create a universe of all arguments"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'universe = ctx.target_universe(["root//path/...", "X"])\n'})}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsx)(n.li,{children:"Lookup args in the universe"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'arg0 = universe.lookup("root//path/...")\narg1 = universe.lookup("X")\n'})}),"\n",(0,r.jsxs)(n.ol,{start:"3",children:["\n",(0,r.jsx)(n.li,{children:"Run cquery"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"res = ctx.cquery().rdeps(arg0, arg1, depth=1)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Alternatively, you can also achieve the same result with a single command:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"res = ctx.cquery().eval('rdeps(root//path/..., X, 1)')\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"ctx.cquery().eval()"})," will do same logic when we do in CLI"]}),"\n",(0,r.jsx)(n.h2,{id:"reflection-philosophy-of-configuration-management-in-cli-and-cquery",children:"Reflection: Philosophy of Configuration Management in CLI and cquery"}),"\n",(0,r.jsx)(n.p,{children:"The divergence between CLI and BXL cquery reflects a broader design trade-off:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"CLI: Optimized for user-friendliness, abstracting configuration logic."}),"\n",(0,r.jsx)(n.li,{children:"BXL: Prioritizes flexibility for advanced use cases, requiring explicit\ncontrol (such as ability to provide target universes)."}),"\n"]})]})}function a(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}}}]);