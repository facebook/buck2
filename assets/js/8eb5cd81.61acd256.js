"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[63613],{28453:(e,t,r)=>{r.d(t,{R:()=>o,x:()=>s});var n=r(96540);const a={},d=n.createContext(a);function o(e){const t=n.useContext(d);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),n.createElement(d.Provider,{value:t},e.children)}},48049:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>i,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"api/bxl/ConfiguredTargetNode","title":"ConfiguredTargetNode","description":"ConfiguredTargetNode.attrs\\\\_eager","source":"@site/../docs/api/bxl/ConfiguredTargetNode.md","sourceDirName":"api/bxl","slug":"/api/bxl/ConfiguredTargetNode","permalink":"/docs/api/bxl/ConfiguredTargetNode","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"apiSidebar","previous":{"title":"ConfiguredAttr","permalink":"/docs/api/bxl/ConfiguredAttr"},"next":{"title":"ConfiguredTargetSet","permalink":"/docs/api/bxl/ConfiguredTargetSet"}}');var a=r(74848),d=r(28453),o=r(56289);const s={},l="ConfiguredTargetNode",i={},c=[{value:"ConfiguredTargetNode.attrs_eager",id:"configuredtargetnodeattrs_eager",level:2},{value:"ConfiguredTargetNode.attrs_lazy",id:"configuredtargetnodeattrs_lazy",level:2},{value:"ConfiguredTargetNode.buildfile_path",id:"configuredtargetnodebuildfile_path",level:2},{value:"ConfiguredTargetNode.deps",id:"configuredtargetnodedeps",level:2},{value:"ConfiguredTargetNode.get_attr",id:"configuredtargetnodeget_attr",level:2},{value:"ConfiguredTargetNode.get_attrs",id:"configuredtargetnodeget_attrs",level:2},{value:"ConfiguredTargetNode.get_source",id:"configuredtargetnodeget_source",level:2},{value:"ConfiguredTargetNode.has_attr",id:"configuredtargetnodehas_attr",level:2},{value:"ConfiguredTargetNode.label",id:"configuredtargetnodelabel",level:2},{value:"ConfiguredTargetNode.oncall",id:"configuredtargetnodeoncall",level:2},{value:"ConfiguredTargetNode.resolved_attrs_eager",id:"configuredtargetnoderesolved_attrs_eager",level:2},{value:"ConfiguredTargetNode.resolved_attrs_lazy",id:"configuredtargetnoderesolved_attrs_lazy",level:2},{value:"ConfiguredTargetNode.rule_kind",id:"configuredtargetnoderule_kind",level:2},{value:"ConfiguredTargetNode.rule_type",id:"configuredtargetnoderule_type",level:2},{value:"ConfiguredTargetNode.sources",id:"configuredtargetnodesources",level:2},{value:"ConfiguredTargetNode.unwrap_forward",id:"configuredtargetnodeunwrap_forward",level:2}];function h(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",p:"p",pre:"pre",...(0,d.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"configuredtargetnode",children:"ConfiguredTargetNode"})}),"\n",(0,a.jsx)(t.h2,{id:"configuredtargetnodeattrs_eager",children:"ConfiguredTargetNode.attrs_eager"}),"\n",(0,a.jsx)("pre",{class:"language-python",children:(0,a.jsx)("code",{children:"def ConfiguredTargetNode.attrs_eager()"})}),"\n",(0,a.jsxs)(t.p,{children:["Returns a struct of all the attributes of this target node. The structs fields are the attributes names, and the values are [",(0,a.jsx)(t.code,{children:"StarlarkConfiguredAttr"}),"]."]}),"\n",(0,a.jsxs)(t.p,{children:["If you need to access many or all attrs on the same node, then this is the preferred way. Otherwise,\nusing ",(0,a.jsx)(t.code,{children:"attrs_lazy()"})," would be a better option for only accessing only a few attrs, although this really\ndepends on what kind of attrs are on the node. Benchmarking performance will give you the best\nindication on which method to use."]}),"\n",(0,a.jsxs)(t.p,{children:["You should store the result of this function call for further usage in the code rather than calling\n",(0,a.jsx)(t.code,{children:"attrs_eager()"})," each time you need to access the attrs."]}),"\n",(0,a.jsxs)(t.p,{children:["Right now, it is not recommended to use this method. Instead, use ",(0,a.jsx)(t.code,{children:"get_attr"})," and ",(0,a.jsx)(t.code,{children:"get_attrs"})," methods.\nWe will deprecate this method in the future."]}),"\n",(0,a.jsx)(t.p,{children:"Sample usage:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'def _impl_attrs_eager(ctx):\n    node = ctx.cquery().owner("cell//path/to/TARGETS")[0]\n    attrs = node.attrs_eager() # cache once\n    ctx.output.print(attrs)\n    # do more stuff with attrs\n'})}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"configuredtargetnodeattrs_lazy",children:"ConfiguredTargetNode.attrs_lazy"}),"\n",(0,a.jsx)("pre",{class:"language-python",children:(0,a.jsxs)("code",{children:["def ConfiguredTargetNode.attrs_lazy(\n) -> ",(0,a.jsx)(o.default,{to:"/docs/api/bxl/LazyAttrs",children:"bxl.LazyAttrs"})]})}),"\n",(0,a.jsxs)(t.p,{children:["Returns a ",(0,a.jsx)(t.code,{children:"lazy_attrs"})," object that you can call ",(0,a.jsx)(t.code,{children:"get()"})," on that gets an attr one at a time."]}),"\n",(0,a.jsxs)(t.p,{children:["If you need to access only few attrs on the same node, then this is the preferred way. Otherwise,\nusing ",(0,a.jsx)(t.code,{children:"attrs_eager()"})," would be a better option for accessing many or all attrs, although this really\ndepends on what kind of attrs are on the node. Benchmarking performance will give you the best\nindication on which method to use."]}),"\n",(0,a.jsxs)(t.p,{children:["You should store the result of this function call for further usage in the code rather than calling\n",(0,a.jsx)(t.code,{children:"attrs_lazy()"})," each time to get the ",(0,a.jsx)(t.code,{children:"lazy_attrs"})," object. Note that if the ",(0,a.jsx)(t.code,{children:"get()"})," is ",(0,a.jsx)(t.code,{children:"None"}),",\nthen any methods called on ",(0,a.jsx)(t.code,{children:"None"})," will result in an error."]}),"\n",(0,a.jsxs)(t.p,{children:["Right now, it is not recommended to use this method. Instead, use ",(0,a.jsx)(t.code,{children:"get_attr"})," and ",(0,a.jsx)(t.code,{children:"get_attrs"})," methods.\nWe will deprecate this method in the future."]}),"\n",(0,a.jsx)(t.p,{children:"Sample usage:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'def _impl_attrs_lazy(ctx):\n    node = ctx.cquery().owner("cell//path/to/TARGETS")[0]\n    attrs = node.attrs_lazy() # cache once\n    ctx.output.print(attrs.get("some_attributes").value())\n    ctx.output.print(attrs.get("some_attribute").label)\n'})}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"configuredtargetnodebuildfile_path",children:"ConfiguredTargetNode.buildfile_path"}),"\n",(0,a.jsx)("pre",{class:"language-python",children:(0,a.jsxs)("code",{children:["ConfiguredTargetNode.buildfile_path: ",(0,a.jsx)(o.default,{to:"/docs/api/bxl/FileNode",children:"bxl.FileNode"})]})}),"\n",(0,a.jsx)(t.p,{children:"Gets the buildfile path from the configured target node."}),"\n",(0,a.jsx)(t.p,{children:"Sample usage:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:"def _impl_label(ctx):\n    target_node = ctx.cquery().eval(\"owner('path/to/file')\")[0]\n    ctx.output.print(target_node.buildfile_path)\n"})}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"configuredtargetnodedeps",children:"ConfiguredTargetNode.deps"}),"\n",(0,a.jsx)("pre",{class:"language-python",children:(0,a.jsxs)("code",{children:["def ConfiguredTargetNode.deps(\n) -> list[",(0,a.jsx)(o.default,{to:"/docs/api/bxl/ConfiguredTargetNode",children:"bxl.ConfiguredTargetNode"}),"]"]})}),"\n",(0,a.jsxs)(t.p,{children:["Gets all deps for this target. The result is a list of ",(0,a.jsx)(t.code,{children:"ConfiguredTargetNode"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Sample usage:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'def _impl_get_deps(ctx):\n    target_node = ctx.uquery().eval("//foo:bar")[0]\n    ctx.output.print(target_node.deps())\n'})}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"configuredtargetnodeget_attr",children:"ConfiguredTargetNode.get_attr"}),"\n",(0,a.jsx)("pre",{class:"language-python",children:(0,a.jsxs)("code",{children:["def ConfiguredTargetNode.get_attr(\nkey: ",(0,a.jsx)(o.default,{to:"/docs/api/starlark/str",children:"str"}),",\n/,\n)"]})}),"\n",(0,a.jsxs)(t.p,{children:["Gets the attribute from the configured target node. If the attribute is unset, returns the default value. If the attribute is not defined by the rule, returns ",(0,a.jsx)(t.code,{children:"None"}),". It will not return special attribute (attribute that start with 'buck.' in ",(0,a.jsx)(t.code,{children:"buck2 cquery -A"})," command)."]}),"\n",(0,a.jsx)(t.p,{children:"Sample usage:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:"def _impl_attributes(ctx):\n    target_node = ctx.uquery().eval(\"//foo:bar\")[0]\n    ctx.output.print(target_node.get_attr('my_attr'))\n"})}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"configuredtargetnodeget_attrs",children:"ConfiguredTargetNode.get_attrs"}),"\n",(0,a.jsx)("pre",{class:"language-python",children:(0,a.jsxs)("code",{children:["def ConfiguredTargetNode.get_attrs(\n) -> dict[",(0,a.jsx)(o.default,{to:"/docs/api/starlark/str",children:"str"}),", typing.Any]"]})}),"\n",(0,a.jsx)(t.p,{children:"Gets all the attributes (excluding special attributes) from the configured target node. For attributes that are not explicitly set, the default value is returned."}),"\n",(0,a.jsx)(t.p,{children:"Sample usage:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'def _impl_attributes(ctx):\n    target_node = ctx.uquery().eval("//foo:bar")[0]\n    ctx.output.print(target_node.get_attrs())\n'})}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"configuredtargetnodeget_source",children:"ConfiguredTargetNode.get_source"}),"\n",(0,a.jsx)("pre",{class:"language-python",children:(0,a.jsxs)("code",{children:["def ConfiguredTargetNode.get_source(\npath: ",(0,a.jsx)(o.default,{to:"/docs/api/starlark/str",children:"str"}),",\nctx: ",(0,a.jsx)(o.default,{to:"/docs/api/bxl/Context",children:"bxl.Context"}),",\n) -> ",(0,a.jsx)(o.default,{to:"/docs/api/build/PromiseArtifact",children:"Artifact"})," | None"]})}),"\n",(0,a.jsxs)(t.p,{children:["Gets the source ",(0,a.jsx)(t.code,{children:"Artifact"})," that corresponds to the given ",(0,a.jsx)(t.code,{children:"path"})," given a context. The path should be the project relative path to the file, or an absolute path."]}),"\n",(0,a.jsx)(t.p,{children:"Sample usage:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'def _impl_get_source(ctx):\n    owner = ctx.cquery().owner("project/relative/path/to/file")[0]\n    artifact = owner.sources()[0]\n    ctx.output.print(artifact)\n'})}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"configuredtargetnodehas_attr",children:"ConfiguredTargetNode.has_attr"}),"\n",(0,a.jsx)("pre",{class:"language-python",children:(0,a.jsxs)("code",{children:["def ConfiguredTargetNode.has_attr(\nkey: ",(0,a.jsx)(o.default,{to:"/docs/api/starlark/str",children:"str"}),",\n/,\n) -> ",(0,a.jsx)(o.default,{to:"/docs/api/starlark/bool",children:"bool"})]})}),"\n",(0,a.jsx)(t.p,{children:"Check if rule has the attribute."}),"\n",(0,a.jsxs)(t.p,{children:["Known attribute is always set explicitly or to default value\n(otherwise target would not be created)\nFor special attributes, it will return ",(0,a.jsx)(t.code,{children:"False"})]}),"\n",(0,a.jsx)(t.p,{children:"Sample usage:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:"def _impl_has_attr(ctx):\n    target_node = ctx.uquery().eval(\"//foo:bar\")[0]\n    ctx.output.print(target_node.has_attr('my_attr'))\n"})}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"configuredtargetnodelabel",children:"ConfiguredTargetNode.label"}),"\n",(0,a.jsx)("pre",{class:"language-python",children:(0,a.jsxs)("code",{children:["ConfiguredTargetNode.label: ",(0,a.jsx)(o.default,{to:"/docs/api/build/ConfiguredTargetLabel",children:"ConfiguredTargetLabel"})]})}),"\n",(0,a.jsx)(t.p,{children:"Gets the configured target label of this target node."}),"\n",(0,a.jsx)(t.p,{children:"Note that you cannot get a non-configured label from a configured target node because the\nconfigured target node is not uniquely identified a non-configured label, only by the configured target label."}),"\n",(0,a.jsx)(t.p,{children:"Sample usage:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'def _impl_label(ctx):\n    node = ctx.configured_targets("my_cell//bin:the_binary")\n    ctx.output.print(node.label)\n'})}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"configuredtargetnodeoncall",children:"ConfiguredTargetNode.oncall"}),"\n",(0,a.jsx)("pre",{class:"language-python",children:(0,a.jsxs)("code",{children:["ConfiguredTargetNode.oncall: None | ",(0,a.jsx)(o.default,{to:"/docs/api/starlark/str",children:"str"})]})}),"\n",(0,a.jsxs)(t.p,{children:["Gets the target's special attr ",(0,a.jsx)(t.code,{children:"oncall"})]}),"\n",(0,a.jsx)(t.p,{children:"Sample usage:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'def _impl_get_oncall(ctx):\n    target_node = ctx.cquery().eval("//foo:bar")[0]\n    ctx.output.print(target_node.oncall)\n'})}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"configuredtargetnoderesolved_attrs_eager",children:"ConfiguredTargetNode.resolved_attrs_eager"}),"\n",(0,a.jsx)("pre",{class:"language-python",children:(0,a.jsxs)("code",{children:["def ConfiguredTargetNode.resolved_attrs_eager(\nctx: ",(0,a.jsx)(o.default,{to:"/docs/api/bxl/Context",children:"bxl.Context"}),",\n)"]})}),"\n",(0,a.jsx)(t.p,{children:"Returns a struct of all the resolved attributes of this target node. The structs fields are the attributes names, and the values are the underlying Starlark values of the attributes."}),"\n",(0,a.jsxs)(t.p,{children:["If you need to access many or all resolved attrs on the same node, then this is the preferred way. Otherwise,\nusing ",(0,a.jsx)(t.code,{children:"resolved_attrs_lazy()"})," would be a better option for accessing only a few resolved attrs, although this really\ndepends on what kind of resolved attrs are on the node. Benchmarking performance will give you the best\nindication on which method to use."]}),"\n",(0,a.jsxs)(t.p,{children:["You should store the result of this function call for further usage in the code rather than calling\n",(0,a.jsx)(t.code,{children:"resolved_attrs_eager()"})," each time you need all the resolved attrs."]}),"\n",(0,a.jsxs)(t.p,{children:["Right now, it is not recommended to use this method. Instead, use ",(0,a.jsx)(t.code,{children:"get_attr"})," and ",(0,a.jsx)(t.code,{children:"get_attrs"})," methods.\nWe will deprecate this method in the future."]}),"\n",(0,a.jsx)(t.p,{children:"Sample usage:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'def _impl_resolved_attrs_eager(ctx):\n    node = ctx.cquery().owner("cell//path/to/TARGETS")[0]\n    attrs = node.resolved_attrs_eager(ctx) # cache once\n    ctx.output.print(attrs)\n    # do more stuff with attrs\n'})}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"configuredtargetnoderesolved_attrs_lazy",children:"ConfiguredTargetNode.resolved_attrs_lazy"}),"\n",(0,a.jsx)("pre",{class:"language-python",children:(0,a.jsxs)("code",{children:["def ConfiguredTargetNode.resolved_attrs_lazy(\nctx: ",(0,a.jsx)(o.default,{to:"/docs/api/bxl/Context",children:"bxl.Context"}),",\n) -> ",(0,a.jsx)(o.default,{to:"/docs/api/bxl/LazyResolvedAttrs",children:"bxl.LazyResolvedAttrs"})]})}),"\n",(0,a.jsxs)(t.p,{children:["Returns a ",(0,a.jsx)(t.code,{children:"lazy_resolved_attrs"})," object that you can call ",(0,a.jsx)(t.code,{children:"get()"})," on that gets a resolved attr one at a time."]}),"\n",(0,a.jsxs)(t.p,{children:["If you need to access only few resolved attrs on the same node, then this is the preferred way. Otherwise,\nusing ",(0,a.jsx)(t.code,{children:"resolved_attrs_eager()"})," would be a better option for accessing many or all resolved attrs, although this really\ndepends on what kind of resolved attrs are on the node. Benchmarking performance will give you the best\nindication on which method to use."]}),"\n",(0,a.jsxs)(t.p,{children:["You should store the result of this function call for further usage in the code rather than calling\n",(0,a.jsx)(t.code,{children:"resolved_attrs_lazy()"})," each time to get the ",(0,a.jsx)(t.code,{children:"lazy_resolved_attrs"})," object. Note that if the ",(0,a.jsx)(t.code,{children:"get()"})," is ",(0,a.jsx)(t.code,{children:"None"}),",\nthen any methods called on ",(0,a.jsx)(t.code,{children:"None"})," will result in an error."]}),"\n",(0,a.jsxs)(t.p,{children:["Right now, it is not recommended to use this method. Instead, use ",(0,a.jsx)(t.code,{children:"get_attr"})," and ",(0,a.jsx)(t.code,{children:"get_attrs"})," methods.\nWe will deprecate this method in the future."]}),"\n",(0,a.jsx)(t.p,{children:"Sample usage:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'def _impl_resolved_attrs_lazy(ctx):\n    node = ctx.cquery().owner("cell//path/to/TARGETS")[0]\n    attrs = node.resolved_attrs_lazy(ctx) # cache once\n    ctx.output.print(attrs.get("some_attributes").value())\n    ctx.output.print(attrs.get("some_attribute").label)\n'})}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"configuredtargetnoderule_kind",children:"ConfiguredTargetNode.rule_kind"}),"\n",(0,a.jsx)("pre",{class:"language-python",children:(0,a.jsxs)("code",{children:["ConfiguredTargetNode.rule_kind: ",(0,a.jsx)(o.default,{to:"/docs/api/starlark/str",children:"str"})]})}),"\n",(0,a.jsx)(t.p,{children:"Gets the targets' corresponding rule's kind which is one of - normal (with no special properties) - configured (usable in a configuration context) - toolchain (only usable as a toolchain dep)"}),"\n",(0,a.jsx)(t.p,{children:"Sample usage:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'def _impl_rule_kind(ctx):\n    node = ctx.configured_targets("my_cell//bin:the_binary")\n    ctx.output.print(node.rule_kind)\n'})}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"configuredtargetnoderule_type",children:"ConfiguredTargetNode.rule_type"}),"\n",(0,a.jsx)("pre",{class:"language-python",children:(0,a.jsxs)("code",{children:["ConfiguredTargetNode.rule_type: ",(0,a.jsx)(o.default,{to:"/docs/api/starlark/str",children:"str"})]})}),"\n",(0,a.jsx)(t.p,{children:"Gets the targets' corresponding rule's name. This is the fully qualified rule name including the import path."}),"\n",(0,a.jsx)(t.p,{children:"Sample usage:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'def _impl_rule_type(ctx):\n    node = ctx.configured_targets("my_cell//bin:the_binary")\n    ctx.output.print(node.rule_type)\n'})}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"configuredtargetnodesources",children:"ConfiguredTargetNode.sources"}),"\n",(0,a.jsx)("pre",{class:"language-python",children:(0,a.jsxs)("code",{children:["def ConfiguredTargetNode.sources(\n) -> list[",(0,a.jsx)(o.default,{to:"/docs/api/build/PromiseArtifact",children:"Artifact"}),"]"]})}),"\n",(0,a.jsxs)(t.p,{children:["Returns all source ",(0,a.jsx)(t.code,{children:"Artifact"}),"s exist in this target's attributes. This method will traverse all the attributes to find and collect all the source ",(0,a.jsx)(t.code,{children:"Artifact"}),"s."]}),"\n",(0,a.jsx)(t.p,{children:"Sample usage:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'def _impl_sources(ctx):\n    node = ctx.configured_targets("my_cell//bin:the_binary")\n    ctx.output.print(node.sources())\n'})}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"configuredtargetnodeunwrap_forward",children:"ConfiguredTargetNode.unwrap_forward"}),"\n",(0,a.jsx)("pre",{class:"language-python",children:(0,a.jsxs)("code",{children:["def ConfiguredTargetNode.unwrap_forward(\n) -> ",(0,a.jsx)(o.default,{to:"/docs/api/bxl/ConfiguredTargetNode",children:"bxl.ConfiguredTargetNode"})]})}),"\n",(0,a.jsx)(t.p,{children:"Skip incoming transition forward node. If a target is a forward node, which is created by applying incoming configuration transition, return the transition target, otherwise return itself. This is is particularly useful when you don't care about 'forward' node."}),"\n",(0,a.jsx)(t.p,{children:"Example usage:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'def _impl_unwrap_forward(ctx):\n    node = ctx.configured_targets("my_cell//bin:the_binary")\n    actual_node = node.unwrap_forward()\n'})})]})}function u(e={}){const{wrapper:t}={...(0,d.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}}}]);