load(
    "@prelude//cxx:comp_db.bzl",
    "CxxCompilationDbInfo",
)

BUCK_CPP_RULE_KINDS = [
    "apple_binary",
    "apple_library",
    "apple_test",
    "cxx_python_extension",
    ".*xx_binary",
    ".*xx_library",
    ".*xx_.*_library",
    ".*xx_test",
    ".*xx_resources",
]

# Update this whenever this file is changed.
CPP_GEN_CDB_SCRIPT_VERSION = "1.0.13"

def _impl(ctx):
    filename = ctx.cli_args.filename
    need_full_cdb = ctx.cli_args.need_full_cdb
    resolve_symlinks = ctx.cli_args.resolve_symlinks
    owner = findOwningTarget(ctx, filename)

    if owner == None:
        unfilteredOwners = ctx.cquery().owner(filename)
        for target in unfilteredOwners:
            if "export_file" in target.rule_type:
                owners = findTargetsByReverseDependency(ctx, unfilteredOwners)
                if len(owners) > 0:
                    owner = pickTarget(ctx, owners)
            elif "genrule" in target.rule_type:
                ctx.output.print_json({"errorMessage": "This file belongs to a genrule and is not supported right now", "version": CPP_GEN_CDB_SCRIPT_VERSION})
                return
    if owner == None:
        ctx.output.print_json({"errorMessage": "Cannot find build target for this file", "version": CPP_GEN_CDB_SCRIPT_VERSION})
        return

    buckRoot = ctx.root()
    providers = ctx.analysis(owner).providers()
    platform = providers[CxxCompilationDbInfo].platform.name
    toolchain = parseToolChain(platform, str(providers[CxxCompilationDbInfo].toolchain.linker_info.archiver.args))

    compileCommands = []
    cxx_compile_info = providers[CxxCompilationDbInfo].info.values()[0]
    for compile_info in providers[CxxCompilationDbInfo].info.values():
        arguments = cmd_args()
        arguments.add(compile_info.cxx_compile_cmd.base_compile_cmd)

        # `_CxxCompileArgsfile.argfile_args` are shell quoted
        # use `args` for original values to store in compile_commands.json
        # see: https://fburl.com/code/5x7td4h1
        arguments.add(compile_info.cxx_compile_cmd.argsfile.args)
        arguments.add(compile_info.args)

        # @unsorted-dict-items
        compileCommands.append({"file": compile_info.src, "directory": buckRoot, "arguments": arguments})

        if not need_full_cdb:
            break
    actionFactory = ctx.bxl_actions.action_factory()
    compdbArtifact = actionFactory.write_json("compdb.json", compileCommands)

    sourceLabel = owner.get_source(filename, ctx)
    if sourceLabel in providers[CxxCompilationDbInfo].info:
        cxx_compile_info = providers[CxxCompilationDbInfo].info[sourceLabel]

    # HMAP CONVERTER
    hmapConverter = ctx.analysis("fbsource//xplat/scripts/clangd/hmapconverter:hmapconverter").providers()[RunInfo]
    outputDir = actionFactory.declare_output("merged_cdb")
    cmd = cmd_args(hmapConverter)
    cmd.add("--input-file")
    cmd.add(compdbArtifact)
    cmd.add("--working-dir")
    cmd.add(buckRoot)
    cmd.add("--output-dir")
    cmd.add(outputDir.as_output())
    cmd.add("--filename")
    cmd.add(filename)
    cmd.add("--use-dotslash")
    if resolve_symlinks:
        cmd.add("--resolve-symlinks")
    if need_full_cdb:
        cmd.add("--need-full-cdb")

    # TODO: do we need these as well?
    # cmd.hidden(cxx_compile_info.cxx_compile_cmd.base_compile_cmd)
    # cmd.hidden(arguments.add(cxx_compile_info.args[:-1]))
    cmd.hidden(cxx_compile_info.cxx_compile_cmd.argsfile.argfile_args)
    actionFactory.run(cmd, category = "cxx_merge_compdb_hmap")
    ensured = ctx.output.ensure(outputDir)
    platform = translatePlatform(platform)
    ctx.output.print_json({"compilationDatabasePath": ensured.abs_path(), "platform": platform, "toolchain": toolchain, "version": CPP_GEN_CDB_SCRIPT_VERSION})

def parseToolChain(platform, toolchain):
    if "llvm-fb" in toolchain:
        if "llvm-fb/9.0.0" in toolchain:
            return "llvm9"
        elif "llvm-fb/12" in toolchain:
            return "llvm12"
        elif "platform010" in platform:
            return "llvm12"

        # TODO: llvm11 for windows
    elif "xcode" in toolchain:
        return "xcode"
    return toolchain

def translatePlatform(platform):
    if "platform" in platform:
        return platform
    else:
        # A variety of apple platforms map to pika in the lsp.
        return "pika"

def findOwningTarget(ctx, filename):
    owners = ctx.cquery().kind("|".join(BUCK_CPP_RULE_KINDS), ctx.cquery().owner(filename))
    if len(owners) >= 1:
        return pickTarget(ctx, owners)
    return None

def findTargetsByReverseDependency(ctx, unfilteredTargets):
    for searchDepth in range(1, 3):
        for unfilteredTarget in unfilteredTargets:
            buildPackage = str(unfilteredTarget.label).split(":")[0]
            dirCount = buildPackage.count("/")
            owners = []
            fromTarget = str(unfilteredTarget.label).split(" ")[0]

            # We only try targets from a few nearby packages
            for _i in range(0, min(2, dirCount + 1)):
                universe = buildPackage + "/..."
                owners = ctx.cquery().kind(
                    "|".join(BUCK_CPP_RULE_KINDS),
                    ctx.cquery().rdeps(
                        universe,
                        fromTarget,
                        searchDepth,
                    ),
                )
                if buildPackage == "/" or len(buildPackage) == 0:
                    break
                if "/" not in buildPackage:
                    break
                buildPackage = buildPackage[0:buildPackage.rindex("/")]
                if buildPackage == "//" or buildPackage == ".":
                    buildPackage = "/"
                if len(owners) > 0:
                    return owners

    return []

def pickTarget(ctx, targets):
    if len(targets) == 1:
        for target in targets:
            return target

    if ctx.cli_args.os == "darwin":
        for target in targets:
            if str(target.label).endswith("applemac"):
                return target

    # todo: identify fobjc mode

    # pick a target that's prefix for all other targets
    sortedTargets = sorted(targets, key = lambda target: str(target.label))
    for sortedTarget in sortedTargets:
        if not str(sortedTarget.label).startswith(str(sortedTargets[0].label)):
            return targets[0]
    return sortedTargets[0]

cpp_gen_cdb = bxl(
    impl = _impl,
    cli_args = {
        "filename": cli_args.string(),
        "need_full_cdb": cli_args.bool(),
        "os": cli_args.string(),
        "resolve_symlinks": cli_args.bool(),
    },
)
