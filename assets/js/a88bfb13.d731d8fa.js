"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[54026],{28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>s});var i=n(96540);const o={},r=i.createContext(o);function a(e){const t=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(r.Provider,{value:t},e.children)}},64287:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"rule_authors/configurations","title":"Configurations","description":"This page mostly focuses on how configurations and related features are","source":"@site/../docs/rule_authors/configurations.md","sourceDirName":"rule_authors","slug":"/rule_authors/configurations","permalink":"/docs/rule_authors/configurations","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"configurations","title":"Configurations"},"sidebar":"main","previous":{"title":"Transitive Sets","permalink":"/docs/rule_authors/transitive_sets"},"next":{"title":"Configurations By Example","permalink":"/docs/rule_authors/configurations_by_example"}}');var o=n(74848),r=n(28453);const a={id:"configurations",title:"Configurations"},s=void 0,l={},c=[{value:"Context",id:"context",level:2},{value:"Selectable attributes",id:"selectable-attributes",level:2},{value:"Selectable resolution",id:"selectable-resolution",level:2},{value:"Target Platform Resolution",id:"target-platform-resolution",level:2},{value:"Configuration propagation",id:"configuration-propagation",level:2},{value:"Transitions",id:"transitions",level:2},{value:"<code>ConfigurationInfo</code>, <code>platform()</code> analysis, and more",id:"configurationinfo-platform-analysis-and-more",level:2},{value:"Configurations and output paths",id:"configurations-and-output-paths",level:2},{value:"Target platform compatibility",id:"target-platform-compatibility",level:2},{value:"Buck v1 compatibility",id:"buck-v1-compatibility",level:3},{value:"Incompatible target skipping",id:"incompatible-target-skipping",level:2},{value:"Execution platforms",id:"execution-platforms",level:2},{value:"Execution deps",id:"execution-deps",level:2},{value:"Toolchain deps",id:"toolchain-deps",level:2},{value:"Running non-execution deps",id:"running-non-execution-deps",level:2},{value:"Execution platform resolution",id:"execution-platform-resolution",level:2},{value:"Execution groups",id:"execution-groups",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"This page mostly focuses on how configurations and related features are\nimplemented."}),"\n",(0,o.jsx)(t.h2,{id:"context",children:"Context"}),"\n",(0,o.jsx)(t.p,{children:"Buck configurations provide an API to express the different ways in which\nprojects and targets can be built."}),"\n",(0,o.jsx)(t.p,{children:"A configuration consists of a set of constraints and config settings (values\nfrom buckconfig). These are determined by a base platform that sets the initial\nvalues and then a series of transitions that may change them."}),"\n",(0,o.jsxs)(t.p,{children:["The common way that users are exposed to configurations is in ",(0,o.jsx)(t.code,{children:"select()"}),"\ninvocations where the resolution is based on the configuration."]}),"\n",(0,o.jsxs)(t.p,{children:["A build may involve many configurations. A particular target label (",(0,o.jsx)(t.code,{children:"//:foo"}),")\nmay end up with multiple instances in the configured graph with different\nconfigurations."]}),"\n",(0,o.jsx)(t.h2,{id:"selectable-attributes",children:"Selectable attributes"}),"\n",(0,o.jsxs)(t.p,{children:["Almost all rule attributes can be set to a ",(0,o.jsx)(t.code,{children:"select()"})," value; such an attribute\nis 'selectable'. These attributes' final resolved values will depend on the\nconfiguration."]}),"\n",(0,o.jsxs)(t.p,{children:["There are some attributes that cannot use a ",(0,o.jsx)(t.code,{children:"select()"}),"; such attributes are\ntermed 'not selectable'. Examples include attributes that buck needs to read\nfrom the unconfigured node (such as ",(0,o.jsx)(t.code,{children:"name"})," and ",(0,o.jsx)(t.code,{children:"default_target_platform"}),") and\nattributes that are used by ",(0,o.jsx)(t.code,{children:"platform()"})," rules and their dependencies (see\nbelow)."]}),"\n",(0,o.jsx)(t.h2,{id:"selectable-resolution",children:"Selectable resolution"}),"\n",(0,o.jsx)(t.p,{children:"Resolving selectable attributes is pretty straightforward, it happens when\nconstructing the 'configured target node'. At that point, the full configuration\nis available so Buck can lookup whether each constraint in the select is\nsatisfied or not."}),"\n",(0,o.jsxs)(t.p,{children:["If multiple conditions of the select() match, then the select will be resolved\nto the 'most refined' of the conditions that match. A set of constraints (as in\na ",(0,o.jsx)(t.code,{children:"config_setting"}),") is said to 'refine' another if it is a superset of that\nother's constraints. The 'most refined' of a set is then the condition that\nrefines all the others. If there is no 'most refined' condition of the matching\nones, it is an error."]}),"\n",(0,o.jsx)(t.h2,{id:"target-platform-resolution",children:"Target Platform Resolution"}),"\n",(0,o.jsx)(t.p,{children:"In the event that targets are provided on the command line, or when there is no\nindication of what configuration the target will be built in, configurations are\ndetermined by performing 'target platform resolution' on the unconfigured target\nlabels."}),"\n",(0,o.jsxs)(t.p,{children:["The target platform resolution for a target ",(0,o.jsx)(t.code,{children:"//:foo"})," works as follows:"]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["Look up (unconfigured) target node for ",(0,o.jsx)(t.code,{children:"//:foo"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["If the command has a ",(0,o.jsx)(t.code,{children:"--target-platforms"})," flag, use that."]}),"\n",(0,o.jsxs)(t.li,{children:["If there's a ",(0,o.jsx)(t.code,{children:"default_target_platform"})," attribute, use that."]}),"\n",(0,o.jsx)(t.li,{children:"Else, use the cell's default platform."}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["This is performed independently for any targets that need a platform. Since this\nresolution is done without a configuration, it means that the\n",(0,o.jsx)(t.code,{children:"default_target_platform"})," attribute ",(0,o.jsx)(t.strong,{children:"is not selectable"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"This target platform will form the initial configuration for the node."}),"\n",(0,o.jsx)(t.h2,{id:"configuration-propagation",children:"Configuration propagation"}),"\n",(0,o.jsx)(t.p,{children:"Once the top-level nodes have been configured via the target platform\nresolution, the configuration is propagated to dependencies (possibly altered by\ntransitions)."}),"\n",(0,o.jsx)(t.admonition,{type:"note",children:(0,o.jsx)(t.p,{children:"The target platform resolution is not applied to all nodes in the graph."})}),"\n",(0,o.jsx)(t.h2,{id:"transitions",children:"Transitions"}),"\n",(0,o.jsx)(t.p,{children:"A transition transforms a configuration by adding or changing constraint values\nand config settings or by setting an entirely new underlying target platform."}),"\n",(0,o.jsxs)(t.p,{children:["For more details, see ",(0,o.jsx)(t.a,{href:"/docs/rule_authors/configuration_transitions",children:"Configuration transitions"}),"."]}),"\n",(0,o.jsxs)(t.h2,{id:"configurationinfo-platform-analysis-and-more",children:[(0,o.jsx)(t.code,{children:"ConfigurationInfo"}),", ",(0,o.jsx)(t.code,{children:"platform()"})," analysis, and more"]}),"\n",(0,o.jsxs)(t.p,{children:["The definition of a platform (either execution or target) is done with a\n",(0,o.jsx)(t.code,{children:"platform"})," rule instance. The configuration is actually part of the analysis\nresult of the platform target (the ",(0,o.jsx)(t.code,{children:"ConfigurationInfo"})," provider instance). This\nis convenient from an implementation standpoint, but it leads to a situation\nwhere some nodes are analyzed with an 'unbound' Configuration."]}),"\n",(0,o.jsxs)(t.p,{children:["All the rule types involved in defining a platform may be analyzed with an\nunbound configuration (",(0,o.jsx)(t.code,{children:"platform()"}),", ",(0,o.jsx)(t.code,{children:"config_setting()"}),", ",(0,o.jsx)(t.code,{children:"constraint_setting()"}),",\nand so on). These are sometimes called 'configuration rules'. This means that\nall the attributes of these rules are not selectable."]}),"\n",(0,o.jsxs)(t.p,{children:["Configurations also reference a few other provider instances such as\n",(0,o.jsx)(t.code,{children:"ConstraintSettingInfo"}),". All of these end up being potentially produced in a\ncontext with an unbound configuration."]}),"\n",(0,o.jsx)(t.p,{children:"Using analysis for this also means that 'configuration' and 'analysis' are not\ndistinct phases within a build (although they are still distinct for a node and\nare still conceptually useful)."}),"\n",(0,o.jsx)(t.h2,{id:"configurations-and-output-paths",children:"Configurations and output paths"}),"\n",(0,o.jsx)(t.p,{children:"Since a target may appear within a build in multiple different configurations,\noutput paths cannot be derived based on just targets (as multiple actions would\nmap to the same outputs). For this reason, the target and the configuration are\nencoded into output paths. The configuration is currently represented as a hash\nof its values (a 'hashed buck-out')."}),"\n",(0,o.jsx)(t.h2,{id:"target-platform-compatibility",children:"Target platform compatibility"}),"\n",(0,o.jsxs)(t.p,{children:["All (non-configuration) rules support a ",(0,o.jsx)(t.code,{children:"target_compatible_with"})," attribute. In\naddition, the rule itself can define ",(0,o.jsx)(t.code,{children:"target_compatible_with"})," constraints that\naffect all instances. The ",(0,o.jsx)(t.code,{children:"target_compatible_with"})," attribute is a list of\nconstraints/config settings and it ",(0,o.jsx)(t.strong,{children:"is selectable"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["Target platform compatibility is transitive, all ",(0,o.jsx)(t.em,{children:"dependents"})," of an incompatible\ntarget are incompatible. In other words, a node is compatible if and only if the\nnode itself and all of its transitive dependencies are compatible."]}),"\n",(0,o.jsx)(t.p,{children:"In buck, this is implemented by graph configuration returning either a\nconfigured target node or an indicator that the node is incompatible with the\ntarget platform."}),"\n",(0,o.jsx)(t.h3,{id:"buck-v1-compatibility",children:"Buck v1 compatibility"}),"\n",(0,o.jsxs)(t.p,{children:["Buck2 also supports the ",(0,o.jsx)(t.code,{children:"compatible_with"})," field on nodes but it has different\nbehavior."]}),"\n",(0,o.jsx)(t.p,{children:"In summary:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"compatible_with"}),": List of constraints, where ",(0,o.jsx)(t.em,{children:"any"})," of them must match the\nconfiguration to be compatible."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"target_compatible_with"}),": List of constraints, where ",(0,o.jsx)(t.em,{children:"all"})," of them must match\nthe configuration to be compatible."]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"incompatible-target-skipping",children:"Incompatible target skipping"}),"\n",(0,o.jsxs)(t.p,{children:["In a build-like command where a non-literal target pattern is provided (for\nexample, ",(0,o.jsx)(t.code,{children:"buck build //:"})," or ",(0,o.jsx)(t.code,{children:"buck build //foo/..."}),"), the target pattern will be\nresolved to a set of unconfigured targets. Those targets will then go through\n",(0,o.jsx)(t.a,{href:"#target-platform-resolution",children:"target platform resolution"}),". If any of those\ntargets resolve to a platform where they are incompatible, building them will be\nskipped. Users generally expect and prefer this behavior to needing to\nexplicitly specify only the targets that can build in their current context."]}),"\n",(0,o.jsx)(t.p,{children:"If an explicitly specified literal is incompatible, it is an error."}),"\n",(0,o.jsx)(t.p,{children:"The implementation checks compatibility when looking up the analysis results for\nconfigured nodes requested (in the non-ignored flow, it uses that analysis\nresult to lookup the default outputs and build them)."}),"\n",(0,o.jsx)(t.h2,{id:"execution-platforms",children:"Execution platforms"}),"\n",(0,o.jsx)(t.p,{children:"Execution platforms/configurations are used to represent the platforms where\nbuild execution happens. These are defined in a similar manner to target\nplatforms. These may or may not be what one would logically consider different\n'platforms'. For example, there could be multiple different execution platforms\nthat all execute things similarly on the local machine."}),"\n",(0,o.jsx)(t.p,{children:"A build configures a fixed list of one or more execution platforms."}),"\n",(0,o.jsx)(t.h2,{id:"execution-deps",children:"Execution deps"}),"\n",(0,o.jsxs)(t.p,{children:["Some target deps are 'execution deps'. These are the dependencies of the target\nthat should be built for the execution platform. For example, a compiler or\nother build tool would be an execution dep. This includes all exe macro deps\n(for example, ",(0,o.jsx)(t.code,{children:"$(exe //:tool)"}),") and includes all ",(0,o.jsx)(t.code,{children:"attrs.exec_dep()"})," deps."]}),"\n",(0,o.jsx)(t.h2,{id:"toolchain-deps",children:"Toolchain deps"}),"\n",(0,o.jsxs)(t.p,{children:["In addition to ",(0,o.jsx)(t.code,{children:"attrs.exec_dep()"}),", there are ",(0,o.jsx)(t.code,{children:"attrs.toolchain_dep()"}),", which are\nsimilar but differ in an important way. These nodes don't select their execution\nplatform, but instead inherit the execution platform of whatever target\nreferences them; hence, it must be recorded in the configured target label. In\nsome sense, execution platform resolution sees through them."]}),"\n",(0,o.jsxs)(t.p,{children:["In other words, ",(0,o.jsx)(t.code,{children:"attrs.toolchain_dep()"})," is like a mix of ",(0,o.jsx)(t.code,{children:"attrs.dep()"})," and\n",(0,o.jsx)(t.code,{children:"attrs.exec_dep()"}),":"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["It inherits its target platform from the dependent build target like\n",(0,o.jsx)(t.code,{children:"attrs.dep()"})," (so any ",(0,o.jsx)(t.code,{children:"select()"}),"s using the target of the\n",(0,o.jsx)(t.code,{children:"attrs.toolchain_dep()"})," will evaluate as if they were on the target\nreferencing the ",(0,o.jsx)(t.code,{children:"attrs.toolchain_dep()"})," - the target platform gets inherited\nas with ",(0,o.jsx)(t.code,{children:"attrs.dep()"}),")"]}),"\n",(0,o.jsxs)(t.li,{children:["Like ",(0,o.jsx)(t.code,{children:"attrs.exec_dep()"})," itself, ",(0,o.jsx)(t.code,{children:"attrs.exec_dep()"}),"s of the\n",(0,o.jsx)(t.code,{children:"attrs.toolchain_dep()"})," target are inserted into the list of\n",(0,o.jsx)(t.code,{children:"attrs.exec_dep()"})," on the dependent target of the ",(0,o.jsx)(t.code,{children:"attrs.toolchain_dep()"}),"\n(they get passed up the dep tree, so participate in exec platform resolution)."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"This is illustrated in the following example:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:'target(\n    name = "A",\n    toolchain = attrs.toolchain_dep(default = ":B"),\n)\ntarget(\n    name = "B",\n    tool = attrs.exec_dep(default = ":C")\n)\n'})}),"\n",(0,o.jsxs)(t.p,{children:["The above means that ",(0,o.jsx)(t.code,{children:":C"})," will be an execution dependency of ",(0,o.jsx)(t.code,{children:":A"})," and any\n",(0,o.jsx)(t.code,{children:"select()"}),"s defined in ",(0,o.jsx)(t.code,{children:":B"})," would be evaluated against the same target platform\nas ",(0,o.jsx)(t.code,{children:":A"})," (as target platform gets inherited by ",(0,o.jsx)(t.code,{children:"attrs.toolchain_dep()"}),"s)."]}),"\n",(0,o.jsx)(t.h2,{id:"running-non-execution-deps",children:"Running non-execution deps"}),"\n",(0,o.jsxs)(t.p,{children:["If you have a binary that you want to run, but it isn't a build tool, then you\nshould use ",(0,o.jsx)(t.code,{children:"$(exe_target //:binary)"})," rather than ",(0,o.jsx)(t.code,{children:"$(exe //:binary)"}),". That will\nrun the same binary that you'd get from ",(0,o.jsx)(t.code,{children:"buck2 build"}),", rather than one that is\nbuilt for the execution platform."]}),"\n",(0,o.jsx)(t.p,{children:"The path macros vary along two axes:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Path Source"}),": either ",(0,o.jsx)(t.code,{children:"DefaultInfo"})," or ",(0,o.jsx)(t.code,{children:"RunInfo"})," providers"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Configuration"}),": inherits the configuration or transitions to an execution\nplatform configuration"]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Specifically:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"$location"}),": ",(0,o.jsx)(t.code,{children:"DefaultInfo"})," path source, inherits configuration"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"$location_exec"}),": ",(0,o.jsx)(t.code,{children:"DefaultInfo"})," path source, exec platform configuration"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"$exe"}),": ",(0,o.jsx)(t.code,{children:"RunInfo"})," path source, exec platform configuration"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"$exe_target"}),": ",(0,o.jsx)(t.code,{children:"RunInfo"})," path source, inherits configuration"]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"execution-platform-resolution",children:"Execution platform resolution"}),"\n",(0,o.jsx)(t.p,{children:"During analysis, unlike target platform resolution, every configured node\nundergoes execution platform resolution independently (see exception below).\nThis means that even for a specific target platform, different nodes in the\ngraph can be built on different execution platforms."}),"\n",(0,o.jsx)(t.p,{children:"This works roughly as follows:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:"next: for platform in execution_platforms:\n    if exec_compatible_with(target, platform):\n        for dep in target.execution_deps():\n            if !target_compatible_with(dep, platform):\n              continue next\n        return platform\nreturn err\n"})}),"\n",(0,o.jsxs)(t.p,{children:["One important note here is that until the execution platform has been resolved,\n",(0,o.jsx)(t.strong,{children:"the configuration for execution deps is not known"}),". Only after execution\nplatform has been resolved can the execution deps be configured (also, analysis\nfor them can only be performed at that point)."]}),"\n",(0,o.jsxs)(t.p,{children:["For the normal use case, a particular configured target node performs execution\nplatform resolution a single time. The execution platform ",(0,o.jsx)(t.strong,{children:"is not"})," encoded in\noutput paths."]}),"\n",(0,o.jsxs)(t.p,{children:["Regarding target compatibility, imagine the following pseudo-code for the\n",(0,o.jsx)(t.code,{children:"target_compatible_with()"})," function above:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:"def target_compatible_with(target, cfg):\n    for constraint in target.target_compatible_with:\n        if not satisfied(constraint, cfg):\n            return False\n\n    if len(target.compatible_with) > 0:\n        found_satisfied_constraint = False\n        for constraint in target.compatible_with:\n            if satisfied(constraint, cfg):\n                found_satisfied_constraint = True\n                break\n        if not found_satisfied_constraint:\n            return False\n\n    for (dep, dep_cfg) in direct_deps(target):\n        # NB: recursive call\n        if not target_compatible_with(dep, dep_cfg):\n            return False\n\n    return True\n"})}),"\n",(0,o.jsx)(t.h2,{id:"execution-groups",children:"Execution groups"}),"\n",(0,o.jsx)(t.p,{children:"Execution groups are a future feature that will allow a rule to perform\nexecution platform resolution multiple times and then specify in which of the\nresolved platforms each action runs in."})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);