load("@fbcode//buck2/prelude/intellij_project:libraries.bxl", "get_library_json_contents")
load("@fbcode//buck2/prelude/java:java_providers.bzl", "JavaLibraryIntellijInfo")
load("@fbcode//buck2/prelude/utils:utils.bzl", "expect", "flatten")

IjTargetNode = record(
    deps = ["configured_target_label"],
    label = "configured_target_label",
    directory_path = str.type,
    srcs = ["artifact"],
)

AggregatedIjTargetNode = record(
    deps = ["configured_target_label"],
    labels = ["configured_target_label"],
    name = str.type,
    srcs = ["artifact"],
)

IjModule = record(
    ij_target_node = AggregatedIjTargetNode.type,
    module_dependencies = [AggregatedIjTargetNode.type],
    module_libraries = ["IjLibrary"],
    project_libraries = ["IjLibrary"],
)

_ANDROID_LIBRARY_RULE_TYPE = "fbcode//buck2/prelude/rules.bzl:android_library"
_JAVA_LIBRARY_RULE_TYPE = "fbcode//buck2/prelude/rules.bzl:java_library"
_MODULE_RULE_TYPES = [
    _ANDROID_LIBRARY_RULE_TYPE,
    _JAVA_LIBRARY_RULE_TYPE,
]

def get_aggregated_ij_module_target_nodes(all_nodes: "target_set", analysis: dict.type) -> [AggregatedIjTargetNode.type]:
    ij_target_nodes = []
    for node in all_nodes:
        rule_type = node.rule_type
        if rule_type not in _MODULE_RULE_TYPES:
            continue

        if rule_type == _JAVA_LIBRARY_RULE_TYPE:
            providers = analysis[configured_sub_target(node.label)].providers()
            ij_target_nodes.append(_get_java_library_target_node(node, providers))
        elif rule_type == _ANDROID_LIBRARY_RULE_TYPE:
            providers = analysis[configured_sub_target(node.label)].providers()
            ij_target_nodes.append(_get_android_library_target_node(node, providers))
        else:
            fail("Should add if branch above for rule type: {}".format(rule_type))

    return _aggregate_ij_target_nodes(ij_target_nodes)

def _get_android_library_target_node(node: "target_node", providers: "provider_collection") -> IjTargetNode.type:
    expect(node.rule_type == _ANDROID_LIBRARY_RULE_TYPE, "Rule type must be {} but was {}".format(_JAVA_LIBRARY_RULE_TYPE, node.rule_type))
    java_library_intellij_info = providers[JavaLibraryIntellijInfo]
    return IjTargetNode(
        deps = [compiling_dep.owner.configured_target() for compiling_dep in java_library_intellij_info.compiling_classpath],
        label = node.label,
        directory_path = node.label.package,
        srcs = node.attrs().srcs.value(),
    )

def _get_java_library_target_node(node: "target_node", providers: "provider_collection") -> IjTargetNode.type:
    expect(node.rule_type == _JAVA_LIBRARY_RULE_TYPE, "Rule type must be {} but was {}".format(_JAVA_LIBRARY_RULE_TYPE, node.rule_type))
    java_library_intellij_info = providers[JavaLibraryIntellijInfo]
    return IjTargetNode(
        deps = [compiling_dep.owner.configured_target() for compiling_dep in java_library_intellij_info.compiling_classpath],
        label = node.label,
        directory_path = node.label.package,
        srcs = node.attrs().srcs.value(),
    )

def _get_name(directory_path: str.type) -> str.type:
    return directory_path.replace("/", "_")

def _aggregate_ij_target_nodes(ij_target_nodes: [IjTargetNode.type]) -> [AggregatedIjTargetNode.type]:
    directory_path_to_ij_target_node_list = {}
    for ij_target_node in ij_target_nodes:
        ij_target_node_list = directory_path_to_ij_target_node_list.get(ij_target_node.directory_path)
        if not ij_target_node_list:
            ij_target_node_list = []
            directory_path_to_ij_target_node_list[ij_target_node.directory_path] = ij_target_node_list
        ij_target_node_list.append(ij_target_node)

    aggregated_ij_target_nodes = []
    for directory_path, ij_target_node_list in directory_path_to_ij_target_node_list.items():
        deps = dedupe(flatten([node.deps for node in ij_target_node_list]))
        labels = dedupe([node.label for node in ij_target_node_list])
        srcs = dedupe(flatten([node.srcs for node in ij_target_node_list]))

        aggregated_ij_target_nodes.append(
            AggregatedIjTargetNode(
                deps = deps,
                labels = labels,
                name = _get_name(directory_path),
                srcs = srcs,
            ),
        )

    return aggregated_ij_target_nodes

def get_module_json_file_name(ij_target_node: AggregatedIjTargetNode.type) -> str.type:
    return "modules/{}.json".format(ij_target_node.name)

# TODO(T124403530) Fill this in correctly
def get_module_file_json_contents(ij_module: IjModule.type) -> dict.type:
    return {
        "dependencies": {
            "LIBRARY": _get_project_libraries_json(ij_module.project_libraries),
            "MODULE": _get_module_dependencies_json(ij_module.module_dependencies),
            "MODULE_LIBRARY": _get_module_libraries_json(ij_module.module_libraries),
        },
        "type": "JAVA_MODULE",
    }

def _get_module_dependencies_json(module_dependencies: [AggregatedIjTargetNode.type]) -> [dict.type]:
    return [_get_module_dependency_json(module_dependency) for module_dependency in module_dependencies]

def _get_module_dependency_json(module_dependency: AggregatedIjTargetNode.type) -> dict.type:
    return {
        "name": module_dependency.name,
    }

def _get_module_libraries_json(libraries: ["IjLibrary"]) -> [dict.type]:
    return [_get_module_library_json(module_library) for module_library in libraries]

def _get_module_library_json(module_library: "IjLibrary") -> dict.type:
    return get_library_json_contents(module_library)

def _get_project_libraries_json(libraries: ["IjLibrary"]) -> [dict.type]:
    return [_get_project_library_json(project_library) for project_library in libraries]

def _get_project_library_json(project_library: "IjLibrary") -> dict.type:
    return {
        "name": project_library.name,
    }
