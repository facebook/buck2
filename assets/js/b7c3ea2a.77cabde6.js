"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5461],{28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>d});var l=i(96540);const s={},r=l.createContext(s);function o(e){const n=l.useContext(r);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),l.createElement(r.Provider,{value:n},e.children)}},98350:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>t,contentTitle:()=>d,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>a});const l=JSON.parse('{"id":"users/commands/audit","title":"audit","description":"This document provides an overview of the commands and options available under buck2 audit.","source":"@site/../docs/users/commands/audit.generated.md","sourceDirName":"users/commands","slug":"/users/commands/audit","permalink":"/docs/users/commands/audit","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"audit","title":"audit"},"sidebar":"main","previous":{"title":"aquery","permalink":"/docs/users/commands/aquery"},"next":{"title":"build","permalink":"/docs/users/commands/build"}}');var s=i(74848),r=i(28453);const o={id:"audit",title:"audit"},d="audit",t={},a=[{value:"<code>buck2 audit</code>",id:"buck2-audit",level:2},{value:"Subcommands:",id:"subcommands",level:3},{value:"Common Options:",id:"common-options",level:3},{value:"<code>buck2 audit cell</code>",id:"buck2-audit-cell",level:2},{value:"Arguments:",id:"arguments",level:3},{value:"Common Options:",id:"common-options-1",level:3},{value:"Options:",id:"options",level:3},{value:"<code>buck2 audit file-package</code>",id:"buck2-audit-file-package",level:2},{value:"Arguments:",id:"arguments-1",level:3},{value:"Common Options:",id:"common-options-2",level:3},{value:"Options:",id:"options-1",level:3},{value:"<code>buck2 audit classpath</code>",id:"buck2-audit-classpath",level:2},{value:"Arguments:",id:"arguments-2",level:3},{value:"Common Options:",id:"common-options-3",level:3},{value:"Options:",id:"options-2",level:3},{value:"<code>buck2 audit config</code>",id:"buck2-audit-config",level:2},{value:"Arguments:",id:"arguments-3",level:3},{value:"Common Options:",id:"common-options-4",level:3},{value:"Options:",id:"options-3",level:3},{value:"<code>buck2 audit configurations</code>",id:"buck2-audit-configurations",level:2},{value:"Arguments:",id:"arguments-4",level:3},{value:"Common Options:",id:"common-options-5",level:3},{value:"Options:",id:"options-4",level:3},{value:"<code>buck2 audit includes</code>",id:"buck2-audit-includes",level:2},{value:"Arguments:",id:"arguments-5",level:3},{value:"Common Options:",id:"common-options-6",level:3},{value:"Options:",id:"options-5",level:3},{value:"<code>buck2 audit prelude</code>",id:"buck2-audit-prelude",level:2},{value:"Common Options:",id:"common-options-7",level:3},{value:"Options:",id:"options-6",level:3},{value:"<code>buck2 audit providers</code>",id:"buck2-audit-providers",level:2},{value:"Arguments:",id:"arguments-6",level:3},{value:"Common Options:",id:"common-options-8",level:3},{value:"Options:",id:"options-7",level:3},{value:"<code>buck2 audit subtargets</code>",id:"buck2-audit-subtargets",level:2},{value:"Arguments:",id:"arguments-7",level:3},{value:"Common Options:",id:"common-options-9",level:3},{value:"Options:",id:"options-8",level:3},{value:"<code>buck2 audit analysis-queries</code>",id:"buck2-audit-analysis-queries",level:2},{value:"Arguments:",id:"arguments-8",level:3},{value:"Common Options:",id:"common-options-10",level:3},{value:"Options:",id:"options-9",level:3},{value:"<code>buck2 audit execution-platform-resolution</code>",id:"buck2-audit-execution-platform-resolution",level:2},{value:"Arguments:",id:"arguments-9",level:3},{value:"Common Options:",id:"common-options-11",level:3},{value:"Options:",id:"options-10",level:3},{value:"<code>buck2 audit visibility</code>",id:"buck2-audit-visibility",level:2},{value:"Arguments:",id:"arguments-10",level:3},{value:"Common Options:",id:"common-options-12",level:3},{value:"Options:",id:"options-11",level:3},{value:"<code>buck2 audit starlark</code>",id:"buck2-audit-starlark",level:2},{value:"Subcommands:",id:"subcommands-1",level:3},{value:"Common Options:",id:"common-options-13",level:3},{value:"<code>buck2 audit starlark module</code>",id:"buck2-audit-starlark-module",level:2},{value:"Arguments:",id:"arguments-11",level:3},{value:"Common Options:",id:"common-options-14",level:3},{value:"Options:",id:"options-12",level:3},{value:"<code>buck2 audit starlark package-deps</code>",id:"buck2-audit-starlark-package-deps",level:2},{value:"Arguments:",id:"arguments-12",level:3},{value:"Common Options:",id:"common-options-15",level:3},{value:"Options:",id:"options-13",level:3},{value:"<code>buck2 audit dep-files</code>",id:"buck2-audit-dep-files",level:2},{value:"Arguments:",id:"arguments-13",level:3},{value:"Common Options:",id:"common-options-16",level:3},{value:"Options:",id:"options-14",level:3},{value:"<code>buck2 audit deferred-materializer</code>",id:"buck2-audit-deferred-materializer",level:2},{value:"Subcommands:",id:"subcommands-2",level:3},{value:"Common Options:",id:"common-options-17",level:3},{value:"Options:",id:"options-15",level:3},{value:"<code>buck2 audit deferred-materializer list</code>",id:"buck2-audit-deferred-materializer-list",level:2},{value:"Common Options:",id:"common-options-18",level:3},{value:"<code>buck2 audit deferred-materializer list-subscriptions</code>",id:"buck2-audit-deferred-materializer-list-subscriptions",level:2},{value:"Common Options:",id:"common-options-19",level:3},{value:"<code>buck2 audit deferred-materializer fsck</code>",id:"buck2-audit-deferred-materializer-fsck",level:2},{value:"Common Options:",id:"common-options-20",level:3},{value:"<code>buck2 audit deferred-materializer refresh</code>",id:"buck2-audit-deferred-materializer-refresh",level:2},{value:"Arguments:",id:"arguments-14",level:3},{value:"Common Options:",id:"common-options-21",level:3},{value:"<code>buck2 audit deferred-materializer get-refresh-log</code>",id:"buck2-audit-deferred-materializer-get-refresh-log",level:2},{value:"Common Options:",id:"common-options-22",level:3},{value:"<code>buck2 audit deferred-materializer test-iter</code>",id:"buck2-audit-deferred-materializer-test-iter",level:2},{value:"Common Options:",id:"common-options-23",level:3},{value:"Options:",id:"options-16",level:3},{value:"<code>buck2 audit deferred-materializer flush-access-times</code>",id:"buck2-audit-deferred-materializer-flush-access-times",level:2},{value:"Common Options:",id:"common-options-24",level:3},{value:"<code>buck2 audit output</code>",id:"buck2-audit-output",level:2},{value:"Arguments:",id:"arguments-15",level:3},{value:"Common Options:",id:"common-options-25",level:3},{value:"Options:",id:"options-17",level:3},{value:"<code>buck2 audit parse</code>",id:"buck2-audit-parse",level:2},{value:"Arguments:",id:"arguments-16",level:3},{value:"Common Options:",id:"common-options-26",level:3},{value:"Options:",id:"options-18",level:3},{value:"<code>buck2 audit package-values</code>",id:"buck2-audit-package-values",level:2},{value:"Arguments:",id:"arguments-17",level:3},{value:"Common Options:",id:"common-options-27",level:3},{value:"Options:",id:"options-19",level:3},{value:"<code>buck2 audit perf</code>",id:"buck2-audit-perf",level:2},{value:"Subcommands:",id:"subcommands-3",level:3},{value:"Common Options:",id:"common-options-28",level:3},{value:"<code>buck2 audit perf configured-graph-size</code>",id:"buck2-audit-perf-configured-graph-size",level:2},{value:"Arguments:",id:"arguments-18",level:3},{value:"Common Options:",id:"common-options-29",level:3},{value:"Options:",id:"options-20",level:3}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"audit",children:"audit"})}),"\n",(0,s.jsxs)(n.p,{children:["This document provides an overview of the commands and options available under ",(0,s.jsx)(n.code,{children:"buck2 audit"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit",children:(0,s.jsx)(n.code,{children:"buck2 audit"})}),"\n",(0,s.jsx)(n.p,{children:"Perform lower level queries"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit <COMMAND>"})]}),"\n",(0,s.jsx)(n.h3,{id:"subcommands",children:"Subcommands:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"cell"}),": Query information about the [cells] list in .buckconfig."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"file-package"}),": Map file paths to fully qualified package names."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"classpath"}),": Prints out a target's classpaths if it has one.\nThis command is deprecated and currently available for compatibility with buck1.\nWe will replace this command with something that can audit the entire ",(0,s.jsx)(n.code,{children:"TemplatePlaceholderInfo"})," in the future."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"config"}),": buck audit config"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"configurations"}),": prints the constraints for configuration IDs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"includes"}),": list build file extensions imported at parse time."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"prelude"}),": print the interpreter prelude to stdout"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"providers"}),": prints out the providers for a target pattern"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"subtargets"}),": Print all subtargets"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"analysis-queries"}),": buck audit analysis resolving query attrs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"execution-platform-resolution"}),": prints out information about execution platform resolution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"visibility"}),": Verify the visibility for transitive deps of the specified target(s) on the unconfigured target graph"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"starlark"}),": Debug Starlark interpreter"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"dep-files"}),": prints out the select files for a command"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"deferred-materializer"}),": Access and interact with the deferred materializer"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"output"}),": Query the action that produced the output artifact. Does not support BXL, test, scratch, or anon artifacts. If the configuration hash of the output path does not match the current platform configuration, the unconfigured target label will be returned."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"parse"}),": Parses the buck-out path into parts that may be useful (ex: config hash, file path to artifact)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"package-values"}),": Inspect package values"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"perf"}),": Commands for checking buck2 performance"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-cell",children:(0,s.jsx)(n.code,{children:"buck2 audit cell"})}),"\n",(0,s.jsx)(n.p,{children:"Query information about the [cells] list in .buckconfig."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit cell [OPTIONS] [CELL_ALIASES]..."})]}),"\n",(0,s.jsx)(n.h3,{id:"arguments",children:"Arguments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<CELL_ALIASES>"}),"\nCell aliases to query. These aliases will be resolved in the working directory cell."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-1",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h3,{id:"options",children:"Options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--json"}),"\nOutput in JSON format"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--paths-only"}),"\nDon't include the cell name in the output"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--aliases"}),"\nIf enabled and no explicit aliases are passed, will query for all aliases in the working directory cell."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-m, --modifier <VALUE>"}),"\nThis option is not used"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--disable-starlark-types"}),"\nDisable runtime type checking in Starlark interpreter."]}),"\n",(0,s.jsx)(n.p,{children:"This option is not stable, and can be used only locally to diagnose evaluation performance problems."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--stack"}),"\nRecord or show target call stacks."]}),"\n",(0,s.jsx)(n.p,{children:"Starlark call stacks will be included in duplicate targets error."}),"\n",(0,s.jsxs)(n.p,{children:["If a command outputs targets (like ",(0,s.jsx)(n.code,{children:"targets"})," command), starlark call stacks will be printed after the targets."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns <PROFILE_PATTERNS>"}),"\nEnables profiling for all evaluations whose evaluation identifier matches one of the provided patterns."]}),"\n",(0,s.jsxs)(n.p,{children:["Some examples identifiers: analysis/cell//buck2/app/buck2_action_impl",":buck2_action_impl"," (cfg",":linux-x86_64","#27ac5723e0c99706) load/cell//build_defs/json.bzl load/prelude//playground/test.bxl load/cell//build_defs/json.bzl@other_cell load_buildfile/fbcode//third-party-buck/platform010/build/ncurses load_packagefile/fbcode//cli/rust/cli_delegate anon_analysis/anon//:_anon_link_rule (anon: 766183dc9b6f680a) (fbcode//buck2/platform/execution",":linux-x86_64","#08961b14cfb182aa) bxl/prelude//playground/test.bxl",":playground"]}),"\n",(0,s.jsxs)(n.p,{children:["You can pass ",(0,s.jsx)(n.code,{children:"--profile-patterns=.*"})," to enable no-op profiling for everything (additionally pass ",(0,s.jsx)(n.code,{children:"--profile-patterns-mode=none"})," to use no-op profiling to just get a list of all the identifiers)."]}),"\n",(0,s.jsxs)(n.p,{children:["The profile results will be written to individual .profile files in ",(0,s.jsx)(n.code,{children:"<ROOT_OUTPUT>/<data+time>-<uuid>/"})," where ROOT_OUTPUT comes from the --profile-patterns-output flag. In that directory there will also be a file listing all the identifiers that were profiled."]}),"\n",(0,s.jsx)(n.p,{children:"Enabling/disabling profiling of an evaluation will invalidate the results of that evaluation and it will be recomputed. In some cases, this will cause other work to also need to be redone (for example, invalidating the result of loading PACKAGE files causes all consumers to be recomputed). But if you keep profiling options consistent between commands, only the work that is otherwise invalidated will be redone (and only for those would profiling results be created)."}),"\n",(0,s.jsx)(n.p,{children:"You must also pass --profile-patterns-mode and --profile-patterns-output."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--profile-patterns-output <PATH>"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns-mode <PROFILE_PATTERNS_MODE>"}),"\nProfile mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,s.jsx)(n.code,{children:"-allocated"})," or ",(0,s.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heaps after analysis completes. ",(0,s.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"time-flame"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"statement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"typecheck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"coverage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-file-package",children:(0,s.jsx)(n.code,{children:"buck2 audit file-package"})}),"\n",(0,s.jsx)(n.p,{children:"Map file paths to fully qualified package names."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit file-package [OPTIONS] [PATHS]..."})]}),"\n",(0,s.jsx)(n.h3,{id:"arguments-1",children:"Arguments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<PATHS>"}),"\nFile paths to resolve to package names (build files, directories, or any source files)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-2",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h3,{id:"options-1",children:"Options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--json"}),"\nOutput in JSON format"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-m, --modifier <VALUE>"}),"\nThis option is not used"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--disable-starlark-types"}),"\nDisable runtime type checking in Starlark interpreter."]}),"\n",(0,s.jsx)(n.p,{children:"This option is not stable, and can be used only locally to diagnose evaluation performance problems."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--stack"}),"\nRecord or show target call stacks."]}),"\n",(0,s.jsx)(n.p,{children:"Starlark call stacks will be included in duplicate targets error."}),"\n",(0,s.jsxs)(n.p,{children:["If a command outputs targets (like ",(0,s.jsx)(n.code,{children:"targets"})," command), starlark call stacks will be printed after the targets."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns <PROFILE_PATTERNS>"}),"\nEnables profiling for all evaluations whose evaluation identifier matches one of the provided patterns."]}),"\n",(0,s.jsxs)(n.p,{children:["Some examples identifiers: analysis/cell//buck2/app/buck2_action_impl",":buck2_action_impl"," (cfg",":linux-x86_64","#27ac5723e0c99706) load/cell//build_defs/json.bzl load/prelude//playground/test.bxl load/cell//build_defs/json.bzl@other_cell load_buildfile/fbcode//third-party-buck/platform010/build/ncurses load_packagefile/fbcode//cli/rust/cli_delegate anon_analysis/anon//:_anon_link_rule (anon: 766183dc9b6f680a) (fbcode//buck2/platform/execution",":linux-x86_64","#08961b14cfb182aa) bxl/prelude//playground/test.bxl",":playground"]}),"\n",(0,s.jsxs)(n.p,{children:["You can pass ",(0,s.jsx)(n.code,{children:"--profile-patterns=.*"})," to enable no-op profiling for everything (additionally pass ",(0,s.jsx)(n.code,{children:"--profile-patterns-mode=none"})," to use no-op profiling to just get a list of all the identifiers)."]}),"\n",(0,s.jsxs)(n.p,{children:["The profile results will be written to individual .profile files in ",(0,s.jsx)(n.code,{children:"<ROOT_OUTPUT>/<data+time>-<uuid>/"})," where ROOT_OUTPUT comes from the --profile-patterns-output flag. In that directory there will also be a file listing all the identifiers that were profiled."]}),"\n",(0,s.jsx)(n.p,{children:"Enabling/disabling profiling of an evaluation will invalidate the results of that evaluation and it will be recomputed. In some cases, this will cause other work to also need to be redone (for example, invalidating the result of loading PACKAGE files causes all consumers to be recomputed). But if you keep profiling options consistent between commands, only the work that is otherwise invalidated will be redone (and only for those would profiling results be created)."}),"\n",(0,s.jsx)(n.p,{children:"You must also pass --profile-patterns-mode and --profile-patterns-output."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--profile-patterns-output <PATH>"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns-mode <PROFILE_PATTERNS_MODE>"}),"\nProfile mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,s.jsx)(n.code,{children:"-allocated"})," or ",(0,s.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heaps after analysis completes. ",(0,s.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"time-flame"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"statement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"typecheck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"coverage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-classpath",children:(0,s.jsx)(n.code,{children:"buck2 audit classpath"})}),"\n",(0,s.jsxs)(n.p,{children:["Prints out a target's classpaths if it has one.\nThis command is deprecated and currently available for compatibility with buck1.\nWe will replace this command with something that can audit the entire ",(0,s.jsx)(n.code,{children:"TemplatePlaceholderInfo"})," in the future."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit classpath [OPTIONS] [TARGET_PATTERNS]..."})]}),"\n",(0,s.jsx)(n.h3,{id:"arguments-2",children:"Arguments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<TARGET_PATTERNS>"}),"\nTarget patterns to audit"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-3",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h3,{id:"options-2",children:"Options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--json"}),"\nOutput in JSON format"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--target-platforms <PLATFORM>"}),"\nConfiguration target (one) to use to configure targets"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-m, --modifier <VALUE>"}),"\nA configuration modifier to configure all targets on the command line. This may be a constraint value target."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--disable-starlark-types"}),"\nDisable runtime type checking in Starlark interpreter."]}),"\n",(0,s.jsx)(n.p,{children:"This option is not stable, and can be used only locally to diagnose evaluation performance problems."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--stack"}),"\nRecord or show target call stacks."]}),"\n",(0,s.jsx)(n.p,{children:"Starlark call stacks will be included in duplicate targets error."}),"\n",(0,s.jsxs)(n.p,{children:["If a command outputs targets (like ",(0,s.jsx)(n.code,{children:"targets"})," command), starlark call stacks will be printed after the targets."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns <PROFILE_PATTERNS>"}),"\nEnables profiling for all evaluations whose evaluation identifier matches one of the provided patterns."]}),"\n",(0,s.jsxs)(n.p,{children:["Some examples identifiers: analysis/cell//buck2/app/buck2_action_impl",":buck2_action_impl"," (cfg",":linux-x86_64","#27ac5723e0c99706) load/cell//build_defs/json.bzl load/prelude//playground/test.bxl load/cell//build_defs/json.bzl@other_cell load_buildfile/fbcode//third-party-buck/platform010/build/ncurses load_packagefile/fbcode//cli/rust/cli_delegate anon_analysis/anon//:_anon_link_rule (anon: 766183dc9b6f680a) (fbcode//buck2/platform/execution",":linux-x86_64","#08961b14cfb182aa) bxl/prelude//playground/test.bxl",":playground"]}),"\n",(0,s.jsxs)(n.p,{children:["You can pass ",(0,s.jsx)(n.code,{children:"--profile-patterns=.*"})," to enable no-op profiling for everything (additionally pass ",(0,s.jsx)(n.code,{children:"--profile-patterns-mode=none"})," to use no-op profiling to just get a list of all the identifiers)."]}),"\n",(0,s.jsxs)(n.p,{children:["The profile results will be written to individual .profile files in ",(0,s.jsx)(n.code,{children:"<ROOT_OUTPUT>/<data+time>-<uuid>/"})," where ROOT_OUTPUT comes from the --profile-patterns-output flag. In that directory there will also be a file listing all the identifiers that were profiled."]}),"\n",(0,s.jsx)(n.p,{children:"Enabling/disabling profiling of an evaluation will invalidate the results of that evaluation and it will be recomputed. In some cases, this will cause other work to also need to be redone (for example, invalidating the result of loading PACKAGE files causes all consumers to be recomputed). But if you keep profiling options consistent between commands, only the work that is otherwise invalidated will be redone (and only for those would profiling results be created)."}),"\n",(0,s.jsx)(n.p,{children:"You must also pass --profile-patterns-mode and --profile-patterns-output."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--profile-patterns-output <PATH>"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns-mode <PROFILE_PATTERNS_MODE>"}),"\nProfile mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,s.jsx)(n.code,{children:"-allocated"})," or ",(0,s.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heaps after analysis completes. ",(0,s.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"time-flame"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"statement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"typecheck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"coverage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-config",children:(0,s.jsx)(n.code,{children:"buck2 audit config"})}),"\n",(0,s.jsx)(n.p,{children:"buck audit config"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit config [OPTIONS] [SPECS]..."})]}),"\n",(0,s.jsx)(n.h3,{id:"arguments-3",children:"Arguments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<SPECS>"}),"\nconfig section/key specs of the form ",(0,s.jsx)(n.code,{children:"section"})," or ",(0,s.jsx)(n.code,{children:"section.key"}),". If any specs are provided, only values matching a spec will be printed (section headers will be printed only for sections with a key matching the spec)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-4",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h3,{id:"options-3",children:"Options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--cell <CELL>"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--all-cells"}),"\nProduce information for all cells that Buck2 knows about"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--output-format <OUTPUT_FORMAT>"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"simple"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"json"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--json"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--location <LOCATION_STYLE>"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Default value: ",(0,s.jsx)(n.code,{children:"none"})]}),"\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"direct"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"extended"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--value <VALUE_STYLE>"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Default value: ",(0,s.jsx)(n.code,{children:"resolved"})]}),"\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"resolved"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"raw"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"both"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-m, --modifier <VALUE>"}),"\nThis option is not used"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--disable-starlark-types"}),"\nDisable runtime type checking in Starlark interpreter."]}),"\n",(0,s.jsx)(n.p,{children:"This option is not stable, and can be used only locally to diagnose evaluation performance problems."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--stack"}),"\nRecord or show target call stacks."]}),"\n",(0,s.jsx)(n.p,{children:"Starlark call stacks will be included in duplicate targets error."}),"\n",(0,s.jsxs)(n.p,{children:["If a command outputs targets (like ",(0,s.jsx)(n.code,{children:"targets"})," command), starlark call stacks will be printed after the targets."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns <PROFILE_PATTERNS>"}),"\nEnables profiling for all evaluations whose evaluation identifier matches one of the provided patterns."]}),"\n",(0,s.jsxs)(n.p,{children:["Some examples identifiers: analysis/cell//buck2/app/buck2_action_impl",":buck2_action_impl"," (cfg",":linux-x86_64","#27ac5723e0c99706) load/cell//build_defs/json.bzl load/prelude//playground/test.bxl load/cell//build_defs/json.bzl@other_cell load_buildfile/fbcode//third-party-buck/platform010/build/ncurses load_packagefile/fbcode//cli/rust/cli_delegate anon_analysis/anon//:_anon_link_rule (anon: 766183dc9b6f680a) (fbcode//buck2/platform/execution",":linux-x86_64","#08961b14cfb182aa) bxl/prelude//playground/test.bxl",":playground"]}),"\n",(0,s.jsxs)(n.p,{children:["You can pass ",(0,s.jsx)(n.code,{children:"--profile-patterns=.*"})," to enable no-op profiling for everything (additionally pass ",(0,s.jsx)(n.code,{children:"--profile-patterns-mode=none"})," to use no-op profiling to just get a list of all the identifiers)."]}),"\n",(0,s.jsxs)(n.p,{children:["The profile results will be written to individual .profile files in ",(0,s.jsx)(n.code,{children:"<ROOT_OUTPUT>/<data+time>-<uuid>/"})," where ROOT_OUTPUT comes from the --profile-patterns-output flag. In that directory there will also be a file listing all the identifiers that were profiled."]}),"\n",(0,s.jsx)(n.p,{children:"Enabling/disabling profiling of an evaluation will invalidate the results of that evaluation and it will be recomputed. In some cases, this will cause other work to also need to be redone (for example, invalidating the result of loading PACKAGE files causes all consumers to be recomputed). But if you keep profiling options consistent between commands, only the work that is otherwise invalidated will be redone (and only for those would profiling results be created)."}),"\n",(0,s.jsx)(n.p,{children:"You must also pass --profile-patterns-mode and --profile-patterns-output."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--profile-patterns-output <PATH>"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns-mode <PROFILE_PATTERNS_MODE>"}),"\nProfile mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,s.jsx)(n.code,{children:"-allocated"})," or ",(0,s.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heaps after analysis completes. ",(0,s.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"time-flame"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"statement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"typecheck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"coverage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-configurations",children:(0,s.jsx)(n.code,{children:"buck2 audit configurations"})}),"\n",(0,s.jsx)(n.p,{children:"prints the constraints for configuration IDs"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit configurations [OPTIONS] [configurations]..."})]}),"\n",(0,s.jsx)(n.h3,{id:"arguments-4",children:"Arguments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<configurations>"}),"\nconfigurations to audit (example: ",(0,s.jsx)(n.code,{children:"cell//package:target-105fe3389fc7e436"}),"). If none provided, will print information about all known configurations."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-5",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h3,{id:"options-4",children:"Options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-m, --modifier <VALUE>"}),"\nThis option is not used"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--disable-starlark-types"}),"\nDisable runtime type checking in Starlark interpreter."]}),"\n",(0,s.jsx)(n.p,{children:"This option is not stable, and can be used only locally to diagnose evaluation performance problems."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--stack"}),"\nRecord or show target call stacks."]}),"\n",(0,s.jsx)(n.p,{children:"Starlark call stacks will be included in duplicate targets error."}),"\n",(0,s.jsxs)(n.p,{children:["If a command outputs targets (like ",(0,s.jsx)(n.code,{children:"targets"})," command), starlark call stacks will be printed after the targets."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns <PROFILE_PATTERNS>"}),"\nEnables profiling for all evaluations whose evaluation identifier matches one of the provided patterns."]}),"\n",(0,s.jsxs)(n.p,{children:["Some examples identifiers: analysis/cell//buck2/app/buck2_action_impl",":buck2_action_impl"," (cfg",":linux-x86_64","#27ac5723e0c99706) load/cell//build_defs/json.bzl load/prelude//playground/test.bxl load/cell//build_defs/json.bzl@other_cell load_buildfile/fbcode//third-party-buck/platform010/build/ncurses load_packagefile/fbcode//cli/rust/cli_delegate anon_analysis/anon//:_anon_link_rule (anon: 766183dc9b6f680a) (fbcode//buck2/platform/execution",":linux-x86_64","#08961b14cfb182aa) bxl/prelude//playground/test.bxl",":playground"]}),"\n",(0,s.jsxs)(n.p,{children:["You can pass ",(0,s.jsx)(n.code,{children:"--profile-patterns=.*"})," to enable no-op profiling for everything (additionally pass ",(0,s.jsx)(n.code,{children:"--profile-patterns-mode=none"})," to use no-op profiling to just get a list of all the identifiers)."]}),"\n",(0,s.jsxs)(n.p,{children:["The profile results will be written to individual .profile files in ",(0,s.jsx)(n.code,{children:"<ROOT_OUTPUT>/<data+time>-<uuid>/"})," where ROOT_OUTPUT comes from the --profile-patterns-output flag. In that directory there will also be a file listing all the identifiers that were profiled."]}),"\n",(0,s.jsx)(n.p,{children:"Enabling/disabling profiling of an evaluation will invalidate the results of that evaluation and it will be recomputed. In some cases, this will cause other work to also need to be redone (for example, invalidating the result of loading PACKAGE files causes all consumers to be recomputed). But if you keep profiling options consistent between commands, only the work that is otherwise invalidated will be redone (and only for those would profiling results be created)."}),"\n",(0,s.jsx)(n.p,{children:"You must also pass --profile-patterns-mode and --profile-patterns-output."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--profile-patterns-output <PATH>"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns-mode <PROFILE_PATTERNS_MODE>"}),"\nProfile mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,s.jsx)(n.code,{children:"-allocated"})," or ",(0,s.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heaps after analysis completes. ",(0,s.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"time-flame"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"statement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"typecheck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"coverage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-includes",children:(0,s.jsx)(n.code,{children:"buck2 audit includes"})}),"\n",(0,s.jsx)(n.p,{children:"list build file extensions imported at parse time."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit includes [OPTIONS] [BUILD_FILES]..."})]}),"\n",(0,s.jsx)(n.h3,{id:"arguments-5",children:"Arguments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<BUILD_FILES>"}),"\nBuild files to audit. These are expected to be relative paths from the working dir cell."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-6",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h3,{id:"options-5",children:"Options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--json"}),"\nPrint json representation of outputs"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-m, --modifier <VALUE>"}),"\nThis option is not used"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--disable-starlark-types"}),"\nDisable runtime type checking in Starlark interpreter."]}),"\n",(0,s.jsx)(n.p,{children:"This option is not stable, and can be used only locally to diagnose evaluation performance problems."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--stack"}),"\nRecord or show target call stacks."]}),"\n",(0,s.jsx)(n.p,{children:"Starlark call stacks will be included in duplicate targets error."}),"\n",(0,s.jsxs)(n.p,{children:["If a command outputs targets (like ",(0,s.jsx)(n.code,{children:"targets"})," command), starlark call stacks will be printed after the targets."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns <PROFILE_PATTERNS>"}),"\nEnables profiling for all evaluations whose evaluation identifier matches one of the provided patterns."]}),"\n",(0,s.jsxs)(n.p,{children:["Some examples identifiers: analysis/cell//buck2/app/buck2_action_impl",":buck2_action_impl"," (cfg",":linux-x86_64","#27ac5723e0c99706) load/cell//build_defs/json.bzl load/prelude//playground/test.bxl load/cell//build_defs/json.bzl@other_cell load_buildfile/fbcode//third-party-buck/platform010/build/ncurses load_packagefile/fbcode//cli/rust/cli_delegate anon_analysis/anon//:_anon_link_rule (anon: 766183dc9b6f680a) (fbcode//buck2/platform/execution",":linux-x86_64","#08961b14cfb182aa) bxl/prelude//playground/test.bxl",":playground"]}),"\n",(0,s.jsxs)(n.p,{children:["You can pass ",(0,s.jsx)(n.code,{children:"--profile-patterns=.*"})," to enable no-op profiling for everything (additionally pass ",(0,s.jsx)(n.code,{children:"--profile-patterns-mode=none"})," to use no-op profiling to just get a list of all the identifiers)."]}),"\n",(0,s.jsxs)(n.p,{children:["The profile results will be written to individual .profile files in ",(0,s.jsx)(n.code,{children:"<ROOT_OUTPUT>/<data+time>-<uuid>/"})," where ROOT_OUTPUT comes from the --profile-patterns-output flag. In that directory there will also be a file listing all the identifiers that were profiled."]}),"\n",(0,s.jsx)(n.p,{children:"Enabling/disabling profiling of an evaluation will invalidate the results of that evaluation and it will be recomputed. In some cases, this will cause other work to also need to be redone (for example, invalidating the result of loading PACKAGE files causes all consumers to be recomputed). But if you keep profiling options consistent between commands, only the work that is otherwise invalidated will be redone (and only for those would profiling results be created)."}),"\n",(0,s.jsx)(n.p,{children:"You must also pass --profile-patterns-mode and --profile-patterns-output."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--profile-patterns-output <PATH>"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns-mode <PROFILE_PATTERNS_MODE>"}),"\nProfile mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,s.jsx)(n.code,{children:"-allocated"})," or ",(0,s.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heaps after analysis completes. ",(0,s.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"time-flame"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"statement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"typecheck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"coverage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-prelude",children:(0,s.jsx)(n.code,{children:"buck2 audit prelude"})}),"\n",(0,s.jsx)(n.p,{children:"print the interpreter prelude to stdout"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit prelude [OPTIONS]"})]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-7",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h3,{id:"options-6",children:"Options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-m, --modifier <VALUE>"}),"\nThis option is not used"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--disable-starlark-types"}),"\nDisable runtime type checking in Starlark interpreter."]}),"\n",(0,s.jsx)(n.p,{children:"This option is not stable, and can be used only locally to diagnose evaluation performance problems."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--stack"}),"\nRecord or show target call stacks."]}),"\n",(0,s.jsx)(n.p,{children:"Starlark call stacks will be included in duplicate targets error."}),"\n",(0,s.jsxs)(n.p,{children:["If a command outputs targets (like ",(0,s.jsx)(n.code,{children:"targets"})," command), starlark call stacks will be printed after the targets."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns <PROFILE_PATTERNS>"}),"\nEnables profiling for all evaluations whose evaluation identifier matches one of the provided patterns."]}),"\n",(0,s.jsxs)(n.p,{children:["Some examples identifiers: analysis/cell//buck2/app/buck2_action_impl",":buck2_action_impl"," (cfg",":linux-x86_64","#27ac5723e0c99706) load/cell//build_defs/json.bzl load/prelude//playground/test.bxl load/cell//build_defs/json.bzl@other_cell load_buildfile/fbcode//third-party-buck/platform010/build/ncurses load_packagefile/fbcode//cli/rust/cli_delegate anon_analysis/anon//:_anon_link_rule (anon: 766183dc9b6f680a) (fbcode//buck2/platform/execution",":linux-x86_64","#08961b14cfb182aa) bxl/prelude//playground/test.bxl",":playground"]}),"\n",(0,s.jsxs)(n.p,{children:["You can pass ",(0,s.jsx)(n.code,{children:"--profile-patterns=.*"})," to enable no-op profiling for everything (additionally pass ",(0,s.jsx)(n.code,{children:"--profile-patterns-mode=none"})," to use no-op profiling to just get a list of all the identifiers)."]}),"\n",(0,s.jsxs)(n.p,{children:["The profile results will be written to individual .profile files in ",(0,s.jsx)(n.code,{children:"<ROOT_OUTPUT>/<data+time>-<uuid>/"})," where ROOT_OUTPUT comes from the --profile-patterns-output flag. In that directory there will also be a file listing all the identifiers that were profiled."]}),"\n",(0,s.jsx)(n.p,{children:"Enabling/disabling profiling of an evaluation will invalidate the results of that evaluation and it will be recomputed. In some cases, this will cause other work to also need to be redone (for example, invalidating the result of loading PACKAGE files causes all consumers to be recomputed). But if you keep profiling options consistent between commands, only the work that is otherwise invalidated will be redone (and only for those would profiling results be created)."}),"\n",(0,s.jsx)(n.p,{children:"You must also pass --profile-patterns-mode and --profile-patterns-output."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--profile-patterns-output <PATH>"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns-mode <PROFILE_PATTERNS_MODE>"}),"\nProfile mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,s.jsx)(n.code,{children:"-allocated"})," or ",(0,s.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heaps after analysis completes. ",(0,s.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"time-flame"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"statement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"typecheck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"coverage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-providers",children:(0,s.jsx)(n.code,{children:"buck2 audit providers"})}),"\n",(0,s.jsx)(n.p,{children:"prints out the providers for a target pattern"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit providers [OPTIONS] <TARGET_PATTERNS>..."})]}),"\n",(0,s.jsx)(n.h3,{id:"arguments-6",children:"Arguments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<TARGET_PATTERNS>"}),"\nPatterns to analyze"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-8",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h3,{id:"options-7",children:"Options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--quiet"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-l, --list"}),"\nList the available providers"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--print-debug"}),"\nPrint the providers using debug format (very verbose)"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-u, --target-universe <TARGET_UNIVERSE>"}),"\nComma separated list of targets to construct a configured target universe."]}),"\n",(0,s.jsxs)(n.p,{children:["When the option is specified, command targets are be resolved in this universe.\nAdditionally, ",(0,s.jsx)(n.code,{children:"--target-platforms="})," and ",(0,s.jsx)(n.code,{children:"--modifier="})," flags are be used to configure the\nuniverse targets, not the command targets."]}),"\n",(0,s.jsx)(n.p,{children:"This argument is particularly recommended on most non-trivial cqueries. In the absence of\nthis argument, buck2 will use the target literals in your cquery expression as the value\nfor this argument, which may not be what you want."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--target-platforms <PLATFORM>"}),"\nConfiguration target (one) to use to configure targets"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-m, --modifier <VALUE>"}),"\nA configuration modifier to configure all targets on the command line. This may be a constraint value target."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--disable-starlark-types"}),"\nDisable runtime type checking in Starlark interpreter."]}),"\n",(0,s.jsx)(n.p,{children:"This option is not stable, and can be used only locally to diagnose evaluation performance problems."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--stack"}),"\nRecord or show target call stacks."]}),"\n",(0,s.jsx)(n.p,{children:"Starlark call stacks will be included in duplicate targets error."}),"\n",(0,s.jsxs)(n.p,{children:["If a command outputs targets (like ",(0,s.jsx)(n.code,{children:"targets"})," command), starlark call stacks will be printed after the targets."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns <PROFILE_PATTERNS>"}),"\nEnables profiling for all evaluations whose evaluation identifier matches one of the provided patterns."]}),"\n",(0,s.jsxs)(n.p,{children:["Some examples identifiers: analysis/cell//buck2/app/buck2_action_impl",":buck2_action_impl"," (cfg",":linux-x86_64","#27ac5723e0c99706) load/cell//build_defs/json.bzl load/prelude//playground/test.bxl load/cell//build_defs/json.bzl@other_cell load_buildfile/fbcode//third-party-buck/platform010/build/ncurses load_packagefile/fbcode//cli/rust/cli_delegate anon_analysis/anon//:_anon_link_rule (anon: 766183dc9b6f680a) (fbcode//buck2/platform/execution",":linux-x86_64","#08961b14cfb182aa) bxl/prelude//playground/test.bxl",":playground"]}),"\n",(0,s.jsxs)(n.p,{children:["You can pass ",(0,s.jsx)(n.code,{children:"--profile-patterns=.*"})," to enable no-op profiling for everything (additionally pass ",(0,s.jsx)(n.code,{children:"--profile-patterns-mode=none"})," to use no-op profiling to just get a list of all the identifiers)."]}),"\n",(0,s.jsxs)(n.p,{children:["The profile results will be written to individual .profile files in ",(0,s.jsx)(n.code,{children:"<ROOT_OUTPUT>/<data+time>-<uuid>/"})," where ROOT_OUTPUT comes from the --profile-patterns-output flag. In that directory there will also be a file listing all the identifiers that were profiled."]}),"\n",(0,s.jsx)(n.p,{children:"Enabling/disabling profiling of an evaluation will invalidate the results of that evaluation and it will be recomputed. In some cases, this will cause other work to also need to be redone (for example, invalidating the result of loading PACKAGE files causes all consumers to be recomputed). But if you keep profiling options consistent between commands, only the work that is otherwise invalidated will be redone (and only for those would profiling results be created)."}),"\n",(0,s.jsx)(n.p,{children:"You must also pass --profile-patterns-mode and --profile-patterns-output."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--profile-patterns-output <PATH>"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns-mode <PROFILE_PATTERNS_MODE>"}),"\nProfile mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,s.jsx)(n.code,{children:"-allocated"})," or ",(0,s.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heaps after analysis completes. ",(0,s.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"time-flame"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"statement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"typecheck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"coverage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-subtargets",children:(0,s.jsx)(n.code,{children:"buck2 audit subtargets"})}),"\n",(0,s.jsx)(n.p,{children:"Print all subtargets"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit subtargets [OPTIONS] <TARGET_PATTERNS>..."})]}),"\n",(0,s.jsx)(n.h3,{id:"arguments-7",children:"Arguments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<TARGET_PATTERNS>"}),"\nPatterns to analyze"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-9",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h3,{id:"options-8",children:"Options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--shallow"}),"\nDo not recursively print all nested subtargets; print only the first level. This is set to false by default"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--json"}),"\nPrint subtargets as JSON"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-u, --target-universe <TARGET_UNIVERSE>"}),"\nComma separated list of targets to construct a configured target universe."]}),"\n",(0,s.jsxs)(n.p,{children:["When the option is specified, command targets are be resolved in this universe.\nAdditionally, ",(0,s.jsx)(n.code,{children:"--target-platforms="})," and ",(0,s.jsx)(n.code,{children:"--modifier="})," flags are be used to configure the\nuniverse targets, not the command targets."]}),"\n",(0,s.jsx)(n.p,{children:"This argument is particularly recommended on most non-trivial cqueries. In the absence of\nthis argument, buck2 will use the target literals in your cquery expression as the value\nfor this argument, which may not be what you want."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--target-platforms <PLATFORM>"}),"\nConfiguration target (one) to use to configure targets"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-m, --modifier <VALUE>"}),"\nA configuration modifier to configure all targets on the command line. This may be a constraint value target."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--disable-starlark-types"}),"\nDisable runtime type checking in Starlark interpreter."]}),"\n",(0,s.jsx)(n.p,{children:"This option is not stable, and can be used only locally to diagnose evaluation performance problems."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--stack"}),"\nRecord or show target call stacks."]}),"\n",(0,s.jsx)(n.p,{children:"Starlark call stacks will be included in duplicate targets error."}),"\n",(0,s.jsxs)(n.p,{children:["If a command outputs targets (like ",(0,s.jsx)(n.code,{children:"targets"})," command), starlark call stacks will be printed after the targets."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns <PROFILE_PATTERNS>"}),"\nEnables profiling for all evaluations whose evaluation identifier matches one of the provided patterns."]}),"\n",(0,s.jsxs)(n.p,{children:["Some examples identifiers: analysis/cell//buck2/app/buck2_action_impl",":buck2_action_impl"," (cfg",":linux-x86_64","#27ac5723e0c99706) load/cell//build_defs/json.bzl load/prelude//playground/test.bxl load/cell//build_defs/json.bzl@other_cell load_buildfile/fbcode//third-party-buck/platform010/build/ncurses load_packagefile/fbcode//cli/rust/cli_delegate anon_analysis/anon//:_anon_link_rule (anon: 766183dc9b6f680a) (fbcode//buck2/platform/execution",":linux-x86_64","#08961b14cfb182aa) bxl/prelude//playground/test.bxl",":playground"]}),"\n",(0,s.jsxs)(n.p,{children:["You can pass ",(0,s.jsx)(n.code,{children:"--profile-patterns=.*"})," to enable no-op profiling for everything (additionally pass ",(0,s.jsx)(n.code,{children:"--profile-patterns-mode=none"})," to use no-op profiling to just get a list of all the identifiers)."]}),"\n",(0,s.jsxs)(n.p,{children:["The profile results will be written to individual .profile files in ",(0,s.jsx)(n.code,{children:"<ROOT_OUTPUT>/<data+time>-<uuid>/"})," where ROOT_OUTPUT comes from the --profile-patterns-output flag. In that directory there will also be a file listing all the identifiers that were profiled."]}),"\n",(0,s.jsx)(n.p,{children:"Enabling/disabling profiling of an evaluation will invalidate the results of that evaluation and it will be recomputed. In some cases, this will cause other work to also need to be redone (for example, invalidating the result of loading PACKAGE files causes all consumers to be recomputed). But if you keep profiling options consistent between commands, only the work that is otherwise invalidated will be redone (and only for those would profiling results be created)."}),"\n",(0,s.jsx)(n.p,{children:"You must also pass --profile-patterns-mode and --profile-patterns-output."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--profile-patterns-output <PATH>"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns-mode <PROFILE_PATTERNS_MODE>"}),"\nProfile mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,s.jsx)(n.code,{children:"-allocated"})," or ",(0,s.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heaps after analysis completes. ",(0,s.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"time-flame"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"statement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"typecheck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"coverage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-analysis-queries",children:(0,s.jsx)(n.code,{children:"buck2 audit analysis-queries"})}),"\n",(0,s.jsx)(n.p,{children:"buck audit analysis resolving query attrs"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit analysis-queries [OPTIONS] [TARGET_PATTERNS]..."})]}),"\n",(0,s.jsx)(n.h3,{id:"arguments-8",children:"Arguments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<TARGET_PATTERNS>"}),"\nPatterns to evaluate. The query attributes for targets matching these patterns will be evaluated"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-10",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h3,{id:"options-9",children:"Options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--include-outputs"}),"\nEnable to print the outputs for the targets in the resolved queries"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-u, --target-universe <TARGET_UNIVERSE>"}),"\nComma separated list of targets to construct a configured target universe."]}),"\n",(0,s.jsxs)(n.p,{children:["When the option is specified, command targets are be resolved in this universe.\nAdditionally, ",(0,s.jsx)(n.code,{children:"--target-platforms="})," and ",(0,s.jsx)(n.code,{children:"--modifier="})," flags are be used to configure the\nuniverse targets, not the command targets."]}),"\n",(0,s.jsx)(n.p,{children:"This argument is particularly recommended on most non-trivial cqueries. In the absence of\nthis argument, buck2 will use the target literals in your cquery expression as the value\nfor this argument, which may not be what you want."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--target-platforms <PLATFORM>"}),"\nConfiguration target (one) to use to configure targets"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-m, --modifier <VALUE>"}),"\nA configuration modifier to configure all targets on the command line. This may be a constraint value target."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--disable-starlark-types"}),"\nDisable runtime type checking in Starlark interpreter."]}),"\n",(0,s.jsx)(n.p,{children:"This option is not stable, and can be used only locally to diagnose evaluation performance problems."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--stack"}),"\nRecord or show target call stacks."]}),"\n",(0,s.jsx)(n.p,{children:"Starlark call stacks will be included in duplicate targets error."}),"\n",(0,s.jsxs)(n.p,{children:["If a command outputs targets (like ",(0,s.jsx)(n.code,{children:"targets"})," command), starlark call stacks will be printed after the targets."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns <PROFILE_PATTERNS>"}),"\nEnables profiling for all evaluations whose evaluation identifier matches one of the provided patterns."]}),"\n",(0,s.jsxs)(n.p,{children:["Some examples identifiers: analysis/cell//buck2/app/buck2_action_impl",":buck2_action_impl"," (cfg",":linux-x86_64","#27ac5723e0c99706) load/cell//build_defs/json.bzl load/prelude//playground/test.bxl load/cell//build_defs/json.bzl@other_cell load_buildfile/fbcode//third-party-buck/platform010/build/ncurses load_packagefile/fbcode//cli/rust/cli_delegate anon_analysis/anon//:_anon_link_rule (anon: 766183dc9b6f680a) (fbcode//buck2/platform/execution",":linux-x86_64","#08961b14cfb182aa) bxl/prelude//playground/test.bxl",":playground"]}),"\n",(0,s.jsxs)(n.p,{children:["You can pass ",(0,s.jsx)(n.code,{children:"--profile-patterns=.*"})," to enable no-op profiling for everything (additionally pass ",(0,s.jsx)(n.code,{children:"--profile-patterns-mode=none"})," to use no-op profiling to just get a list of all the identifiers)."]}),"\n",(0,s.jsxs)(n.p,{children:["The profile results will be written to individual .profile files in ",(0,s.jsx)(n.code,{children:"<ROOT_OUTPUT>/<data+time>-<uuid>/"})," where ROOT_OUTPUT comes from the --profile-patterns-output flag. In that directory there will also be a file listing all the identifiers that were profiled."]}),"\n",(0,s.jsx)(n.p,{children:"Enabling/disabling profiling of an evaluation will invalidate the results of that evaluation and it will be recomputed. In some cases, this will cause other work to also need to be redone (for example, invalidating the result of loading PACKAGE files causes all consumers to be recomputed). But if you keep profiling options consistent between commands, only the work that is otherwise invalidated will be redone (and only for those would profiling results be created)."}),"\n",(0,s.jsx)(n.p,{children:"You must also pass --profile-patterns-mode and --profile-patterns-output."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--profile-patterns-output <PATH>"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns-mode <PROFILE_PATTERNS_MODE>"}),"\nProfile mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,s.jsx)(n.code,{children:"-allocated"})," or ",(0,s.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heaps after analysis completes. ",(0,s.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"time-flame"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"statement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"typecheck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"coverage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-execution-platform-resolution",children:(0,s.jsx)(n.code,{children:"buck2 audit execution-platform-resolution"})}),"\n",(0,s.jsx)(n.p,{children:"prints out information about execution platform resolution"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit execution-platform-resolution [OPTIONS] [TARGET_PATTERNS]..."})]}),"\n",(0,s.jsx)(n.h3,{id:"arguments-9",children:"Arguments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<TARGET_PATTERNS>"}),"\nPatterns to analyze"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-11",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h3,{id:"options-10",children:"Options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-u, --target-universe <TARGET_UNIVERSE>"}),"\nComma separated list of targets to construct a configured target universe."]}),"\n",(0,s.jsxs)(n.p,{children:["When the option is specified, command targets are be resolved in this universe.\nAdditionally, ",(0,s.jsx)(n.code,{children:"--target-platforms="})," and ",(0,s.jsx)(n.code,{children:"--modifier="})," flags are be used to configure the\nuniverse targets, not the command targets."]}),"\n",(0,s.jsx)(n.p,{children:"This argument is particularly recommended on most non-trivial cqueries. In the absence of\nthis argument, buck2 will use the target literals in your cquery expression as the value\nfor this argument, which may not be what you want."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--target-platforms <PLATFORM>"}),"\nConfiguration target (one) to use to configure targets"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-m, --modifier <VALUE>"}),"\nA configuration modifier to configure all targets on the command line. This may be a constraint value target."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--disable-starlark-types"}),"\nDisable runtime type checking in Starlark interpreter."]}),"\n",(0,s.jsx)(n.p,{children:"This option is not stable, and can be used only locally to diagnose evaluation performance problems."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--stack"}),"\nRecord or show target call stacks."]}),"\n",(0,s.jsx)(n.p,{children:"Starlark call stacks will be included in duplicate targets error."}),"\n",(0,s.jsxs)(n.p,{children:["If a command outputs targets (like ",(0,s.jsx)(n.code,{children:"targets"})," command), starlark call stacks will be printed after the targets."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns <PROFILE_PATTERNS>"}),"\nEnables profiling for all evaluations whose evaluation identifier matches one of the provided patterns."]}),"\n",(0,s.jsxs)(n.p,{children:["Some examples identifiers: analysis/cell//buck2/app/buck2_action_impl",":buck2_action_impl"," (cfg",":linux-x86_64","#27ac5723e0c99706) load/cell//build_defs/json.bzl load/prelude//playground/test.bxl load/cell//build_defs/json.bzl@other_cell load_buildfile/fbcode//third-party-buck/platform010/build/ncurses load_packagefile/fbcode//cli/rust/cli_delegate anon_analysis/anon//:_anon_link_rule (anon: 766183dc9b6f680a) (fbcode//buck2/platform/execution",":linux-x86_64","#08961b14cfb182aa) bxl/prelude//playground/test.bxl",":playground"]}),"\n",(0,s.jsxs)(n.p,{children:["You can pass ",(0,s.jsx)(n.code,{children:"--profile-patterns=.*"})," to enable no-op profiling for everything (additionally pass ",(0,s.jsx)(n.code,{children:"--profile-patterns-mode=none"})," to use no-op profiling to just get a list of all the identifiers)."]}),"\n",(0,s.jsxs)(n.p,{children:["The profile results will be written to individual .profile files in ",(0,s.jsx)(n.code,{children:"<ROOT_OUTPUT>/<data+time>-<uuid>/"})," where ROOT_OUTPUT comes from the --profile-patterns-output flag. In that directory there will also be a file listing all the identifiers that were profiled."]}),"\n",(0,s.jsx)(n.p,{children:"Enabling/disabling profiling of an evaluation will invalidate the results of that evaluation and it will be recomputed. In some cases, this will cause other work to also need to be redone (for example, invalidating the result of loading PACKAGE files causes all consumers to be recomputed). But if you keep profiling options consistent between commands, only the work that is otherwise invalidated will be redone (and only for those would profiling results be created)."}),"\n",(0,s.jsx)(n.p,{children:"You must also pass --profile-patterns-mode and --profile-patterns-output."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--profile-patterns-output <PATH>"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns-mode <PROFILE_PATTERNS_MODE>"}),"\nProfile mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,s.jsx)(n.code,{children:"-allocated"})," or ",(0,s.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heaps after analysis completes. ",(0,s.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"time-flame"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"statement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"typecheck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"coverage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-visibility",children:(0,s.jsx)(n.code,{children:"buck2 audit visibility"})}),"\n",(0,s.jsx)(n.p,{children:"Verify the visibility for transitive deps of the specified target(s) on the unconfigured target graph"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit visibility [OPTIONS] [TARGET_PATTERNS]..."})]}),"\n",(0,s.jsx)(n.h3,{id:"arguments-10",children:"Arguments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<TARGET_PATTERNS>"}),"\nTarget pattern(s) to analyze."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-12",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h3,{id:"options-11",children:"Options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-m, --modifier <VALUE>"}),"\nThis option is not used"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--disable-starlark-types"}),"\nDisable runtime type checking in Starlark interpreter."]}),"\n",(0,s.jsx)(n.p,{children:"This option is not stable, and can be used only locally to diagnose evaluation performance problems."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--stack"}),"\nRecord or show target call stacks."]}),"\n",(0,s.jsx)(n.p,{children:"Starlark call stacks will be included in duplicate targets error."}),"\n",(0,s.jsxs)(n.p,{children:["If a command outputs targets (like ",(0,s.jsx)(n.code,{children:"targets"})," command), starlark call stacks will be printed after the targets."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns <PROFILE_PATTERNS>"}),"\nEnables profiling for all evaluations whose evaluation identifier matches one of the provided patterns."]}),"\n",(0,s.jsxs)(n.p,{children:["Some examples identifiers: analysis/cell//buck2/app/buck2_action_impl",":buck2_action_impl"," (cfg",":linux-x86_64","#27ac5723e0c99706) load/cell//build_defs/json.bzl load/prelude//playground/test.bxl load/cell//build_defs/json.bzl@other_cell load_buildfile/fbcode//third-party-buck/platform010/build/ncurses load_packagefile/fbcode//cli/rust/cli_delegate anon_analysis/anon//:_anon_link_rule (anon: 766183dc9b6f680a) (fbcode//buck2/platform/execution",":linux-x86_64","#08961b14cfb182aa) bxl/prelude//playground/test.bxl",":playground"]}),"\n",(0,s.jsxs)(n.p,{children:["You can pass ",(0,s.jsx)(n.code,{children:"--profile-patterns=.*"})," to enable no-op profiling for everything (additionally pass ",(0,s.jsx)(n.code,{children:"--profile-patterns-mode=none"})," to use no-op profiling to just get a list of all the identifiers)."]}),"\n",(0,s.jsxs)(n.p,{children:["The profile results will be written to individual .profile files in ",(0,s.jsx)(n.code,{children:"<ROOT_OUTPUT>/<data+time>-<uuid>/"})," where ROOT_OUTPUT comes from the --profile-patterns-output flag. In that directory there will also be a file listing all the identifiers that were profiled."]}),"\n",(0,s.jsx)(n.p,{children:"Enabling/disabling profiling of an evaluation will invalidate the results of that evaluation and it will be recomputed. In some cases, this will cause other work to also need to be redone (for example, invalidating the result of loading PACKAGE files causes all consumers to be recomputed). But if you keep profiling options consistent between commands, only the work that is otherwise invalidated will be redone (and only for those would profiling results be created)."}),"\n",(0,s.jsx)(n.p,{children:"You must also pass --profile-patterns-mode and --profile-patterns-output."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--profile-patterns-output <PATH>"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns-mode <PROFILE_PATTERNS_MODE>"}),"\nProfile mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,s.jsx)(n.code,{children:"-allocated"})," or ",(0,s.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heaps after analysis completes. ",(0,s.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"time-flame"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"statement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"typecheck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"coverage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-starlark",children:(0,s.jsx)(n.code,{children:"buck2 audit starlark"})}),"\n",(0,s.jsx)(n.p,{children:"Debug Starlark interpreter"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit starlark <COMMAND>"})]}),"\n",(0,s.jsx)(n.h3,{id:"subcommands-1",children:"Subcommands:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"module"}),": Inspect Starlark module by fully qualified import string like foo//bar",":baz",".bzl"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"package-deps"}),": Inspect Starlark package file all bzl dependencies by package name like foo//bar/baz"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-13",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-starlark-module",children:(0,s.jsx)(n.code,{children:"buck2 audit starlark module"})}),"\n",(0,s.jsxs)(n.p,{children:["Inspect Starlark module by fully qualified import string like foo//bar",":baz",".bzl"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit starlark module [OPTIONS] <IMPORT_PATH>"})]}),"\n",(0,s.jsx)(n.h3,{id:"arguments-11",children:"Arguments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<IMPORT_PATH>"}),"\nModule import path"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-14",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h3,{id:"options-12",children:"Options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-m, --modifier <VALUE>"}),"\nThis option is not used"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--disable-starlark-types"}),"\nDisable runtime type checking in Starlark interpreter."]}),"\n",(0,s.jsx)(n.p,{children:"This option is not stable, and can be used only locally to diagnose evaluation performance problems."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--stack"}),"\nRecord or show target call stacks."]}),"\n",(0,s.jsx)(n.p,{children:"Starlark call stacks will be included in duplicate targets error."}),"\n",(0,s.jsxs)(n.p,{children:["If a command outputs targets (like ",(0,s.jsx)(n.code,{children:"targets"})," command), starlark call stacks will be printed after the targets."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns <PROFILE_PATTERNS>"}),"\nEnables profiling for all evaluations whose evaluation identifier matches one of the provided patterns."]}),"\n",(0,s.jsxs)(n.p,{children:["Some examples identifiers: analysis/cell//buck2/app/buck2_action_impl",":buck2_action_impl"," (cfg",":linux-x86_64","#27ac5723e0c99706) load/cell//build_defs/json.bzl load/prelude//playground/test.bxl load/cell//build_defs/json.bzl@other_cell load_buildfile/fbcode//third-party-buck/platform010/build/ncurses load_packagefile/fbcode//cli/rust/cli_delegate anon_analysis/anon//:_anon_link_rule (anon: 766183dc9b6f680a) (fbcode//buck2/platform/execution",":linux-x86_64","#08961b14cfb182aa) bxl/prelude//playground/test.bxl",":playground"]}),"\n",(0,s.jsxs)(n.p,{children:["You can pass ",(0,s.jsx)(n.code,{children:"--profile-patterns=.*"})," to enable no-op profiling for everything (additionally pass ",(0,s.jsx)(n.code,{children:"--profile-patterns-mode=none"})," to use no-op profiling to just get a list of all the identifiers)."]}),"\n",(0,s.jsxs)(n.p,{children:["The profile results will be written to individual .profile files in ",(0,s.jsx)(n.code,{children:"<ROOT_OUTPUT>/<data+time>-<uuid>/"})," where ROOT_OUTPUT comes from the --profile-patterns-output flag. In that directory there will also be a file listing all the identifiers that were profiled."]}),"\n",(0,s.jsx)(n.p,{children:"Enabling/disabling profiling of an evaluation will invalidate the results of that evaluation and it will be recomputed. In some cases, this will cause other work to also need to be redone (for example, invalidating the result of loading PACKAGE files causes all consumers to be recomputed). But if you keep profiling options consistent between commands, only the work that is otherwise invalidated will be redone (and only for those would profiling results be created)."}),"\n",(0,s.jsx)(n.p,{children:"You must also pass --profile-patterns-mode and --profile-patterns-output."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--profile-patterns-output <PATH>"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns-mode <PROFILE_PATTERNS_MODE>"}),"\nProfile mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,s.jsx)(n.code,{children:"-allocated"})," or ",(0,s.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heaps after analysis completes. ",(0,s.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"time-flame"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"statement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"typecheck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"coverage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-starlark-package-deps",children:(0,s.jsx)(n.code,{children:"buck2 audit starlark package-deps"})}),"\n",(0,s.jsx)(n.p,{children:"Inspect Starlark package file all bzl dependencies by package name like foo//bar/baz"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit starlark package-deps [OPTIONS] <PACKAGE>"})]}),"\n",(0,s.jsx)(n.h3,{id:"arguments-12",children:"Arguments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<PACKAGE>"}),"\nPackage"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-15",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h3,{id:"options-13",children:"Options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-m, --modifier <VALUE>"}),"\nThis option is not used"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--disable-starlark-types"}),"\nDisable runtime type checking in Starlark interpreter."]}),"\n",(0,s.jsx)(n.p,{children:"This option is not stable, and can be used only locally to diagnose evaluation performance problems."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--stack"}),"\nRecord or show target call stacks."]}),"\n",(0,s.jsx)(n.p,{children:"Starlark call stacks will be included in duplicate targets error."}),"\n",(0,s.jsxs)(n.p,{children:["If a command outputs targets (like ",(0,s.jsx)(n.code,{children:"targets"})," command), starlark call stacks will be printed after the targets."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns <PROFILE_PATTERNS>"}),"\nEnables profiling for all evaluations whose evaluation identifier matches one of the provided patterns."]}),"\n",(0,s.jsxs)(n.p,{children:["Some examples identifiers: analysis/cell//buck2/app/buck2_action_impl",":buck2_action_impl"," (cfg",":linux-x86_64","#27ac5723e0c99706) load/cell//build_defs/json.bzl load/prelude//playground/test.bxl load/cell//build_defs/json.bzl@other_cell load_buildfile/fbcode//third-party-buck/platform010/build/ncurses load_packagefile/fbcode//cli/rust/cli_delegate anon_analysis/anon//:_anon_link_rule (anon: 766183dc9b6f680a) (fbcode//buck2/platform/execution",":linux-x86_64","#08961b14cfb182aa) bxl/prelude//playground/test.bxl",":playground"]}),"\n",(0,s.jsxs)(n.p,{children:["You can pass ",(0,s.jsx)(n.code,{children:"--profile-patterns=.*"})," to enable no-op profiling for everything (additionally pass ",(0,s.jsx)(n.code,{children:"--profile-patterns-mode=none"})," to use no-op profiling to just get a list of all the identifiers)."]}),"\n",(0,s.jsxs)(n.p,{children:["The profile results will be written to individual .profile files in ",(0,s.jsx)(n.code,{children:"<ROOT_OUTPUT>/<data+time>-<uuid>/"})," where ROOT_OUTPUT comes from the --profile-patterns-output flag. In that directory there will also be a file listing all the identifiers that were profiled."]}),"\n",(0,s.jsx)(n.p,{children:"Enabling/disabling profiling of an evaluation will invalidate the results of that evaluation and it will be recomputed. In some cases, this will cause other work to also need to be redone (for example, invalidating the result of loading PACKAGE files causes all consumers to be recomputed). But if you keep profiling options consistent between commands, only the work that is otherwise invalidated will be redone (and only for those would profiling results be created)."}),"\n",(0,s.jsx)(n.p,{children:"You must also pass --profile-patterns-mode and --profile-patterns-output."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--profile-patterns-output <PATH>"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns-mode <PROFILE_PATTERNS_MODE>"}),"\nProfile mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,s.jsx)(n.code,{children:"-allocated"})," or ",(0,s.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heaps after analysis completes. ",(0,s.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"time-flame"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"statement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"typecheck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"coverage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-dep-files",children:(0,s.jsx)(n.code,{children:"buck2 audit dep-files"})}),"\n",(0,s.jsx)(n.p,{children:"prints out the select files for a command"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit dep-files [OPTIONS] <PATTERN> <CATEGORY> [IDENTIFIER]"})]}),"\n",(0,s.jsx)(n.h3,{id:"arguments-13",children:"Arguments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"<PATTERN>"}),"\nTarget to query dep files for"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"<CATEGORY>"}),"\nAction category"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"<IDENTIFIER>"}),"\nAction identifier"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-16",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h3,{id:"options-14",children:"Options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--target-platforms <PLATFORM>"}),"\nConfiguration target (one) to use to configure targets"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-m, --modifier <VALUE>"}),"\nA configuration modifier to configure all targets on the command line. This may be a constraint value target."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--disable-starlark-types"}),"\nDisable runtime type checking in Starlark interpreter."]}),"\n",(0,s.jsx)(n.p,{children:"This option is not stable, and can be used only locally to diagnose evaluation performance problems."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--stack"}),"\nRecord or show target call stacks."]}),"\n",(0,s.jsx)(n.p,{children:"Starlark call stacks will be included in duplicate targets error."}),"\n",(0,s.jsxs)(n.p,{children:["If a command outputs targets (like ",(0,s.jsx)(n.code,{children:"targets"})," command), starlark call stacks will be printed after the targets."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns <PROFILE_PATTERNS>"}),"\nEnables profiling for all evaluations whose evaluation identifier matches one of the provided patterns."]}),"\n",(0,s.jsxs)(n.p,{children:["Some examples identifiers: analysis/cell//buck2/app/buck2_action_impl",":buck2_action_impl"," (cfg",":linux-x86_64","#27ac5723e0c99706) load/cell//build_defs/json.bzl load/prelude//playground/test.bxl load/cell//build_defs/json.bzl@other_cell load_buildfile/fbcode//third-party-buck/platform010/build/ncurses load_packagefile/fbcode//cli/rust/cli_delegate anon_analysis/anon//:_anon_link_rule (anon: 766183dc9b6f680a) (fbcode//buck2/platform/execution",":linux-x86_64","#08961b14cfb182aa) bxl/prelude//playground/test.bxl",":playground"]}),"\n",(0,s.jsxs)(n.p,{children:["You can pass ",(0,s.jsx)(n.code,{children:"--profile-patterns=.*"})," to enable no-op profiling for everything (additionally pass ",(0,s.jsx)(n.code,{children:"--profile-patterns-mode=none"})," to use no-op profiling to just get a list of all the identifiers)."]}),"\n",(0,s.jsxs)(n.p,{children:["The profile results will be written to individual .profile files in ",(0,s.jsx)(n.code,{children:"<ROOT_OUTPUT>/<data+time>-<uuid>/"})," where ROOT_OUTPUT comes from the --profile-patterns-output flag. In that directory there will also be a file listing all the identifiers that were profiled."]}),"\n",(0,s.jsx)(n.p,{children:"Enabling/disabling profiling of an evaluation will invalidate the results of that evaluation and it will be recomputed. In some cases, this will cause other work to also need to be redone (for example, invalidating the result of loading PACKAGE files causes all consumers to be recomputed). But if you keep profiling options consistent between commands, only the work that is otherwise invalidated will be redone (and only for those would profiling results be created)."}),"\n",(0,s.jsx)(n.p,{children:"You must also pass --profile-patterns-mode and --profile-patterns-output."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--profile-patterns-output <PATH>"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns-mode <PROFILE_PATTERNS_MODE>"}),"\nProfile mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,s.jsx)(n.code,{children:"-allocated"})," or ",(0,s.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heaps after analysis completes. ",(0,s.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"time-flame"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"statement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"typecheck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"coverage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-deferred-materializer",children:(0,s.jsx)(n.code,{children:"buck2 audit deferred-materializer"})}),"\n",(0,s.jsx)(n.p,{children:"Access and interact with the deferred materializer"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit deferred-materializer [OPTIONS] <COMMAND>"})]}),"\n",(0,s.jsx)(n.h3,{id:"subcommands-2",children:"Subcommands:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"list"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"list-subscriptions"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"fsck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"refresh"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"get-refresh-log"}),": Get the log for TTL refreshes"]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"test-iter"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"flush-access-times"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-17",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h3,{id:"options-15",children:"Options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-m, --modifier <VALUE>"}),"\nThis option is not used"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--disable-starlark-types"}),"\nDisable runtime type checking in Starlark interpreter."]}),"\n",(0,s.jsx)(n.p,{children:"This option is not stable, and can be used only locally to diagnose evaluation performance problems."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--stack"}),"\nRecord or show target call stacks."]}),"\n",(0,s.jsx)(n.p,{children:"Starlark call stacks will be included in duplicate targets error."}),"\n",(0,s.jsxs)(n.p,{children:["If a command outputs targets (like ",(0,s.jsx)(n.code,{children:"targets"})," command), starlark call stacks will be printed after the targets."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns <PROFILE_PATTERNS>"}),"\nEnables profiling for all evaluations whose evaluation identifier matches one of the provided patterns."]}),"\n",(0,s.jsxs)(n.p,{children:["Some examples identifiers: analysis/cell//buck2/app/buck2_action_impl",":buck2_action_impl"," (cfg",":linux-x86_64","#27ac5723e0c99706) load/cell//build_defs/json.bzl load/prelude//playground/test.bxl load/cell//build_defs/json.bzl@other_cell load_buildfile/fbcode//third-party-buck/platform010/build/ncurses load_packagefile/fbcode//cli/rust/cli_delegate anon_analysis/anon//:_anon_link_rule (anon: 766183dc9b6f680a) (fbcode//buck2/platform/execution",":linux-x86_64","#08961b14cfb182aa) bxl/prelude//playground/test.bxl",":playground"]}),"\n",(0,s.jsxs)(n.p,{children:["You can pass ",(0,s.jsx)(n.code,{children:"--profile-patterns=.*"})," to enable no-op profiling for everything (additionally pass ",(0,s.jsx)(n.code,{children:"--profile-patterns-mode=none"})," to use no-op profiling to just get a list of all the identifiers)."]}),"\n",(0,s.jsxs)(n.p,{children:["The profile results will be written to individual .profile files in ",(0,s.jsx)(n.code,{children:"<ROOT_OUTPUT>/<data+time>-<uuid>/"})," where ROOT_OUTPUT comes from the --profile-patterns-output flag. In that directory there will also be a file listing all the identifiers that were profiled."]}),"\n",(0,s.jsx)(n.p,{children:"Enabling/disabling profiling of an evaluation will invalidate the results of that evaluation and it will be recomputed. In some cases, this will cause other work to also need to be redone (for example, invalidating the result of loading PACKAGE files causes all consumers to be recomputed). But if you keep profiling options consistent between commands, only the work that is otherwise invalidated will be redone (and only for those would profiling results be created)."}),"\n",(0,s.jsx)(n.p,{children:"You must also pass --profile-patterns-mode and --profile-patterns-output."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--profile-patterns-output <PATH>"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns-mode <PROFILE_PATTERNS_MODE>"}),"\nProfile mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,s.jsx)(n.code,{children:"-allocated"})," or ",(0,s.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heaps after analysis completes. ",(0,s.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"time-flame"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"statement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"typecheck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"coverage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-deferred-materializer-list",children:(0,s.jsx)(n.code,{children:"buck2 audit deferred-materializer list"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit deferred-materializer list"})]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-18",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-deferred-materializer-list-subscriptions",children:(0,s.jsx)(n.code,{children:"buck2 audit deferred-materializer list-subscriptions"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit deferred-materializer list-subscriptions"})]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-19",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-deferred-materializer-fsck",children:(0,s.jsx)(n.code,{children:"buck2 audit deferred-materializer fsck"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit deferred-materializer fsck"})]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-20",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-deferred-materializer-refresh",children:(0,s.jsx)(n.code,{children:"buck2 audit deferred-materializer refresh"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit deferred-materializer refresh <MIN_TTL>"})]}),"\n",(0,s.jsx)(n.h3,{id:"arguments-14",children:"Arguments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<MIN_TTL>"}),"\nMinimum TTL to require for actions"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-21",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-deferred-materializer-get-refresh-log",children:(0,s.jsx)(n.code,{children:"buck2 audit deferred-materializer get-refresh-log"})}),"\n",(0,s.jsx)(n.p,{children:"Get the log for TTL refreshes"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit deferred-materializer get-refresh-log"})]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-22",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-deferred-materializer-test-iter",children:(0,s.jsx)(n.code,{children:"buck2 audit deferred-materializer test-iter"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit deferred-materializer test-iter [OPTIONS]"})]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-23",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h3,{id:"options-16",children:"Options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--count <COUNT>"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Default value: ",(0,s.jsx)(n.code,{children:"1"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-deferred-materializer-flush-access-times",children:(0,s.jsx)(n.code,{children:"buck2 audit deferred-materializer flush-access-times"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit deferred-materializer flush-access-times"})]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-24",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-output",children:(0,s.jsx)(n.code,{children:"buck2 audit output"})}),"\n",(0,s.jsx)(n.p,{children:"Query the action that produced the output artifact. Does not support BXL, test, scratch, or anon artifacts. If the configuration hash of the output path does not match the current platform configuration, the unconfigured target label will be returned."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit output [OPTIONS] <OUTPUT_PATH>"})]}),"\n",(0,s.jsx)(n.h3,{id:"arguments-15",children:"Arguments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<OUTPUT_PATH>"}),"\nThe buck-out path to the build artifact, starting with ",(0,s.jsx)(n.code,{children:"buck-out"})," and including the configuration platform."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-25",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h3,{id:"options-17",children:"Options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--json"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-A, --output-all-attributes"}),"\nOutput all attributes, equivalent of --output-attribute ''."]}),"\n",(0,s.jsx)(n.p,{children:"Avoid using this flag in automation because it may be expensive to produce certain attributes, and because it makes harder to track which special attributes are used."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-B, --output-basic-attributes"}),"\nOutput basic attributes, namely those the user can supply, plus rule type and package name"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-a, --output-attribute <ATTRIBUTE>"}),'\nRegular expressions to match attributes. Regular expressions are used in "search" mode, so for example empty string matches all attributes including special attributes.']}),"\n",(0,s.jsxs)(n.p,{children:["When using in automation, please specify the regular expression to match the attribute precisely, for example ",(0,s.jsx)(n.code,{children:"--output-attribute '^headers$'"})," to make it easier to track which special attributes are used."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--output-attributes <ATTRIBUTE>"}),"\nDeprecated: Use ",(0,s.jsx)(n.code,{children:"--output-attribute"})," instead."]}),"\n",(0,s.jsx)(n.p,{children:"List of space-separated attributes to output, --output-attributes attr1 attr2."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--target-platforms <PLATFORM>"}),"\nConfiguration target (one) to use to configure targets"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-m, --modifier <VALUE>"}),"\nA configuration modifier to configure all targets on the command line. This may be a constraint value target."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--disable-starlark-types"}),"\nDisable runtime type checking in Starlark interpreter."]}),"\n",(0,s.jsx)(n.p,{children:"This option is not stable, and can be used only locally to diagnose evaluation performance problems."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--stack"}),"\nRecord or show target call stacks."]}),"\n",(0,s.jsx)(n.p,{children:"Starlark call stacks will be included in duplicate targets error."}),"\n",(0,s.jsxs)(n.p,{children:["If a command outputs targets (like ",(0,s.jsx)(n.code,{children:"targets"})," command), starlark call stacks will be printed after the targets."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns <PROFILE_PATTERNS>"}),"\nEnables profiling for all evaluations whose evaluation identifier matches one of the provided patterns."]}),"\n",(0,s.jsxs)(n.p,{children:["Some examples identifiers: analysis/cell//buck2/app/buck2_action_impl",":buck2_action_impl"," (cfg",":linux-x86_64","#27ac5723e0c99706) load/cell//build_defs/json.bzl load/prelude//playground/test.bxl load/cell//build_defs/json.bzl@other_cell load_buildfile/fbcode//third-party-buck/platform010/build/ncurses load_packagefile/fbcode//cli/rust/cli_delegate anon_analysis/anon//:_anon_link_rule (anon: 766183dc9b6f680a) (fbcode//buck2/platform/execution",":linux-x86_64","#08961b14cfb182aa) bxl/prelude//playground/test.bxl",":playground"]}),"\n",(0,s.jsxs)(n.p,{children:["You can pass ",(0,s.jsx)(n.code,{children:"--profile-patterns=.*"})," to enable no-op profiling for everything (additionally pass ",(0,s.jsx)(n.code,{children:"--profile-patterns-mode=none"})," to use no-op profiling to just get a list of all the identifiers)."]}),"\n",(0,s.jsxs)(n.p,{children:["The profile results will be written to individual .profile files in ",(0,s.jsx)(n.code,{children:"<ROOT_OUTPUT>/<data+time>-<uuid>/"})," where ROOT_OUTPUT comes from the --profile-patterns-output flag. In that directory there will also be a file listing all the identifiers that were profiled."]}),"\n",(0,s.jsx)(n.p,{children:"Enabling/disabling profiling of an evaluation will invalidate the results of that evaluation and it will be recomputed. In some cases, this will cause other work to also need to be redone (for example, invalidating the result of loading PACKAGE files causes all consumers to be recomputed). But if you keep profiling options consistent between commands, only the work that is otherwise invalidated will be redone (and only for those would profiling results be created)."}),"\n",(0,s.jsx)(n.p,{children:"You must also pass --profile-patterns-mode and --profile-patterns-output."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--profile-patterns-output <PATH>"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns-mode <PROFILE_PATTERNS_MODE>"}),"\nProfile mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,s.jsx)(n.code,{children:"-allocated"})," or ",(0,s.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heaps after analysis completes. ",(0,s.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"time-flame"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"statement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"typecheck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"coverage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-parse",children:(0,s.jsx)(n.code,{children:"buck2 audit parse"})}),"\n",(0,s.jsx)(n.p,{children:"Parses the buck-out path into parts that may be useful (ex: config hash, file path to artifact)."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit parse [OPTIONS] <OUTPUT_PATH>"})]}),"\n",(0,s.jsx)(n.h3,{id:"arguments-16",children:"Arguments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<OUTPUT_PATH>"}),"\nThe buck-out path to the build artifact, starting with ",(0,s.jsx)(n.code,{children:"buck-out"})," and including the configuration platform."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-26",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h3,{id:"options-18",children:"Options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--disable-starlark-types"}),"\nDisable runtime type checking in Starlark interpreter."]}),"\n",(0,s.jsx)(n.p,{children:"This option is not stable, and can be used only locally to diagnose evaluation performance problems."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--stack"}),"\nRecord or show target call stacks."]}),"\n",(0,s.jsx)(n.p,{children:"Starlark call stacks will be included in duplicate targets error."}),"\n",(0,s.jsxs)(n.p,{children:["If a command outputs targets (like ",(0,s.jsx)(n.code,{children:"targets"})," command), starlark call stacks will be printed after the targets."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns <PROFILE_PATTERNS>"}),"\nEnables profiling for all evaluations whose evaluation identifier matches one of the provided patterns."]}),"\n",(0,s.jsxs)(n.p,{children:["Some examples identifiers: analysis/cell//buck2/app/buck2_action_impl",":buck2_action_impl"," (cfg",":linux-x86_64","#27ac5723e0c99706) load/cell//build_defs/json.bzl load/prelude//playground/test.bxl load/cell//build_defs/json.bzl@other_cell load_buildfile/fbcode//third-party-buck/platform010/build/ncurses load_packagefile/fbcode//cli/rust/cli_delegate anon_analysis/anon//:_anon_link_rule (anon: 766183dc9b6f680a) (fbcode//buck2/platform/execution",":linux-x86_64","#08961b14cfb182aa) bxl/prelude//playground/test.bxl",":playground"]}),"\n",(0,s.jsxs)(n.p,{children:["You can pass ",(0,s.jsx)(n.code,{children:"--profile-patterns=.*"})," to enable no-op profiling for everything (additionally pass ",(0,s.jsx)(n.code,{children:"--profile-patterns-mode=none"})," to use no-op profiling to just get a list of all the identifiers)."]}),"\n",(0,s.jsxs)(n.p,{children:["The profile results will be written to individual .profile files in ",(0,s.jsx)(n.code,{children:"<ROOT_OUTPUT>/<data+time>-<uuid>/"})," where ROOT_OUTPUT comes from the --profile-patterns-output flag. In that directory there will also be a file listing all the identifiers that were profiled."]}),"\n",(0,s.jsx)(n.p,{children:"Enabling/disabling profiling of an evaluation will invalidate the results of that evaluation and it will be recomputed. In some cases, this will cause other work to also need to be redone (for example, invalidating the result of loading PACKAGE files causes all consumers to be recomputed). But if you keep profiling options consistent between commands, only the work that is otherwise invalidated will be redone (and only for those would profiling results be created)."}),"\n",(0,s.jsx)(n.p,{children:"You must also pass --profile-patterns-mode and --profile-patterns-output."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--profile-patterns-output <PATH>"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns-mode <PROFILE_PATTERNS_MODE>"}),"\nProfile mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,s.jsx)(n.code,{children:"-allocated"})," or ",(0,s.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heaps after analysis completes. ",(0,s.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"time-flame"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"statement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"typecheck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"coverage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-package-values",children:(0,s.jsx)(n.code,{children:"buck2 audit package-values"})}),"\n",(0,s.jsx)(n.p,{children:"Inspect package values."}),"\n",(0,s.jsxs)(n.p,{children:["Package values is the thing set with ",(0,s.jsx)(n.code,{children:"write_package_value"})," function from ",(0,s.jsx)(n.code,{children:"PACKAGE"})," files."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit package-values [OPTIONS] [PACKAGES]..."})]}),"\n",(0,s.jsx)(n.h3,{id:"arguments-17",children:"Arguments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<PACKAGES>"}),"\nPackage names to inspect (like ",(0,s.jsx)(n.code,{children:"//foo/bar"}),", no trailing colon)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-27",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h3,{id:"options-19",children:"Options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-m, --modifier <VALUE>"}),"\nThis option is not used"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--disable-starlark-types"}),"\nDisable runtime type checking in Starlark interpreter."]}),"\n",(0,s.jsx)(n.p,{children:"This option is not stable, and can be used only locally to diagnose evaluation performance problems."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--stack"}),"\nRecord or show target call stacks."]}),"\n",(0,s.jsx)(n.p,{children:"Starlark call stacks will be included in duplicate targets error."}),"\n",(0,s.jsxs)(n.p,{children:["If a command outputs targets (like ",(0,s.jsx)(n.code,{children:"targets"})," command), starlark call stacks will be printed after the targets."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns <PROFILE_PATTERNS>"}),"\nEnables profiling for all evaluations whose evaluation identifier matches one of the provided patterns."]}),"\n",(0,s.jsxs)(n.p,{children:["Some examples identifiers: analysis/cell//buck2/app/buck2_action_impl",":buck2_action_impl"," (cfg",":linux-x86_64","#27ac5723e0c99706) load/cell//build_defs/json.bzl load/prelude//playground/test.bxl load/cell//build_defs/json.bzl@other_cell load_buildfile/fbcode//third-party-buck/platform010/build/ncurses load_packagefile/fbcode//cli/rust/cli_delegate anon_analysis/anon//:_anon_link_rule (anon: 766183dc9b6f680a) (fbcode//buck2/platform/execution",":linux-x86_64","#08961b14cfb182aa) bxl/prelude//playground/test.bxl",":playground"]}),"\n",(0,s.jsxs)(n.p,{children:["You can pass ",(0,s.jsx)(n.code,{children:"--profile-patterns=.*"})," to enable no-op profiling for everything (additionally pass ",(0,s.jsx)(n.code,{children:"--profile-patterns-mode=none"})," to use no-op profiling to just get a list of all the identifiers)."]}),"\n",(0,s.jsxs)(n.p,{children:["The profile results will be written to individual .profile files in ",(0,s.jsx)(n.code,{children:"<ROOT_OUTPUT>/<data+time>-<uuid>/"})," where ROOT_OUTPUT comes from the --profile-patterns-output flag. In that directory there will also be a file listing all the identifiers that were profiled."]}),"\n",(0,s.jsx)(n.p,{children:"Enabling/disabling profiling of an evaluation will invalidate the results of that evaluation and it will be recomputed. In some cases, this will cause other work to also need to be redone (for example, invalidating the result of loading PACKAGE files causes all consumers to be recomputed). But if you keep profiling options consistent between commands, only the work that is otherwise invalidated will be redone (and only for those would profiling results be created)."}),"\n",(0,s.jsx)(n.p,{children:"You must also pass --profile-patterns-mode and --profile-patterns-output."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--profile-patterns-output <PATH>"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns-mode <PROFILE_PATTERNS_MODE>"}),"\nProfile mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,s.jsx)(n.code,{children:"-allocated"})," or ",(0,s.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heaps after analysis completes. ",(0,s.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"time-flame"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"statement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"typecheck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"coverage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-perf",children:(0,s.jsx)(n.code,{children:"buck2 audit perf"})}),"\n",(0,s.jsx)(n.p,{children:"Commands for checking buck2 performance"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit perf <COMMAND>"})]}),"\n",(0,s.jsx)(n.h3,{id:"subcommands-3",children:"Subcommands:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"configured-graph-size"}),": utility to measure performance of configured graph size computation"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-28",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h2,{id:"buck2-audit-perf-configured-graph-size",children:(0,s.jsx)(n.code,{children:"buck2 audit perf configured-graph-size"})}),"\n",(0,s.jsx)(n.p,{children:"utility to measure performance of configured graph size computation"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": ",(0,s.jsx)(n.code,{children:"buck2 audit perf configured-graph-size [OPTIONS] [TARGET_PATTERNS]..."})]}),"\n",(0,s.jsx)(n.h3,{id:"arguments-18",children:"Arguments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<TARGET_PATTERNS>"}),"\nTarget patterns to audit"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-options-29",children:"Common Options:"}),"\n",(0,s.jsxs)(n.p,{children:["Common options are documented on the ",(0,s.jsx)(n.a,{href:"../common-options",children:"Common Options"})," page."]}),"\n",(0,s.jsx)(n.h3,{id:"options-20",children:"Options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--json"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--sketch"}),"\nwhether to compute sketch or not"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-u, --target-universe <TARGET_UNIVERSE>"}),"\nComma separated list of targets to construct a configured target universe."]}),"\n",(0,s.jsxs)(n.p,{children:["When the option is specified, command targets are be resolved in this universe.\nAdditionally, ",(0,s.jsx)(n.code,{children:"--target-platforms="})," and ",(0,s.jsx)(n.code,{children:"--modifier="})," flags are be used to configure the\nuniverse targets, not the command targets."]}),"\n",(0,s.jsx)(n.p,{children:"This argument is particularly recommended on most non-trivial cqueries. In the absence of\nthis argument, buck2 will use the target literals in your cquery expression as the value\nfor this argument, which may not be what you want."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--target-platforms <PLATFORM>"}),"\nConfiguration target (one) to use to configure targets"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-m, --modifier <VALUE>"}),"\nA configuration modifier to configure all targets on the command line. This may be a constraint value target."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--disable-starlark-types"}),"\nDisable runtime type checking in Starlark interpreter."]}),"\n",(0,s.jsx)(n.p,{children:"This option is not stable, and can be used only locally to diagnose evaluation performance problems."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--stack"}),"\nRecord or show target call stacks."]}),"\n",(0,s.jsx)(n.p,{children:"Starlark call stacks will be included in duplicate targets error."}),"\n",(0,s.jsxs)(n.p,{children:["If a command outputs targets (like ",(0,s.jsx)(n.code,{children:"targets"})," command), starlark call stacks will be printed after the targets."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns <PROFILE_PATTERNS>"}),"\nEnables profiling for all evaluations whose evaluation identifier matches one of the provided patterns."]}),"\n",(0,s.jsxs)(n.p,{children:["Some examples identifiers: analysis/cell//buck2/app/buck2_action_impl",":buck2_action_impl"," (cfg",":linux-x86_64","#27ac5723e0c99706) load/cell//build_defs/json.bzl load/prelude//playground/test.bxl load/cell//build_defs/json.bzl@other_cell load_buildfile/fbcode//third-party-buck/platform010/build/ncurses load_packagefile/fbcode//cli/rust/cli_delegate anon_analysis/anon//:_anon_link_rule (anon: 766183dc9b6f680a) (fbcode//buck2/platform/execution",":linux-x86_64","#08961b14cfb182aa) bxl/prelude//playground/test.bxl",":playground"]}),"\n",(0,s.jsxs)(n.p,{children:["You can pass ",(0,s.jsx)(n.code,{children:"--profile-patterns=.*"})," to enable no-op profiling for everything (additionally pass ",(0,s.jsx)(n.code,{children:"--profile-patterns-mode=none"})," to use no-op profiling to just get a list of all the identifiers)."]}),"\n",(0,s.jsxs)(n.p,{children:["The profile results will be written to individual .profile files in ",(0,s.jsx)(n.code,{children:"<ROOT_OUTPUT>/<data+time>-<uuid>/"})," where ROOT_OUTPUT comes from the --profile-patterns-output flag. In that directory there will also be a file listing all the identifiers that were profiled."]}),"\n",(0,s.jsx)(n.p,{children:"Enabling/disabling profiling of an evaluation will invalidate the results of that evaluation and it will be recomputed. In some cases, this will cause other work to also need to be redone (for example, invalidating the result of loading PACKAGE files causes all consumers to be recomputed). But if you keep profiling options consistent between commands, only the work that is otherwise invalidated will be redone (and only for those would profiling results be created)."}),"\n",(0,s.jsx)(n.p,{children:"You must also pass --profile-patterns-mode and --profile-patterns-output."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"--profile-patterns-output <PATH>"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--profile-patterns-mode <PROFILE_PATTERNS_MODE>"}),"\nProfile mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Memory profiling modes have suffixes either ",(0,s.jsx)(n.code,{children:"-allocated"})," or ",(0,s.jsx)(n.code,{children:"-retained"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-retained"})," means memory kept in frozen starlark heaps after analysis completes. ",(0,s.jsx)(n.code,{children:"-retained"})," does not work when profiling loading, because no memory is retained after loading and frozen heap is not even created. This is probably what you want when profiling analysis."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-allocated"})," means allocated memory, including memory which is later garbage collected."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Possible values:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"time-flame"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-flame-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-allocated"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heap-summary-retained"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"statement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"bytecode-pairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"typecheck"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"coverage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"none"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);