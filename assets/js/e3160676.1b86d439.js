"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[30579],{765:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"bxl/explanation/labels_and_nodes","title":"Understanding Labels and Nodes in Buck2","description":"Buck2\'s labels and nodes are fundamental components that work together to","source":"@site/../docs/bxl/explanation/labels_and_nodes.md","sourceDirName":"bxl/explanation","slug":"/bxl/explanation/labels_and_nodes","permalink":"/docs/bxl/explanation/labels_and_nodes","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"labels_and_nodes","title":"Understanding Labels and Nodes in Buck2"},"sidebar":"main","previous":{"title":"BXL Basics","permalink":"/docs/bxl/explanation/basics"},"next":{"title":"BXL cquery vs. Buck2 CLI cquery - Divergence in Configuration Handling","permalink":"/docs/bxl/explanation/bxl_cquery_vs_cli_cquery"}}');var s=t(74848),i=t(28453),a=t(29030);const o={id:"labels_and_nodes",title:"Understanding Labels and Nodes in Buck2"},d=void 0,l={},c=[{value:"Overview",id:"overview",level:2},{value:"Key Distinctions",id:"key-distinctions",level:2},{value:"Configured vs Unconfigured",id:"configured-vs-unconfigured",level:3},{value:"Labels vs Nodes",id:"labels-vs-nodes",level:3},{value:"Target Labels vs Provider Labels",id:"target-labels-vs-provider-labels",level:3},{value:"Label and Nodes Conversion",id:"label-and-nodes-conversion",level:2}];function h(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Buck2's labels and nodes are fundamental components that work together to\nrepresent and track build targets in the build graph. Understanding how these\ndifferent types of labels and nodes relate to each other is essential not only\nfor writing BXL but also for working effectively with Buck2's architecture."}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"Buck2 uses several types of labels and nodes, each serving a specific purpose:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{}),(0,s.jsx)(n.th,{children:"target label"}),(0,s.jsx)(n.th,{children:"providers label"}),(0,s.jsx)(n.th,{children:"node"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"unconfigured"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"../../../api/build/TargetLabel",children:"TargetLabel"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"../../../api/build/ProvidersLabel",children:"ProvidersLabel"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"../../../api/bxl/UnconfiguredTargetNode",children:"UnconfiguredTargetNode"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"configured"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"../../../api/build/ConfiguredTargetLabel",children:"ConfiguredTargetLabel"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.a,{href:"../../../api/build/Label",children:"Label"})," (same as ",(0,s.jsx)(n.a,{href:"../../../api/build/ConfiguredProvidersLabel",children:"ConfiguredProvidersLabel"}),")"]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"../../../api/bxl/ConfiguredTargetNode",children:"ConfiguredTargetNode"})})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," As part of our ongoing improvements, we are migrating to more explicit\ntype names. TargetLabel and ProvidersLabel will be renamed to include the\n",(0,s.jsx)(n.code,{children:"Unconfigured"})," prefix for consistency."]}),"\n",(0,s.jsx)(n.p,{children:"The following diagram illustrates the relationships between these components:"}),"\n",(0,s.jsx)("img",{src:(0,a.default)("/img/target_node_label_relationship.png"),alt:"justifyContent"}),"\n",(0,s.jsx)(n.h2,{id:"key-distinctions",children:"Key Distinctions"}),"\n",(0,s.jsx)(n.h3,{id:"configured-vs-unconfigured",children:"Configured vs Unconfigured"}),"\n",(0,s.jsxs)(n.p,{children:["In the targets build graph, Buck2 operates with two main perspectives on build\ntargets: unconfigured and configured. You can refer\n",(0,s.jsx)(n.a,{href:"../../../developers/architecture/buck2/#execution-model",children:"execution model"})," to\nsee these two phase in a buck2 build."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Unconfigured"})," components are configuration independent representations. Think\nof them as the blueprint of your targets. For example, ",(0,s.jsx)(n.code,{children:"//buck2:buck2"})," is the\nrepresentation of ",(0,s.jsx)(n.code,{children:"buck2"}),"'s unconfigured target label."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Configured"})," components, on the other hand, include all the platform-specific\ndetails and other configurations needed for actual building. They have the\nnecessary information about how to build it for a specific platform or\nconfiguration. For example, ",(0,s.jsx)(n.code,{children:"//buck2:buck2 (cfg:linux-x86_64-xxxxxx)"})," is the\nrepresentation of ",(0,s.jsx)(n.code,{children:"buck2"}),"'s configured target label."]}),"\n",(0,s.jsx)(n.h3,{id:"labels-vs-nodes",children:"Labels vs Nodes"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Labels"})," are identifiers that uniquely reference targets in your build graph.\nThey're like addresses that tell Buck2 which target you're talking about. For\nexample, ",(0,s.jsx)(n.code,{children:"//buck2:buck2"})," is an unconfigured label that points to a specific\ntarget."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Nodes"})," contain the actual information about targets. They hold the data about\nwhat a target is, what it depends on, what attributes it has, etc."]}),"\n",(0,s.jsx)(n.h3,{id:"target-labels-vs-provider-labels",children:"Target Labels vs Provider Labels"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Target labels"})," (both configured and unconfigured) identify complete build\ntargets. For example, ",(0,s.jsx)(n.code,{children:"//buck2:buck2"})," refers to an entire target."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Provider labels"})," (both configured and unconfigured) represents a specific\npart of a target. For example, ",(0,s.jsx)(n.code,{children:"//buck2:buck2[llvm_ir]"})," represents ",(0,s.jsx)(n.code,{children:"buck2"}),"\ntarget's ",(0,s.jsx)(n.code,{children:"llvm_ir"})," sub-target"]}),"\n",(0,s.jsx)(n.h2,{id:"label-and-nodes-conversion",children:"Label and Nodes Conversion"}),"\n",(0,s.jsx)(n.p,{children:"This diagram shows how different components transform to each other using api"}),"\n",(0,s.jsx)("img",{src:(0,a.default)("/img/node_label_conversion.png"),alt:"justifyContent"})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(96540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);