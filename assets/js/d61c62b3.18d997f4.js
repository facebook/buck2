"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[94804],{28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var r=n(96540);const s={},o=r.createContext(s);function i(e){const t=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(o.Provider,{value:t},e.children)}},75362:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"bxl/how_tos/how_to_use_target_universe","title":"How to Use Target Universe in BXL","description":"BXL cquery and target universe","source":"@site/../docs/bxl/how_tos/how_to_use_target_universe.md","sourceDirName":"bxl/how_tos","slug":"/bxl/how_tos/how_to_use_target_universe","permalink":"/docs/bxl/how_tos/how_to_use_target_universe","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"how_to_use_target_universe","title":"How to Use Target Universe in BXL"},"sidebar":"main","previous":{"title":"How to run actions based on the content of artifact","permalink":"/docs/bxl/how_tos/how_to_run_actions_based_on_the_content_of_artifact"},"next":{"title":"How to Collect Telemetry Events","permalink":"/docs/bxl/how_tos/how_to_collect_telemetry_events"}}');var s=n(74848),o=n(28453);const i={id:"how_to_use_target_universe",title:"How to Use Target Universe in BXL"},a=void 0,c={},l=[{value:"BXL cquery and target universe",id:"bxl-cquery-and-target-universe",level:2},{value:"Specifying target universe in BXL cquery",id:"specifying-target-universe-in-bxl-cquery",level:3},{value:"What does the target universe tend to be in practice?",id:"what-does-the-target-universe-tend-to-be-in-practice",level:3},{value:"<code>keep-going</code>",id:"keep-going",level:3},{value:"BXL build and target universe",id:"bxl-build-and-target-universe",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"bxl-cquery-and-target-universe",children:"BXL cquery and target universe"}),"\n",(0,s.jsxs)(t.p,{children:["BXL cannot infer the\n",(0,s.jsx)(t.a,{href:"/docs/concepts/glossary#target-universe",children:"target universe"})," like in the CLI\n(in most cases). BXL splits up cquery functions per function (ex:\n",(0,s.jsx)(t.code,{children:"ctx.cquery().kind(...)"}),"), with the exception of ",(0,s.jsx)(t.code,{children:"ctx.cquery.eval(...)"}),", which\naccepts literals exactly like in the CLI. For the ",(0,s.jsx)(t.code,{children:"eval"})," query, target universe\nis inferred exactly like the CLI."]}),"\n",(0,s.jsx)(t.p,{children:"For all other cases, take the following query as an example:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.code,{children:'buck2 cquery "rdeps(deps(//example:foo), deps(//example:bar))"'})}),"\n",(0,s.jsxs)(t.p,{children:["The target universe here should be constructed from the all the target literals\nand their transitive deps, which is to say ",(0,s.jsx)(t.code,{children:"deps(//example:foo, //example:bar)"}),".\nWhen you run the query, the evaluation of ",(0,s.jsx)(t.code,{children:"deps(//example:foo)"})," and\n",(0,s.jsx)(t.code,{children:"deps(//example:bar)"})," nested in the ",(0,s.jsx)(t.code,{children:"rdeps"})," query will happen inside the\nuniverse resulting from ",(0,s.jsx)(t.code,{children:"deps(//example:foo, //example:bar)"}),". Translating it to\nBXL's individual cquery functions, and let\u2019s say we also try to use the target\nliterals to construct the universe as the CLI target inference does:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'from_node = ctx.cquery().deps("//example:foo") # universe would be //example:foo\n\nto_node = ctx.cquery().deps("//example:bar") # universe would be //example:bar\n\nrdeps = ctx.cquery().rdeps(from_node, to_node) # what is the universe here?\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Here, the ",(0,s.jsx)(t.code,{children:"from_node"})," query is actually evaluated in the wrong target universe\nbecause we have broken up the query steps in BXL. Instead of\n",(0,s.jsx)(t.code,{children:"deps(//example:foo)"})," being evaluated in ",(0,s.jsx)(t.code,{children:"deps(//example:foo, //example:bar)"}),",\nit\u2019s evaluated with only ",(0,s.jsx)(t.code,{children:"deps(//example:foo)"}),". It\u2019s impossible to know that\nthere\u2019s going to be an rdeps query later on that expects a different target\nuniverse."]}),"\n",(0,s.jsx)(t.h3,{id:"specifying-target-universe-in-bxl-cquery",children:"Specifying target universe in BXL cquery"}),"\n",(0,s.jsxs)(t.p,{children:["BXL cquery functions should only accept configured targets as inputs, with the\nexception of ",(0,s.jsx)(t.code,{children:"eval"})," and ",(0,s.jsx)(t.code,{children:"testsof_with_default_platform"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["BXL has a ",(0,s.jsx)(t.code,{children:"ctx.target_universe()"})," function to construct a ",(0,s.jsx)(t.code,{children:"target_universe"}),"\nobject, which has a ",(0,s.jsx)(t.code,{children:"lookup()"})," function to lookup the configured targets within\nthe target universe and return the target set. \u200b\u200bThe lookup functionality is\nuseful because sometimes a single target can appear multiple times within a\ntarget universe. For example, if you specify a cxx toolchain using its\nunconfigured target label, it will always match against all cxx toolchains in\nthe target universe (so at least once for target deps and once for exec deps),\nsince cxx toolchains may have multiple configurations. Example:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'def _impl():\n    target_universe = ctx.target_universe(["//example:foo", "//example:bar"])\n    to_node = target_universe.lookup("//example:foo")\n    from_node = target_universe.lookup("//example:bar")\n    rdeps = ctx.cquery().rdeps(to_node, from_node)\n'})}),"\n",(0,s.jsxs)(t.p,{children:["However, sometimes you might want a specific configuration instead of using all\nconfigurations found within a target universe, in which case you could use\n",(0,s.jsx)(t.code,{children:"ctx.configured_targets(...)"})," to specify the configuration. Or, sometimes you\nmay want to use the specific configured target nodes resulting from other BXL\ncalls. In these cases, you can pass the configured targets directly into cquery\nfunctions, instead of going through target universe lookup."]}),"\n",(0,s.jsx)(t.h3,{id:"what-does-the-target-universe-tend-to-be-in-practice",children:"What does the target universe tend to be in practice?"}),"\n",(0,s.jsxs)(t.p,{children:["For ",(0,s.jsx)(t.code,{children:"owner"})," query, the universe would be constructed with the unconfigured\ntarget nodes returned from ",(0,s.jsx)(t.code,{children:"ctx.uquery().owner(...)"}),". Example:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'def _impl():\n    unconfigured_owners = ctx.uquery().owner("foobar")\n    target_universe = ctx.target_universe(unconfigured_owners).target_set()\n    owners = ctx.cquery().owner("foobar", target_universe)\n'})}),"\n",(0,s.jsx)(t.p,{children:"For everything else, the universe would usually be constructed using all target\nliterals found in your query. Example:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'def _impl():\n    target_universe = ctx.target_universe("//example:foo")\n    inputs = target_universe.target_set()\n    deps = ctx.cquery().deps(inputs)\n'})}),"\n",(0,s.jsxs)(t.p,{children:["While the above guideline should work for ",(0,s.jsx)(t.code,{children:"rdeps"})," as well, for ",(0,s.jsx)(t.code,{children:"rdeps"}),' the\nuniverse would usually be narrowed down to the "to"/"destination" target set\nargument. (This is a subset of the target universe suggested for non-',(0,s.jsx)(t.code,{children:"owner"}),"\nquery cases). Updating the example from above:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'def _impl():\n    target_universe = ctx.target_universe("//example:foo") # narrowed down to the "to" literals in rdeps\n    universe_node = target_universe.target_set()\n    from_node = target_universe.lookup("//example:bar")\n    rdeps = ctx.cquery().rdeps(universe_node, from_node)\n'})}),"\n",(0,s.jsx)(t.h3,{id:"keep-going",children:(0,s.jsx)(t.code,{children:"keep-going"})}),"\n",(0,s.jsxs)(t.p,{children:["The configured graph can be broken for various reasons: incompatible targets\n(BXL skips these automatically), visibility issues, nonexistent targets, etc.\nFor issues that are not incompatible targets, the ",(0,s.jsx)(t.code,{children:"target_universe"})," can be\nconstructed with the ",(0,s.jsx)(t.code,{children:"keep_going"})," flag set to ",(0,s.jsx)(t.code,{children:"True"})," to skip any other errors,\nand your cquery will not error out. Note that ",(0,s.jsx)(t.code,{children:"keep_going"})," is only compatible\nfor a single string literal target or target pattern at the moment."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'ctx.target_universe("//foo/...", keep_going = True)\n'})}),"\n",(0,s.jsx)(t.h2,{id:"bxl-build-and-target-universe",children:"BXL build and target universe"}),"\n",(0,s.jsx)(t.p,{children:"Note that BXL builds currently do not support target universe, but we intend to\nadd this."})]})}function u(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);