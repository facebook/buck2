#!/usr/bin/env python3
# Copyright (c) Meta Platforms, Inc. and affiliates.
#
# This source code is dual-licensed under either the MIT license found in the
# LICENSE-MIT file in the root directory of this source tree or the Apache
# License, Version 2.0 found in the LICENSE-APACHE file in the root directory
# of this source tree. You may select, at your option, one of the
# above-listed licenses.

"""
Generate OTP application version information for use with erlang_toolchain

This script extracts version information for all OTP applications from the
current Erlang runtime by reading the installed_application_versions file,
which is the canonical source maintained by OTP itself.

Usage:
    python3 generate_otp_versions.py [output_file.bzl]

Example:
    $ python3 generate_otp_versions.py my_otp_versions.bzl
    Generated: my_otp_versions.bzl
    ERTS version: 15.1
    OTP release: 27
    Applications: 34

Then in your BUCK file:
    load(":my_otp_versions.bzl", "get_otp_applications", "get_erts_version")

    erlang_toolchain(
        name = "erlang-27",
        applications = get_otp_applications(),
        erts_version = get_erts_version(),
        ...
    )
"""

import os
import subprocess
import sys
from datetime import datetime
from typing import Dict, List


def get_erl_command() -> str:
    """Find the erl command in PATH."""
    erl = subprocess.run(["which", "erl"], capture_output=True, text=True, check=False)
    if erl.returncode != 0:
        raise RuntimeError(
            "Could not find 'erl' command. Please ensure Erlang is installed and in PATH."
        )
    return erl.stdout.strip()


def run_erl_eval(expression: str) -> str:
    """Execute an Erlang expression and return the output."""
    cmd = [
        "erl",
        "-eval",
        f'io:format("~s", [{expression}])',
        "-s",
        "init",
        "stop",
        "-noshell",
    ]
    result = subprocess.run(cmd, capture_output=True, text=True, check=True)
    return result.stdout.strip()


def get_erts_version() -> str:
    """Get the ERTS version from the current Erlang installation."""
    return run_erl_eval("erlang:system_info(version)")


def get_otp_release() -> str:
    """Get the OTP release number."""
    return run_erl_eval("erlang:system_info(otp_release)")


def get_releases_dir() -> str:
    """Get the OTP releases directory path for the current OTP release."""
    return run_erl_eval(
        'filename:join([code:root_dir(), "releases", erlang:system_info(otp_release)])'
    )


def get_otp_applications() -> List[Dict[str, str]]:
    """
    Get all OTP applications with their versions by reading the
    installed_application_versions file.

    This file is maintained by OTP and contains the canonical list of
    all installed applications with their exact versions.

    Returns:
        List of dicts with 'name' and 'version' keys, sorted by name
    """
    releases_dir = get_releases_dir()
    installed_apps_file = os.path.join(releases_dir, "installed_application_versions")

    if not os.path.exists(installed_apps_file):
        raise RuntimeError(
            f"Could not find installed_application_versions file at: {installed_apps_file}\n"
            f"This file should exist in a standard Erlang/OTP installation."
        )

    applications = []

    with open(installed_apps_file, "r") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue

            # Format is: appname-version
            # Split on first hyphen to separate name from version
            parts = line.split("-", 1)
            if len(parts) == 2:
                name, version = parts
                applications.append({"name": name, "version": version})

    # Sort by name for consistent output
    applications.sort(key=lambda x: x["name"])

    return applications


def generate_bzl_content(
    erts_version: str, otp_release: str, applications: List[Dict[str, str]]
) -> str:
    """Generate the Starlark (.bzl) file content."""

    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # Header
    lines = [
        "# Copyright (c) Meta Platforms, Inc. and affiliates.",
        "#",
        "# This source code is dual-licensed under either the MIT license found in the",
        "# LICENSE-MIT file in the root directory of this source tree or the Apache",
        "# License, Version 2.0 found in the LICENSE-APACHE file in the root directory",
        "# of this source tree. You may select, at your option, one of the",
        "# above-listed licenses.",
        "",
        "# Auto-generated OTP application version information",
        "# DO NOT EDIT THIS FILE MANUALLY",
        "#",
        f"# Generated on: {timestamp}",
        f"# Erlang/OTP: {otp_release}",
        f"# ERTS version: {erts_version}",
        f"# Applications: {len(applications)}",
        "#",
        "# To regenerate this file, run:",
        "#   python3 buck2/prelude/erlang/toolchain/generate_otp_versions.py <output_file>",
        "",
    ]

    # Applications list
    lines.append("_OTP_APPLICATIONS = [")
    for app in applications:
        lines.append(f'    {{"name": "{app["name"]}", "version": "{app["version"]}"}},')
    lines.append("]")
    lines.append("")

    # Constants
    lines.append(f'_ERTS_VERSION = "{erts_version}"')
    lines.append(f'_OTP_RELEASE = "{otp_release}"')
    lines.append("")

    # Helper functions
    lines.extend(
        [
            "def get_otp_applications():",
            '    """Returns list of OTP applications with versions for erlang_toolchain.',
            "",
            "    Returns:",
            "        List of dicts with 'name' and 'version' keys",
            "",
            "    Example:",
            "        erlang_toolchain(",
            '            name = "my-toolchain",',
            "            applications = get_otp_applications(),",
            "            erts_version = get_erts_version(),",
            "            ...",
            "        )",
            '    """',
            "    return _OTP_APPLICATIONS",
            "",
            "def get_erts_version():",
            '    """Returns the ERTS version string.',
            "",
            "    Returns:",
            '        String containing the ERTS version (e.g., "15.1")',
            '    """',
            "    return _ERTS_VERSION",
            "",
            "def get_otp_release():",
            '    """Returns the OTP release number.',
            "",
            "    Returns:",
            '        String containing the OTP release (e.g., "27")',
            '    """',
            "    return _OTP_RELEASE",
        ]
    )

    return "\n".join(lines) + "\n"


def main():
    """Main entry point."""
    if len(sys.argv) > 2:
        print(f"Usage: {sys.argv[0]} [output_file.bzl]", file=sys.stderr)
        sys.exit(1)

    output_file = sys.argv[1] if len(sys.argv) == 2 else "otp_versions.bzl"

    try:
        print("Extracting OTP version information...")

        # Get version information
        erts_version = get_erts_version()
        otp_release = get_otp_release()
        applications = get_otp_applications()

        # Generate .bzl file content
        bzl_content = generate_bzl_content(erts_version, otp_release, applications)

        # Write to file
        with open(output_file, "w") as f:
            f.write(bzl_content)

        # Print summary
        print(f"Generated: {output_file}")
        print(f"ERTS version: {erts_version}")
        print(f"OTP release: {otp_release}")
        print(f"Applications: {len(applications)}")

    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
