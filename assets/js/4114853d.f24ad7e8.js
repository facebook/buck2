"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[38225],{28453:(e,i,t)=>{t.d(i,{R:()=>o,x:()=>r});var n=t(96540);const s={},a=n.createContext(s);function o(e){const i=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(a.Provider,{value:i},e.children)}},97821:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"rfcs/audit_visibility","title":"buck2 audit visibility command","description":"Context","source":"@site/../docs/rfcs/audit_visibility.md","sourceDirName":"rfcs","slug":"/rfcs/audit_visibility","permalink":"/docs/rfcs/audit_visibility","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{}}');var s=t(74848),a=t(28453);const o={},r="buck2 audit visibility command",c={},l=[{value:"Context",id:"context",level:2},{value:"Proposed Solution: <code>audit visibility</code> command",id:"proposed-solution-audit-visibility-command",level:2},{value:"Usage and Invocation",id:"usage-and-invocation",level:2}];function d(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsxs)(i.h1,{id:"buck2-audit-visibility-command",children:[(0,s.jsx)(i.code,{children:"buck2 audit visibility"})," command"]})}),"\n",(0,s.jsx)(i.h2,{id:"context",children:"Context"}),"\n",(0,s.jsxs)(i.p,{children:["Buck has a concept of Visibility for every target. It allows users to define,\nfor each target, the targets it can depend on and targets that can depend on it.\nVisibility is specified as an allowlist of targets/target patterns, and any\ntarget used that falls outside of the allowlist fails visibility checking.\nVisibility pattern can be specified on ",(0,s.jsx)(i.code,{children:"visibility"})," and ",(0,s.jsx)(i.code,{children:"within_view"})," attributes\nin buildfiles and\n",(0,s.jsx)(i.a,{href:"https://www.internalfb.com/intern/wiki/Buck-users/Key_Concepts/Package_Files/",children:"PACKAGE files"}),"."]}),"\n",(0,s.jsxs)(i.p,{children:["Visibility is important to lots of codebase maintainers because it can be used\nto keep projects from pulling in unwanted dependencies. As some examples, App\nCore teams are using Buck visibility as a\n",(0,s.jsx)(i.a,{href:"https://fb.prod.workplace.com/groups/2292177024436518/permalink/3112235492430663/",children:"replacement to current supermodules for protecting app modularity"}),".\nInstagram's using visibility to\n",(0,s.jsx)(i.a,{href:"https://fb.prod.workplace.com/groups/devx.build.bffs/posts/5169450219756775/?comment_id=5169500636418400",children:"protect modularity and define Link Groups used for build speed optimizations"}),".\nThere's interest from various DevX teams in using Buck visibility on\n",(0,s.jsx)(i.a,{href:"https://www.internalfb.com/intern/wiki/Buck-users/Key_Concepts/Package_Files/",children:"PACKAGE files"}),"\nto\n",(0,s.jsx)(i.a,{href:"https://fb.prod.workplace.com/groups/devx.build.bffs/posts/5169450219756775/",children:"enforce repo boundaries, which will allow target determinators to migrate off of sparse profiles and onto Eden"}),",\nalthough visibility in its current form is likely not fit for enforcing such\nrepo boundaries. Visibility has also been used to enforce\n",(0,s.jsx)(i.a,{href:"https://fb.workplace.com/groups/buckeng/permalink/4392940254087889/",children:"requirements that only certain targets are allowed to depend on targets in fbcode/scripts"}),"."]}),"\n",(0,s.jsx)(i.p,{children:"For perf reasons, buck2 doesn't always enforce visibility. Instead, it only\nenforces visibility on construction of the configured target graph. Visibility\nchecking is expensive memory-wise because it requires tracking all deps at each\nnode. When constructing configured target graph, this cost is already paid for\nwhen buck2 checks transitive target compatibility. When constructing the\nunconfigured target graph, however, this is costly, so we avoid checking\nvisibility there. (Note that buck does not allow you to specify selects in\nvisibility attributes.)"}),"\n",(0,s.jsxs)(i.p,{children:["In practice, this means that commands like ",(0,s.jsx)(i.code,{children:"cquery"})," and ",(0,s.jsx)(i.code,{children:"build"})," can enforce\nvisibility whereas commands like ",(0,s.jsx)(i.code,{children:"uquery"})," and ",(0,s.jsx)(i.code,{children:"targets"})," cannot. Having\nvisibility checked only on the configured target graph is problematic for 2\nreasons:"]}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsx)(i.p,{children:"Visibility is only checked on configured deps after selects are resolved, so\nit's possible for a target to pass visibility checking in one configuration\nbut fail visibility checking in another. For example, a target may pass\nvisibility checking on a linux configuration but fail visibility checking on\nmac configuration if it has a bad mac-only dependency. This makes visibility\nenforcement more difficult because now you have to query the same graph in\nboth linux and mac configuration before you know that visibility is always\nvalid."}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsx)(i.p,{children:"Uquery (querying the unconfigured target graph) has better performance than\ncquery (querying the configured target graph). Big-O wise, uquery scales with\nO(# of targets) whereas cquery scales with O((# number of configurations) x\n(# of targets)). Having a way to check visibility on unconfigured target\ngraph can be much cheaper than doing so on configured target graph."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.h2,{id:"proposed-solution-audit-visibility-command",children:["Proposed Solution: ",(0,s.jsx)(i.code,{children:"audit visibility"})," command"]}),"\n",(0,s.jsxs)(i.p,{children:["It's clear that we need a way to check visibility on the unconfigured target\ngraph, but we don't want ",(0,s.jsx)(i.code,{children:"buck2 uquery"})," and ",(0,s.jsx)(i.code,{children:"buck2 targets"})," to regress in memory\nuse. To get the best of both worlds, I propose adding a separate command to\nbuck2, ",(0,s.jsx)(i.code,{children:"buck2 audit visibility"}),", that will check visibility on the unconfigured\ntarget graph. Instead of checking on construction of the unconfigured target\ngraph, this command will check after construction, which will avoid any memory\nregression. The tradeoff is that the visibility checking won't be cached, and\nrerunning ",(0,s.jsx)(i.code,{children:"audit visibility"})," will rerun visibility checking on each invocation."]}),"\n",(0,s.jsx)(i.h2,{id:"usage-and-invocation",children:"Usage and Invocation"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.code,{children:"buck2 audit visibility"})," command will take in a list of target patterns as well\nas common build args like config flags and mode files as args. It will construct\nthe unconfigured target graph based on the ",(0,s.jsx)(i.strong,{children:"transitive deps"})," of those targets\nand check that this graph has valid visibility. Checking transitive deps matches\nthe behavior of visibility checking on cquery, but we may revisit this decision\nin the future if there is a need for just verifying the immediate dependencies."]}),"\n",(0,s.jsx)(i.p,{children:"For example, an invocation to check visibility on the transitive closure of\nfbobjc can be"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-shell",children:"buck2 audit visibility fbsource//fbobjc/...\n"})}),"\n",(0,s.jsxs)(i.p,{children:["It cannot be used to check that a target has a valid visibility with respect to\ntargets outside of the transitive closure of its deps. For example,\n",(0,s.jsx)(i.code,{children:"buck2 audit visibility fbcode//buck2/starlark-rust/starlark:starlark"})," will just\ncheck that all transitive deps of ",(0,s.jsx)(i.code,{children:"starlark"})," target (including ",(0,s.jsx)(i.code,{children:"starlark"}),"\ntarget) have valid visibility with respect to each other. It will not check that\nany targets that depend on ",(0,s.jsx)(i.code,{children:"starlark"})," respect ",(0,s.jsx)(i.code,{children:"starlark"})," target's visibility\nattribute."]})]})}function h(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);