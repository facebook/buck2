# Copyright (c) Meta Platforms, Inc. and affiliates.
#
# This source code is dual-licensed under either the MIT license found in the
# LICENSE-MIT file in the root directory of this source tree or the Apache
# License, Version 2.0 found in the LICENSE-APACHE file in the root directory
# of this source tree. You may select, at your option, one of the
# above-listed licenses.

# Analyse some python files/targets and produce data for the Pyrefly IDE.
# See <https://github.com/facebook/pyrefly>.

# Missing features:
#
# * Manifests for prebuilt library (i.e. 3p python libraries). I think getting those would actually require some extracting and reading from disk (https://github.com/facebook/buck2/blob/2b6c84ef285519a86ad793800296b3cda17e85dd/prelude/python/prebuilt_python_library.bzl#L56)
# * Anything logic that tries to inject / alter srcs or deps within the python rule need to be replicated, e.g.
#   + https://github.com/facebook/buck2/blob/2b6c84ef285519a86ad793800296b3cda17e85dd/prelude/python/python_library.bzl#L188-L192
#   + https://github.com/facebook/buck2/blob/2b6c84ef285519a86ad793800296b3cda17e85dd/prelude/python/python_library.bzl#L339-L341
#   + https://github.com/facebook/buck2/blob/2b6c84ef285519a86ad793800296b3cda17e85dd/prelude/python/python_library.bzl#L290-L306

# @oss-enable: load("@prelude//python:typing.bzl", "DEFAULT_PY_VERSION")
load("@prelude//python/meta_only:config.bzl", "DEFAULT_PY_VERSION")  # @oss-disable

_MODULE_SUFFIXES = set([
    ".dll",
    ".py",
    ".pyi",
    ".pyd",
    ".so",
])

def _append_to_or_set_list(
        mapping: dict[str, list[str | bxl.EnsuredArtifact]],
        key: str,
        value: str | bxl.EnsuredArtifact) -> None:
    if key in mapping:
        mapping[key].append(value)
    else:
        mapping[key] = [value]

def _append_or_default_if_module(
        srcs: dict[str, list[str | bxl.EnsuredArtifact]],
        module: str,
        path: str | bxl.EnsuredArtifact) -> None:
    if isinstance(path, bxl.EnsuredArtifact):
        # we can't filter ensured artifacts, since there's no way to inspect the path
        _append_to_or_set_list(srcs, module, path)
        return
    for suffix in _MODULE_SUFFIXES:
        if path.endswith(suffix):
            _append_to_or_set_list(srcs, module, path)
            return

# Produce a list of all the targets that I care about.
# This should be everything reachable from the command line arguments.
def _list_targets(ctx: bxl.Context) -> bxl.ConfiguredTargetSet:
    cquery = ctx.cquery()
    uquery = ctx.uquery()
    files = cquery.deps(uquery.owner(ctx.cli_args.file), 0)  # deps(0) to convert to configured
    targets = cquery.eval("kind('python_library|alias|genrule', %s)", ctx.cli_args.target)
    res = files
    for target in targets.values():
        res += target

    return cquery.deps(res, filter = "kind('python_library|alias|genrule|cxx_python_extension', target_deps())")

def _clean_module(base_module: str, module: str) -> str:
    base_module = base_module.removesuffix("/").replace("/", ".")
    module = module.replace("/", ".").removesuffix(".pyi").removesuffix(".py").removesuffix("__init__").removesuffix(".")
    sep = ""
    if len(base_module) != 0 and len(module) != 0:
        sep = "."
    return (base_module + sep + module).removeprefix("gen-py3.").removeprefix("gen-python.")

# Set common fields for a target entry.
# NOTE: This function doesn't populate `srcs`. Instead return an empty `srcs` dict for downstream logic to populate.
def _set_entry_common_fields(
        entry: dict,
        attrs: bxl.LazyAttrs,
        fs: bxl.Filesystem,
        target: bxl.ConfiguredTargetNode,
        known_targets: dict[TargetLabel, bxl.ConfiguredTargetNode]) -> dict[str, list[str | bxl.EnsuredArtifact]]:
    srcs = {}
    deps = []
    entry["srcs"] = srcs
    entry["deps"] = deps
    entry["buildfile_path"] = fs.project_rel_path(target.buildfile_path)
    python_version = attrs.get("py_version_for_type_checking")
    entry["python_version"] = python_version.value() if python_version != None and python_version.value() != None else DEFAULT_PY_VERSION

    # TODO(connernilsen): replace with actual platform later
    entry["python_platform"] = "linux"

    # Get buck.deps first, then fall back to deps. buck.deps might
    # have extra targets we eventually exclude or stop processing, which is fine.
    attr_deps = attrs.get("buck.deps") or attrs.get("deps")
    if attr_deps == None:
        fail(target.rule_type)
    attr_deps = attr_deps.value()
    for dep in attr_deps:
        dep = dep.raw_target()
        if dep in known_targets:
            deps.append(str(dep))

    return srcs

def _handle_alias(
        entry: dict,
        attrs: bxl.LazyAttrs,
        target: bxl.ConfiguredTargetNode) -> None:
    actual = attrs.get("actual")
    if actual != None and actual.value() != None:
        entry["alias"] = actual.value().raw_target()
    else:
        fail("Alias has no actual target".format(target.label))

def _handle_python_extension(
        entry: dict,
        attrs: bxl.LazyAttrs,
        fs: bxl.Filesystem,
        target: bxl.ConfiguredTargetNode,
        known_targets: dict[TargetLabel, bxl.ConfiguredTargetNode]) -> None:
    _set_entry_common_fields(entry, attrs, fs, target, known_targets)

def _handle_genrule(
        entry: dict,
        attrs: bxl.LazyAttrs,
        fs: bxl.Filesystem,
        target: bxl.ConfiguredTargetNode,
        known_targets: dict[TargetLabel, bxl.ConfiguredTargetNode],
        to_remove: dict[str, None],
        to_build: list,
        to_insert: list,
        genrule_to_insert: list) -> None:
    labels = attrs.get("labels")
    if "custom_rule_internal" in labels.value():
        # skip internal targets, since they will be materialized as part
        # of their including target
        to_remove[str(target.label.raw_target())] = None
        return

    srcs = _set_entry_common_fields(entry, attrs, fs, target, known_targets)
    to_build.append(target)

    # Only one of these will have a value, but get both of them now since
    # it's easy.
    out = attrs.get("out")
    outs = attrs.get("outs")
    if out != None and out.value() != None:
        items = {out.value(): out.value()}
    elif outs != None and outs.value() != None:
        items = outs.value()
    else:
        fail(target)

    if len(items) == 1:
        module_path = list(items.keys())[0]
        for suffix in _MODULE_SUFFIXES:
            if module_path.endswith(suffix):
                to_insert.append((srcs, _clean_module("", module_path), target.label.with_sub_target()))
                break
    else:
        # we need to handle building the full genrule
        genrule_to_insert.append((target, entry))
        for (module_path, src_paths) in items.items():
            if len(src_paths) < 1:
                fail("Target src has no output path: {}".format(target.label))
            for suffix in _MODULE_SUFFIXES:
                if module_path.endswith(suffix):
                    _append_or_default_if_module(srcs, _clean_module("", module_path), src_paths[0])
                    break

def _handle_python_library(
        entry: dict,
        attrs: bxl.LazyAttrs,
        fs: bxl.Filesystem,
        target: bxl.ConfiguredTargetNode,
        known_targets: dict[TargetLabel, bxl.ConfiguredTargetNode],
        to_remove: dict[str, None],
        to_build: list,
        to_insert: list) -> None:
    base_module = attrs.get("base_module")
    if base_module != None and base_module.value() != None:
        base_module = base_module.value()
    else:
        base_module = target.label.package

    srcs = _set_entry_common_fields(entry, attrs, fs, target, known_targets)

    # add type stubs first, so that they're preferred by Pyrefly
    type_stubs = attrs.get("type_stubs")
    type_stubs = {} if type_stubs == None else type_stubs.value()
    _get_and_materialize_sources(
        type_stubs,
        to_remove,
        base_module,
        srcs,
        to_build,
        to_insert,
        fs,
    )

    # python_binary might be the root target, which doesn't have `srcs`.
    attr_srcs = attrs.get("srcs")
    attr_srcs = {} if attr_srcs == None else attr_srcs.value()
    _get_and_materialize_sources(
        attr_srcs,
        to_remove,
        base_module,
        srcs,
        to_build,
        to_insert,
        fs,
    )

def _build_generated_files(
        ctx: bxl.Context,
        to_build: list,
        to_insert: list,
        genrule_to_insert: list) -> None:
    if not to_build:
        return

    built = ctx.build(to_build)
    ensured = ctx.output.ensure_multiple(built)

    # handle individual generated files
    for srcs, module_name, target in to_insert:
        _append_or_default_if_module(srcs, module_name, ensured[target][0].rel_path())

    # handle genrules
    for target, entry in genrule_to_insert:
        label = target.label.with_sub_target()
        relative_to = ensured[label][0].rel_path()
        entry["relative_to"] = relative_to

def _get_and_materialize_sources(
        to_add: list | dict,
        to_remove: dict[str, None],
        base_module: str,
        srcs: dict[str, list[str | bxl.EnsuredArtifact]],
        to_build: list,
        to_insert: list,
        fs: bxl.Filesystem):
    if type(to_add) == type([]):
        for v in to_add:
            if getattr(v, "is_source", False):
                _append_or_default_if_module(
                    srcs,
                    _clean_module(base_module, v.short_path),
                    fs.project_rel_path(v),
                )
            elif type(v) != "Label" and getattr(v, "short_path"):
                to_build.append(v)
                to_insert.append((srcs, _clean_module(base_module, v.short_path), v))
            elif type(v) == "Label" and "=" in str(v.raw_target()):
                # handle special type_stubs target types for Pytorch
                # for these, we want to use the part after the `=` as the
                # full module name, the part before as a target we don't want
                # to materialize, and the whole label as a target to build.
                # Don't materialize the first part of the target, since
                # otherwise the owning target for the file will be ambiguous,
                # and we will likely not be able to find any circular imports
                # these genrules expect.
                split_target = str(v.raw_target()).split("=")
                if len(split_target) != 2:
                    return
                to_remove[str(v.raw_target())] = None
                to_remove[str(split_target[0])] = None
                relative_path = split_target[1]
                to_build.append(v)
                to_insert.append((srcs, _clean_module("", relative_path), v))
    elif type(to_add) == type({}):
        for k, v in to_add.items():
            if getattr(v, "is_source", False):
                _append_or_default_if_module(
                    srcs,
                    _clean_module(base_module, k),
                    fs.project_rel_path(v),
                )
            else:
                to_build.append(v)
                to_insert.append((srcs, _clean_module(base_module, k), v))

def _main(ctx: bxl.Context) -> None:
    fs = ctx.fs
    to_remove = {}  # Set of targets to remove at the end
    to_build = []  # List of targets I need to build
    to_insert = []  # Triples of (target srcs ref, module name, artifact) to insert after building
    genrule_to_insert = []  # Doubles of (target, entry) to insert after building
    entries = {}  # dict[target, {"deps": list[target], "srcs": dict[qualified_path, list[files]]}]
    json = {"db": entries, "root": ctx.root()}

    # We only want to add `deps` to targets that are in the output.
    known_targets = {
        x.label.raw_target(): x
        for x in _list_targets(ctx)
        if x.rule_type not in (
            "forward",
            "prelude//rules.bzl:command_alias",
            "prelude//rules.bzl:export_file",
            "prelude//rules.bzl:filegroup",
        ) and x.label.name != "restricted_bin"
    }

    for raw_target, x in known_targets.items():
        if str(raw_target) in to_remove:
            continue

        attrs = x.attrs_lazy()
        entry = {}
        entries[str(x.label.raw_target())] = entry

        if x.rule_type == "prelude//rules.bzl:alias" or x.rule_type.endswith("_fbcode_configured_alias"):
            _handle_alias(entry, attrs, x)
        elif x.rule_type.endswith("_fbcode_configured_alias_transition"):
            pass
        elif x.rule_type.endswith("rust_proc_macro_alias"):
            pass
        elif x.rule_type == "prelude//rules.bzl:cxx_python_extension":
            _handle_python_extension(entry, attrs, fs, x, known_targets)
        elif "genrule" in x.rule_type:
            _handle_genrule(entry, attrs, fs, x, known_targets, to_remove, to_build, to_insert, genrule_to_insert)
        elif "python_library" in x.rule_type:
            _handle_python_library(entry, attrs, fs, x, known_targets, to_remove, to_build, to_insert)
        else:
            fail("Unknown rule type `{}` for target `{}`".format(x.rule_type, x.label.raw_target()))

    _build_generated_files(ctx, to_build, to_insert, genrule_to_insert)

    # remove any targets we decided we shouldn't output
    for remove in to_remove:
        entries.pop(remove)

    ctx.output.print_json(json)

main = bxl_main(
    doc = """Produce data required for the Pyrefly IDE.

    Takes a list of target patterns and build the right data to check each.
    """,
    impl = _main,
    cli_args = {
        "file": cli_args.list(
            cli_args.string(doc = "File to analyse"),
            default = [],
        ),
        "target": cli_args.list(
            cli_args.string(doc = "Target pattern to analyse"),
            default = [],
        ),
    },
)
