"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[39721],{28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var a=n(96540);const s={},r=a.createContext(s);function i(e){const t=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(r.Provider,{value:t},e.children)}},30635:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"rule_authors/incremental_actions","title":"Incremental Actions","description":"It\'s possible to make certain Buck2 actions behave incrementally, that is, to","source":"@site/../docs/rule_authors/incremental_actions.md","sourceDirName":"rule_authors","slug":"/rule_authors/incremental_actions","permalink":"/docs/rule_authors/incremental_actions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"incremental_actions","title":"Incremental Actions"},"sidebar":"main","previous":{"title":"Observability and Optimization","permalink":"/docs/rule_authors/optimization"},"next":{"title":"Alias","permalink":"/docs/rule_authors/alias"}}');var s=n(74848),r=n(28453);const i={id:"incremental_actions",title:"Incremental Actions"},o=void 0,c={},l=[];function d(e){const t={code:"code",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"It's possible to make certain Buck2 actions behave incrementally, that is, to\nproduce results for a current invocation based on the result from the previous\nrun. Incrementality could significantly improve performance of some actions such\nas packaging (such as Apple App Bundles) or linking (MSVC incremental linking)."}),"\n",(0,s.jsx)(t.p,{children:"There are two essential requirements to make an action incremental:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The result from the previous run should be accessible."}),"\n",(0,s.jsx)(t.li,{children:"An understanding of which parts of the result need to be updated; it should be\neasy to compare inputs from a previous run with inputs from the current run\nand detect those changed."}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["The only way to run user-defined commands in Buck2 is with ",(0,s.jsx)(t.code,{children:"ctx.actions.run"}),".\nBoth of the above requirements are met via its ",(0,s.jsx)(t.code,{children:"metadata_env_var"}),",\n",(0,s.jsx)(t.code,{children:"metadata_path"})," and ",(0,s.jsx)(t.code,{children:"no_outputs_cleanup"})," parameters."]}),"\n",(0,s.jsxs)(t.p,{children:["When the ",(0,s.jsx)(t.code,{children:"no_outputs_cleanup"})," flag is turned on, Buck2 won't perform any\ndeletion of old outputs for the action. That means the result from the previous\nrun will be accessible, but the user script has to detect which parts of it\nshould be deleted and perform a manual cleanup."]}),"\n",(0,s.jsxs)(t.p,{children:["When the ",(0,s.jsx)(t.code,{children:"metadata_env_var"})," and ",(0,s.jsx)(t.code,{children:"metadata_path"})," parameters are present, Buck2\nwill create a JSON file on a disk before actually executing the command. The\nfile will contain a list of paths and hash digests for every command action\ninput. All paths in the file are relative to the Buck2 project root. Symlinks\nare not included in metadata because it is possible for the user script to\nresolve symlink and use a resolved path to get the destination hash digest from\naction metadata if it's needed, as shown in the following JSON example:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",children:'{\n  "version": 1,\n  "digests": [\n    {\n      "path": "buck-out/v2/gen/cell/configuration_hash/path/to/target/__target_name__/generated_file",\n      "digest": "da39a3ee5e6b4b0d3255bfef95601890afd80709:10"\n    },\n    ...\n  ]\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"A user script that is run as a part of an action execution is responsible for\nparsing the JSON file."}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"version"})," field is bumped every time there is a non-backwards compatible\nchange to the format of the file. The user script should verify that the\nprovided data is of a supported version and should be updated accordingly when\nthe current version is newer than the supported one."]}),"\n",(0,s.jsxs)(t.p,{children:["The path of the JSON file is provided to the user script via an environment\nvariable with a key equal to ",(0,s.jsx)(t.code,{children:"metadata_env_var"}),". The user is able to specify the\npart of the path relative to the result directory via ",(0,s.jsx)(t.code,{children:"metadata_path"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"For example, if some rule implementation has the following code:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'result = ctx.actions.declare_output("result")\ncommand = cmd_args(["my_script.py", "--output", result.as_output()])\nctx.actions.run(\n    command,\n    category = "my_category",\n    metadata_env_var = "ACTION_METADATA",\n    metadata_path = "action_metadata.json",\n    no_outputs_cleanup = True,\n)\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Then ",(0,s.jsx)(t.code,{children:"my_script.py"})," will be executed as:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-shell",children:"ACTION_METADATA=project/relative/path/to/target/action_metadata.json my_script.py --output resolved/path/to/result\n"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"my_script.py"})," is responsible for reading the ",(0,s.jsx)(t.code,{children:"ACTION_METADATA"})," environment\nvariable and parsing a JSON file with the action metadata."]}),"\n",(0,s.jsxs)(t.p,{children:["Parsed metadata provides information about inputs for the current run, but the\nscript needs somehow to obtain similar information about inputs from the\nprevious run. Such information could just be another output of the user script\n(as with the previous result, it won't be deleted when\n",(0,s.jsx)(t.code,{children:"no_outputs_cleanup = True"}),"). The Format of such a file is an implementation\ndetail of the user script, but at the very least it should contain a list of\nevery source that was used to form the result and hash digests for such sources."]}),"\n",(0,s.jsx)(t.p,{children:"The rule implementation would look something like the following:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'result = ctx.actions.declare_output("result")\nstate = ctx.actions.declare_output("incremental_state.json")\ncommand = cmd_args(["my_script.py", "--output", result.as_output(), "--incremental-state", state.as_output()])\nctx.actions.run(\n    command,\n    category = "my_category",\n    metadata_env_var = "ACTION_METADATA",\n    metadata_path = "action_metadata.json",\n    no_outputs_cleanup = True,\n)\n'})}),"\n",(0,s.jsx)(t.p,{children:"The user script would then:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Parse ",(0,s.jsx)(t.code,{children:"incremental_state.json"}),' and delete it. Deletion prior to amending the\nresult is important so it doesn\'t result in a situation where an incremental\nstate file is out of sync with the result when the user script fails while\nchanging the result. Such a corrupted state might lead to subsequent\nincorrect builds reported as "successful".']}),"\n",(0,s.jsx)(t.li,{children:"Parse action metadata file, compute what is needed to update the result, and\namend it accordingly."}),"\n",(0,s.jsxs)(t.li,{children:["Calculate the new state and write it into the new ",(0,s.jsx)(t.code,{children:"incremental_state.json"}),"."]}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);